package com.mapboxnavigation

import android.annotation.SuppressLint
import android.content.res.Configuration
import android.content.res.Resources
import android.graphics.BitmapFactory
import android.util.Log
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.widget.FrameLayout
import com.facebook.react.bridge.Arguments
import com.facebook.react.uimanager.ThemedReactContext
import com.facebook.react.uimanager.events.RCTEventEmitter
import com.google.gson.JsonObject
import com.mapbox.api.directions.v5.DirectionsCriteria
import com.mapbox.api.directions.v5.models.RouteOptions
import com.mapbox.bindgen.Expected
import com.mapbox.common.location.Location
import com.mapbox.geojson.Feature
import com.mapbox.geojson.FeatureCollection
import com.mapbox.geojson.LineString
import com.mapbox.geojson.Point
import com.mapbox.maps.CameraOptions
import com.mapbox.maps.EdgeInsets
import com.mapbox.maps.ImageHolder
import com.mapbox.maps.LayerPosition
import com.mapbox.maps.plugin.LocationPuck2D
import com.mapbox.maps.plugin.animation.camera
import com.mapbox.maps.plugin.compass.compass
import com.mapbox.maps.plugin.locationcomponent.location
import com.mapbox.maps.plugin.gestures.addOnMapClickListener
import com.mapbox.maps.extension.style.sources.getSourceAs
import com.mapbox.maps.RenderedQueryGeometry
import com.mapbox.maps.RenderedQueryOptions
import com.mapbox.maps.ScreenCoordinate
import com.mapbox.maps.viewannotation.ViewAnnotationManager
import com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI
import com.mapbox.navigation.base.TimeFormat
import com.mapbox.navigation.base.extensions.applyDefaultNavigationOptions
import com.mapbox.navigation.base.extensions.applyLanguageAndVoiceUnitOptions
import com.mapbox.navigation.base.formatter.DistanceFormatterOptions
import com.mapbox.navigation.base.formatter.UnitType
import com.mapbox.navigation.base.options.NavigationOptions
import com.mapbox.navigation.base.route.NavigationRoute
import com.mapbox.navigation.base.route.NavigationRouterCallback
import com.mapbox.navigation.base.route.RouterFailure
import com.mapbox.navigation.base.route.RouterOrigin
import com.mapbox.navigation.base.trip.model.RouteLegProgress
import com.mapbox.navigation.base.trip.model.RouteProgress
import com.mapbox.navigation.core.MapboxNavigation
import com.mapbox.navigation.core.MapboxNavigationProvider
import com.mapbox.navigation.core.arrival.ArrivalObserver
import com.mapbox.navigation.core.directions.session.RoutesObserver
import com.mapbox.navigation.core.formatter.MapboxDistanceFormatter
import com.mapbox.navigation.core.trip.session.LocationMatcherResult
import com.mapbox.navigation.core.trip.session.LocationObserver
import com.mapbox.navigation.core.trip.session.RouteProgressObserver
import com.mapbox.navigation.core.trip.session.VoiceInstructionsObserver
import com.mapbox.navigation.tripdata.maneuver.api.MapboxManeuverApi
import com.mapbox.navigation.tripdata.progress.api.MapboxTripProgressApi
import com.mapbox.navigation.tripdata.progress.model.DistanceRemainingFormatter
import com.mapbox.navigation.tripdata.progress.model.EstimatedTimeToArrivalFormatter
import com.mapbox.navigation.tripdata.progress.model.PercentDistanceTraveledFormatter
import com.mapbox.navigation.tripdata.progress.model.TimeRemainingFormatter
import com.mapbox.navigation.tripdata.progress.model.TripProgressUpdateFormatter
import com.mapbox.navigation.tripdata.speedlimit.api.MapboxSpeedInfoApi
import com.mapbox.navigation.ui.base.util.MapboxNavigationConsumer
import com.mapbox.navigation.ui.components.maneuver.model.ManeuverPrimaryOptions
import com.mapbox.navigation.ui.components.maneuver.model.ManeuverSecondaryOptions
import com.mapbox.navigation.ui.components.maneuver.model.ManeuverSubOptions
import com.mapbox.navigation.ui.components.maneuver.model.ManeuverViewOptions
import com.mapbox.navigation.ui.components.maneuver.view.MapboxManeuverView
import com.mapbox.navigation.ui.maps.NavigationStyles
import com.mapbox.navigation.ui.maps.camera.NavigationCamera
import com.mapbox.navigation.ui.maps.camera.data.MapboxNavigationViewportDataSource
import com.mapbox.navigation.ui.maps.camera.lifecycle.NavigationBasicGesturesHandler
import com.mapbox.navigation.ui.maps.camera.state.NavigationCameraState
import com.mapbox.navigation.ui.maps.camera.transition.NavigationCameraTransitionOptions
import com.mapbox.navigation.ui.maps.location.NavigationLocationProvider
import com.mapbox.navigation.ui.maps.route.RouteLayerConstants.TOP_LEVEL_ROUTE_LINE_LAYER_ID
import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowApi
import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowView
import com.mapbox.navigation.ui.maps.route.arrow.model.RouteArrowOptions
import com.mapbox.navigation.ui.maps.route.callout.api.DefaultRouteCalloutAdapter
import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineApi
import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineView
import com.mapbox.navigation.ui.maps.route.line.model.MapboxRouteLineApiOptions
import com.mapbox.navigation.ui.maps.route.line.model.MapboxRouteLineViewOptions
import com.mapbox.navigation.ui.maps.route.line.model.RouteLineColorResources
import com.mapbox.navigation.voice.api.MapboxSpeechApi
import com.mapbox.navigation.voice.api.MapboxVoiceInstructionsPlayer
import com.mapbox.navigation.voice.model.SpeechAnnouncement
import com.mapbox.navigation.voice.model.SpeechError
import com.mapbox.navigation.voice.model.SpeechValue
import com.mapbox.navigation.voice.model.SpeechVolume
import com.mapboxnavigation.databinding.NavigationViewBinding
import java.util.Locale

/** Ponto de radar para exibi√ß√£o no mapa (id, coordenadas, limite de velocidade, tipo). */
data class RadarPoint(
        val id: String,
        val latitude: Double,
        val longitude: Double,
        val speedLimit: Double? = null,
        val type: String? = null // Tipo do radar: "semaforico", "fixo", "m√≥vel", etc.
)

@SuppressLint("ViewConstructor")
@OptIn(ExperimentalPreviewMapboxNavigationAPI::class)
class MapboxNavigationView(private val context: ThemedReactContext) :
        FrameLayout(context.baseContext) {
  private companion object {
    private const val BUTTON_ANIMATION_DURATION = 1500L
  }

  private var origin: Point? = null
  private var destination: Point? = null
  private var destinationTitle: String = "Destination"
  private var waypoints: List<Point> = listOf()
  private var waypointLegs: List<WaypointLegs> = listOf()
  private var distanceUnit: String = DirectionsCriteria.METRIC
  private var locale = Locale("pt", "BR")

  /** Bindings to the example layout. */
  private var binding: NavigationViewBinding =
          NavigationViewBinding.inflate(LayoutInflater.from(context), this, true)

  /**
   * Produces the camera frames based on the location and routing data for the [navigationCamera] to
   * execute.
   */
  private var viewportDataSource = MapboxNavigationViewportDataSource(binding.mapView.mapboxMap)

  /**
   * Used to execute camera transitions based on the data generated by the [viewportDataSource].
   * This includes transitions from route overview to route following and continuously updating the
   * camera as the location changes.
   */
  private var navigationCamera =
          NavigationCamera(binding.mapView.mapboxMap, binding.mapView.camera, viewportDataSource)

  /**
   * Mapbox Navigation entry point. There should only be one instance of this object for the app.
   * You can use [MapboxNavigationProvider] to help create and obtain that instance.
   */
  private var mapboxNavigation: MapboxNavigation? = null

  /*
   * Padding da c√¢mera: estilo Waze ‚Äî modal fixo embaixo, posi√ß√£o do usu√°rio jogada para cima.
   * Bottom = altura do modal (trip progress + speed + margens); top/laterais m√≠nimos.
   * Assim a c√¢mera mant√©m o usu√°rio na √°rea vis√≠vel acima do modal, sem sobreposi√ß√£o.
   */
  private val pixelDensity = Resources.getSystem().displayMetrics.density
  // Overview: rota inteira na tela; bottom um pouco maior para o modal
  private val overviewPadding: EdgeInsets by lazy {
    EdgeInsets(60.0 * pixelDensity, 40.0 * pixelDensity, 200.0 * pixelDensity, 40.0 * pixelDensity)
  }
  private val landscapeOverviewPadding: EdgeInsets by lazy {
    EdgeInsets(30.0 * pixelDensity, 380.0 * pixelDensity, 120.0 * pixelDensity, 20.0 * pixelDensity)
  }
  // Following: usu√°rio na √°rea acima do modal (~220dp para acomodar o floating card + margens)
  private val followingPadding: EdgeInsets by lazy {
    EdgeInsets(70.0 * pixelDensity, 44.0 * pixelDensity, 220.0 * pixelDensity, 44.0 * pixelDensity)
  }
  private val landscapeFollowingPadding: EdgeInsets by lazy {
    EdgeInsets(40.0 * pixelDensity, 400.0 * pixelDensity, 140.0 * pixelDensity, 40.0 * pixelDensity)
  }

  // Properties for radar functionality
  private var radars: List<RadarPoint> = listOf()
  private var filteredRadars: List<RadarPoint> = listOf() // Radares filtrados pr√≥ximos √† rota
  private var nearbyRadarIds: Set<String> = setOf()
  private var additionalBottomPadding: Double = 0.0
  private var lastAppliedAdditionalPadding: Double = 0.0
  private var isDestroyed: Boolean = false
  private var isStyleLoading: Boolean = false
  private var imageMissingListenerRegistered: Boolean = false
  private var alternativeRoutes: List<NavigationRoute> = listOf()
  private var currentRouteIndex: Int = 0
  private var currentRoute: NavigationRoute? = null // Rota atual para filtrar radares
  private var navigationInitialized: Boolean = false

  /**
   * Generates updates for the [MapboxManeuverView] to display the upcoming maneuver instructions
   * and remaining distance to the maneuver point.
   */
  private lateinit var maneuverApi: MapboxManeuverApi

  /**
   * Generates updates for the [MapboxTripProgressView] that include remaining time and distance to
   * the destination.
   */
  private var tripProgressApi: MapboxTripProgressApi? = null

  /**
   * Speed Limit API: formata dados de limite de velocidade para o MapboxSpeedInfoView. Ver:
   * https://docs.mapbox.com/android/navigation/guides/ui-components/speed-limit/
   */
  private val speedInfoApi: MapboxSpeedInfoApi by lazy { MapboxSpeedInfoApi() }

  /** Op√ß√µes de formata√ß√£o de dist√¢ncia (usadas tamb√©m pelo Speed Limit API). */
  private var distanceFormatterOptions: DistanceFormatterOptions? = null

  /**
   * Stores and updates the state of whether the voice instructions should be played as they come or
   * muted.
   */
  private var isVoiceInstructionsMuted = false
    set(value) {
      field = value
      if (value) {
        binding.soundButton.muteAndExtend(BUTTON_ANIMATION_DURATION)
        voiceInstructionsPlayer?.volume(SpeechVolume(0f))
      } else {
        binding.soundButton.unmuteAndExtend(BUTTON_ANIMATION_DURATION)
        voiceInstructionsPlayer?.volume(SpeechVolume(1f))
      }
    }

  /**
   * Extracts message that should be communicated to the driver about the upcoming maneuver. When
   * possible, downloads a synthesized audio file that can be played back to the driver.
   */
  private var speechApi: MapboxSpeechApi? = null

  /**
   * Plays the synthesized audio files with upcoming maneuver instructions or uses an on-device
   * Text-To-Speech engine to communicate the message to the driver. NOTE: do not use lazy
   * initialization for this class since it takes some time to initialize the system services
   * required for on-device speech synthesis. With lazy initialization there is a high risk that
   * said services will not be available when the first instruction has to be played.
   * [MapboxVoiceInstructionsPlayer] should be instantiated in `Activity#onCreate`.
   */
  private var voiceInstructionsPlayer: MapboxVoiceInstructionsPlayer? = null

  /** Observes when a new voice instruction should be played. */
  private val voiceInstructionsObserver = VoiceInstructionsObserver { voiceInstructions ->
    speechApi?.generate(voiceInstructions, speechCallback)
  }

  /**
   * Based on whether the synthesized audio file is available, the callback plays the file or uses
   * the fall back which is played back using the on-device Text-To-Speech engine.
   */
  private val speechCallback =
          MapboxNavigationConsumer<Expected<SpeechError, SpeechValue>> { expected ->
            expected.fold(
                    { error ->
                      // play the instruction via fallback text-to-speech engine
                      voiceInstructionsPlayer?.play(error.fallback, voiceInstructionsPlayerCallback)
                    },
                    { value ->
                      // play the sound file from the external generator
                      voiceInstructionsPlayer?.play(
                              value.announcement,
                              voiceInstructionsPlayerCallback
                      )
                    }
            )
          }

  /**
   * When a synthesized audio file was downloaded, this callback cleans up the disk after it was
   * played.
   */
  private val voiceInstructionsPlayerCallback =
          MapboxNavigationConsumer<SpeechAnnouncement> { value ->
            // remove already consumed file to free-up space
            speechApi?.clean(value)
          }

  /**
   * [NavigationLocationProvider] is a utility class that helps to provide location updates
   * generated by the Navigation SDK to the Maps SDK in order to update the user location indicator
   * on the map.
   */
  private val navigationLocationProvider = NavigationLocationProvider()

  // Observers
  private val offRouteObserver =
          com.mapbox.navigation.core.trip.session.OffRouteObserver { offRoute ->
            if (offRoute) {
              Log.d("MapboxNavigationView", "üöó Usu√°rio saiu da rota")
              val event = Arguments.createMap()
              event.putBoolean("offRoute", true)
              safeEmitEvent("onOffRoute", event)
            }
          }

  /**
   * RouteLine: Additional route line options are available through the [MapboxRouteLineViewOptions]
   * and [MapboxRouteLineApiOptions]. Notice here the
   * [MapboxRouteLineViewOptions.routeLineBelowLayerId] option. The map is made up of layers. In
   * this case the route line will be placed below the "road-label" layer which is a good default
   * for the most common Mapbox navigation related maps. You should consider if this should be
   * changed for your use case especially if you are using a custom map style.
   */
  private val routeLineViewOptions: MapboxRouteLineViewOptions by lazy {
    MapboxRouteLineViewOptions.Builder(context)
            /**
             * Route line related colors can be customized via the [RouteLineColorResources]. If
             * using the default colors the [RouteLineColorResources] does not need to be set as
             * seen here, the defaults will be used internally by the builder.
             */
            .routeLineColorResources(RouteLineColorResources.Builder().build())
            .routeLineBelowLayerId("road-label-navigation")
            .build()
  }

  private val routeLineApiOptions: MapboxRouteLineApiOptions by lazy {
    MapboxRouteLineApiOptions.Builder()
      .isRouteCalloutsEnabled(true)
      .build()
  }

  /**
   * RouteLine: This class is responsible for rendering route line related mutations generated by
   * the [routeLineApi]
   */
  private val routeLineView by lazy { MapboxRouteLineView(routeLineViewOptions) }

  /**
   * RouteLine: This class is responsible for generating route line related data which must be
   * rendered by the [routeLineView] in order to visualize the route line on the map.
   */
  private val routeLineApi: MapboxRouteLineApi by lazy { MapboxRouteLineApi(routeLineApiOptions) }

  /**
   * RouteArrow: This class is responsible for generating data related to maneuver arrows. The data
   * generated must be rendered by the [routeArrowView] in order to apply mutations to the map.
   */
  private val routeArrowApi: MapboxRouteArrowApi by lazy { MapboxRouteArrowApi() }

  /**
   * RouteArrow: Customization of the maneuver arrow(s) can be done using the [RouteArrowOptions].
   * Here the above layer ID is used to determine where in the map layer stack the arrows appear.
   * Above the layer of the route traffic line is being used here. Your use case may necessitate
   * adjusting this to a different layer position.
   */
  private val routeArrowOptions by lazy {
    RouteArrowOptions.Builder(context).withAboveLayerId(TOP_LEVEL_ROUTE_LINE_LAYER_ID).build()
  }

  /**
   * RouteArrow: This class is responsible for rendering the arrow related mutations generated by
   * the [routeArrowApi]
   */
  private val routeArrowView: MapboxRouteArrowView by lazy {
    MapboxRouteArrowView(routeArrowOptions)
  }

  /**
   * Gets notified with location updates.
   *
   * Exposes raw updates coming directly from the location services and the updates enhanced by the
   * Navigation SDK (cleaned up and matched to the road).
   */
  private val locationObserver =
          object : LocationObserver {
            var firstLocationUpdateReceived = false

            override fun onNewRawLocation(rawLocation: Location) {
              // not handled
            }

            override fun onNewLocationMatcherResult(locationMatcherResult: LocationMatcherResult) {
              val enhancedLocation = locationMatcherResult.enhancedLocation
              // update location puck's position on the map
              navigationLocationProvider.changePosition(
                      location = enhancedLocation,
                      keyPoints = locationMatcherResult.keyPoints,
              )

              // update camera position to account for new location
              viewportDataSource.onLocationChanged(enhancedLocation)
              viewportDataSource.evaluate()

              // if this is the first location update the activity has received,
              // it's best to immediately move the camera to the current user location
              if (!firstLocationUpdateReceived) {
                firstLocationUpdateReceived = true
                navigationCamera.requestNavigationCameraToOverview(
                        stateTransitionOptions =
                                NavigationCameraTransitionOptions.Builder()
                                        .maxDuration(0) // instant transition
                                        .build()
                )
              }

              val event = Arguments.createMap()
              event.putDouble("longitude", enhancedLocation.longitude)
              event.putDouble("latitude", enhancedLocation.latitude)
              event.putDouble("heading", enhancedLocation.bearing ?: 0.0)
              event.putDouble("accuracy", enhancedLocation.horizontalAccuracy ?: 0.0)
              context.getJSModule(RCTEventEmitter::class.java)
                      .receiveEvent(id, "onLocationChange", event)

              // Speed: sempre vis√≠vel ‚Äî limite da via (SpeedInfoView) ou velocidade atual
              // (TextView)
              val opts = distanceFormatterOptions
              if (opts != null) {
                try {
                  val value =
                          speedInfoApi.updatePostedAndCurrentSpeed(
                                  locationMatcherResult,
                                  opts,
                          )
                  value?.let {
                    binding.speedLimitView.render(it)
                    binding.speedLimitView.visibility = View.VISIBLE
                  }
                } catch (e: Exception) {
                  Log.w("MapboxNavigationView", "Speed update: ${e.message}")
                }
              }
            }
          }

  /** Gets notified with progress along the currently active route. */
  private val routeProgressObserver = RouteProgressObserver { routeProgress ->
    // Atualizar rota atual se necess√°rio (pode mudar durante navega√ß√£o)
    val currentNavRoute = routeProgress.navigationRoute
    if (currentNavRoute != currentRoute) {
      currentRoute = currentNavRoute
      filterRadarsNearRoute()
    }

    // update the current road name display
    try {
      val streetName = routeProgress.currentLegProgress?.currentStepProgress?.step?.name()
      if (!streetName.isNullOrEmpty()) {
        binding.roadNameText.text = streetName
        binding.roadNameText.visibility = View.VISIBLE
      } else {
        binding.roadNameText.visibility = View.GONE
      }
    } catch (e: Exception) {
      // Ignore errors for road name update
    }

    // update the current road name display
    try {
      val leg = routeProgress.currentLegProgress
      val step = leg?.currentStepProgress?.step
      val streetName = step?.name()
      
      if (!streetName.isNullOrEmpty()) {
        binding.roadNameText.text = streetName
        binding.roadNameText.visibility = View.VISIBLE
      } else {
        binding.roadNameText.visibility = View.GONE
      }
    } catch (e: Exception) {
      Log.w("MapboxNavigationView", "Erro ao atualizar nome da rua: ${e.message}")
    }

    // update the camera position to account for the progressed fragment of the route
    if (routeProgress.fractionTraveled.toDouble() != 0.0) {
      viewportDataSource.onRouteProgressChanged(routeProgress)
    }
    viewportDataSource.evaluate()

    // draw the upcoming maneuver arrow on the map
    try {
      val style = binding.mapView.mapboxMap.style
      if (style != null) {
        val maneuverArrowResult = routeArrowApi.addUpcomingManeuverArrow(routeProgress)
        routeArrowView.renderManeuverUpdate(style, maneuverArrowResult)
      }
    } catch (e: Exception) {
      Log.w("MapboxNavigationView", "Erro ao renderizar seta de manobra: ${e.message}")
    }

    // update top banner with maneuver instructions
    try {
      if (maneuverApi != null && binding.maneuverView != null) {
        val maneuvers = maneuverApi.getManeuvers(routeProgress)
        maneuvers.fold(
                { error -> Log.w("Maneuvers error:", error.throwable) },
                {
                  val maneuverViewOptions =
                          ManeuverViewOptions.Builder()
                                  .primaryManeuverOptions(
                                          ManeuverPrimaryOptions.Builder()
                                                  .textAppearance(
                                                          R.style.PrimaryManeuverTextAppearance
                                                  )
                                                  .build()
                                  )
                                  .secondaryManeuverOptions(
                                          ManeuverSecondaryOptions.Builder()
                                                  .textAppearance(R.style.ManeuverTextAppearance)
                                                  .build()
                                  )
                                  .subManeuverOptions(
                                          ManeuverSubOptions.Builder()
                                                  .textAppearance(R.style.ManeuverTextAppearance)
                                                  .build()
                                  )
                                  .stepDistanceTextAppearance(
                                          R.style.StepDistanceRemainingAppearance
                                  )
                                  .build()

                  // Mostrar instru√ß√£o de manobra (layout tem maneuverView)
                  binding.maneuverView.updateManeuverViewOptions(maneuverViewOptions)
                  binding.maneuverView.renderManeuvers(maneuvers)
                  Unit
                }
        )
      }
    } catch (e: Exception) {
      Log.w("MapboxNavigationView", "Erro ao atualizar maneuver: ${e.message}")
    }

    // update trip progress: duas linhas (tempo em destaque + dist√¢ncia ‚Äî ETA), estilo primeira
    // imagem
    updateTripProgressUi(routeProgress)

    val event = Arguments.createMap()
    event.putDouble("distanceTraveled", routeProgress.distanceTraveled.toDouble())
    event.putDouble("durationRemaining", routeProgress.durationRemaining)
    event.putDouble("fractionTraveled", routeProgress.fractionTraveled.toDouble())
    event.putDouble("distanceRemaining", routeProgress.distanceRemaining.toDouble())
    context.getJSModule(RCTEventEmitter::class.java)
            .receiveEvent(id, "onRouteProgressChange", event)
  }

  /**
   * Atualiza a barra de trip progress usando o tripProgressApi do Mapbox O MapboxTripProgressView
   * atualiza automaticamente via RouteProgressObserver
   */
  private fun updateTripProgressUi(routeProgress: RouteProgress) {
    try {
      // Verificar se tripProgressApi est√° inicializado e tripProgressView n√£o √© null
      // O MapboxTripProgressView atualiza automaticamente via RouteProgressObserver
      // N√£o √© necess√°rio atualizar manualmente - a view j√° est√° conectada ao observer
      if (tripProgressApi != null && binding.tripProgressView != null) {
        // O tripProgressView atualiza automaticamente quando recebe RouteProgress
        // via RouteProgressObserver registrado no mapboxNavigation

        // Aplicar cores de texto pretas ap√≥s a view ser atualizada
        binding.tripProgressView?.post { applyTripProgressTextColors() }
      }
    } catch (e: Exception) {
      Log.w("MapboxNavigationView", "updateTripProgressUi error: ${e.message}")
    }
  }

  /** Aplica cores de texto pretas em todos os TextViews dentro do tripProgressView com suporte a recurs√£o profunda */
  private fun applyTripProgressTextColors() {
    try {
      binding.tripProgressView?.let { view ->
        val textColor = android.graphics.Color.parseColor("#212121")
        val secondaryColor = android.graphics.Color.parseColor("#444444")

        fun findAndStyle(v: android.view.View, isSecondary: Boolean = false) {
            if (v is android.widget.TextView) {
                v.setTextColor(if (isSecondary) secondaryColor else textColor)
            } else if (v is android.view.ViewGroup) {
                for (i in 0 until v.childCount) {
                    findAndStyle(v.getChildAt(i), isSecondary || i > 0)
                }
            }
        }

        findAndStyle(view)
      }
    } catch (e: Exception) {
      Log.w("MapboxNavigationView", "Erro ao aplicar cores no tripProgressView: ${e.message}")
    }
  }

  /**
   * Gets notified whenever the tracked routes change.
   *
   * A change can mean:
   * - routes get changed with [MapboxNavigation.setNavigationRoutes]
   * - routes annotations get refreshed (for example, congestion annotation that indicate the live
   * traffic along the route)
   * - driver got off route and a reroute was executed
   */
  private val routesObserver = RoutesObserver { routeUpdateResult ->
    try {
      if (!isValidForOperations()) return@RoutesObserver

      if (routeUpdateResult.navigationRoutes.isNotEmpty()) {
        // Armazenar rota atual para filtrar radares
        currentRoute = routeUpdateResult.navigationRoutes.first()

        // Filtrar radares pr√≥ximos √† rota
        filterRadarsNearRoute()

        // generate route geometries with SDK default callouts (duration/ETA per route)
        val style = binding.mapView.mapboxMap.style
        if (style != null) {
          val alternativesMetadata =
                  mapboxNavigation?.getAlternativeMetadataFor(routeUpdateResult.navigationRoutes)
          routeLineApi.setNavigationRoutes(
                  routeUpdateResult.navigationRoutes,
                  alternativesMetadata ?: emptyList()
          ) { value -> routeLineView.renderRouteDrawData(style, value) }
        }

        // update the camera position to account for the new route
        viewportDataSource.onRouteChanged(routeUpdateResult.navigationRoutes.first())
        viewportDataSource.evaluate()
      } else {
        // Limpar rota atual e mostrar todos os radares
        currentRoute = null
        filteredRadars = radars
        updateRadarsOnMap()

        // remove the route line and route arrow from the map
        try {
          val style = binding.mapView.mapboxMap.style
          if (style != null) {
            routeLineApi.clearRouteLine { value ->
              routeLineView.renderClearRouteLineValue(style, value)
            }
            routeArrowView.render(style, routeArrowApi.clearArrows())
          }
        } catch (e: Exception) {
          Log.w("MapboxNavigationView", "Erro ao limpar rota: ${e.message}")
        }

        // remove the route reference from camera position evaluations
        viewportDataSource.clearRouteData()
        viewportDataSource.evaluate()
      }
    } catch (e: Exception) {
      Log.w("MapboxNavigationView", "Erro no routesObserver: ${e.message}")
    }
  }

  init {
    onCreate()
  }

  private fun onCreate() {
    // initialize Mapbox Navigation v3.18.0 (token lido de res/values ou MapboxOptions)
    if (!MapboxNavigationProvider.isCreated()) {
      val navigationOptions = NavigationOptions.Builder(context).build()
      MapboxNavigationProvider.create(navigationOptions)
    }
    mapboxNavigation = MapboxNavigationProvider.retrieve()
  }

  @SuppressLint("MissingPermission")
  private fun initNavigation() {
    if (origin == null || destination == null) {
      return
    }
    if (navigationInitialized) {
      return
    }
    try {
      navigationInitialized = true
      Log.d("MapboxNavigationView", "Iniciando navega√ß√£o: origin=$origin, destination=$destination")

      // Recenter Camera
      val initialCameraOptions = CameraOptions.Builder().zoom(14.0).center(origin).build()
      binding.mapView.mapboxMap.setCamera(initialCameraOptions)

      // Start Navigation
      startNavigation()

      // set the animations lifecycle listener to ensure the NavigationCamera stops
      // automatically following the user location when the map is interacted with
      binding.mapView.camera.addCameraAnimationsLifecycleListener(
              NavigationBasicGesturesHandler(navigationCamera)
      )
      navigationCamera.registerNavigationCameraStateChangeObserver { navigationCameraState ->
        // shows/hide the recenter button depending on the camera state
        when (navigationCameraState) {
          NavigationCameraState.TRANSITION_TO_FOLLOWING, NavigationCameraState.FOLLOWING ->
                  binding.recenter.visibility = View.INVISIBLE
          NavigationCameraState.TRANSITION_TO_OVERVIEW,
          NavigationCameraState.OVERVIEW,
          NavigationCameraState.IDLE -> binding.recenter.visibility = View.VISIBLE
        }
      }
      // set the padding values depending on screen orientation and visible view layout
      if (this.resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {
        viewportDataSource.overviewPadding = landscapeOverviewPadding
      } else {
        viewportDataSource.overviewPadding = overviewPadding
      }
      if (this.resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {
        viewportDataSource.followingPadding = landscapeFollowingPadding
      } else {
        viewportDataSource.followingPadding = followingPadding
      }

      // make sure to use the same DistanceFormatterOptions across different features (incl. Speed
      // Limit API)
      val unitType = if (distanceUnit == "imperial") UnitType.IMPERIAL else UnitType.METRIC
      val options = DistanceFormatterOptions.Builder(context).unitType(unitType).build()
      distanceFormatterOptions = options

      // initialize maneuver api that feeds the data to the top banner maneuver view
      maneuverApi = MapboxManeuverApi(MapboxDistanceFormatter(options))

      // initialize bottom progress view
      tripProgressApi =
              MapboxTripProgressApi(
                      TripProgressUpdateFormatter.Builder(context)
                              .distanceRemainingFormatter(DistanceRemainingFormatter(options))
                              .timeRemainingFormatter(TimeRemainingFormatter(context))
                              .percentRouteTraveledFormatter(PercentDistanceTraveledFormatter())
                              .estimatedTimeToArrivalFormatter(
                                      EstimatedTimeToArrivalFormatter(
                                              context,
                                              TimeFormat.NONE_SPECIFIED
                                      )
                              )
                              .build()
              )

      // Aplicar cores de texto ap√≥s a view ser criada
      binding.tripProgressView?.postDelayed(
              { applyTripProgressTextColors() },
              500
      ) // Delay para garantir que a view est√° totalmente renderizada

      // initialize voice instructions api and the voice instruction player (pt-BR)
      val voiceLanguage = locale.toLanguageTag()
      speechApi = MapboxSpeechApi(context, voiceLanguage)
      try {
        voiceInstructionsPlayer = MapboxVoiceInstructionsPlayer(context, voiceLanguage)
      } catch (e: Exception) {
        Log.w("MapboxNavigationView", "Voice instructions n√£o dispon√≠veis: ${e.message}")
        voiceInstructionsPlayer = null
      }

      // load map style
      binding.mapView.mapboxMap.loadStyle(NavigationStyles.NAVIGATION_DAY_STYLE) { style ->
        // Ensure that the route line related layers are present before the route arrow
        routeLineView.initializeLayers(style)
        // Callouts padr√£o do SDK: bolha com dura√ß√£o/ETA na rota
        try {
          routeLineView.setCalloutAdapter(
            binding.mapView.viewAnnotationManager,
            DefaultRouteCalloutAdapter(context)
          )
        } catch (e: Exception) {
          Log.w("MapboxNavigationView", "Erro ao configurar callouts: ${e.message}")
        }

        // Carregar imagens de radar e registrar listener
        try {
          loadRadarImages(style)
          registerImageMissingListener(style)
          // Atualizar radares se j√° houver algum definido
          if (radars.isNotEmpty()) {
            updateRadarsOnMap()
          }
        } catch (e: Exception) {
          Log.e("MapboxNavigationView", "Erro ao inicializar radares no estilo", e)
        }
        // Compass: posi√ß√£o abaixo dos controles (recenter/overview/sound), canto inferior direito
        try {
          val density = pixelDensity.toFloat()
          binding.mapView.compass.updateSettings {
            position = Gravity.BOTTOM or Gravity.START
            marginRight = 16f * density
            marginBottom = 380f * density
            marginTop = 4f * density
            marginLeft = 4f * density
          }
        } catch (e: Exception) {
          Log.d("MapboxNavigationView", "Compass position: ${e.message}")
        }

        // Registrar listener de click no mapa para selecionar rota alternativa
        binding.mapView.mapboxMap.addOnMapClickListener { point ->
          try {
            val mapboxMap = binding.mapView.mapboxMap
            val pixel = mapboxMap.pixelForCoordinate(point)
            
            // Consultar features na camada de rota
            mapboxMap.queryRenderedFeatures(
              RenderedQueryGeometry(ScreenCoordinate(pixel.x, pixel.y)),
              RenderedQueryOptions(
                   listOf(
                     "mapbox-navigation-route-line", 
                     "mapbox-navigation-route-line-casing"
                   ), 
                   null
              )
            ) { expected ->
              if (expected.isValue) {
                val features = expected.value
                if (features != null && features.isNotEmpty()) {
                   val routes = mapboxNavigation?.getNavigationRoutes()
                   if (routes != null && routes.size > 1) {
                      // Melhor: Pegar a rota de √≠ndice 1 (primeira alternativa) e definir como prim√°ria.
                      val newRoutes = routes.toMutableList()
                      val alternative = newRoutes.removeAt(1)
                      newRoutes.add(0, alternative)
                      
                      mapboxNavigation?.setNavigationRoutes(newRoutes)
                      Log.i("MapboxNavigationView", "Rota alternativa selecionada via click!")
                      
                      // Emitir evento para React Native
                      val event = Arguments.createMap()
                      event.putBoolean("alternativeSelected", true)
                      
                      val reactContext = context as ThemedReactContext
                      reactContext
                          .getJSModule(RCTEventEmitter::class.java)
                          .receiveEvent(id, "onRouteAlternativeSelected", event)
                   }
                }
              }
            }
            // Retornar false para permitir que o mapa processe outros clicks se necess√°rio
            return@addOnMapClickListener false
          } catch(e: Exception) {
             Log.w("MapboxNavigationView", "Erro no click do mapa: ${e.message}")
          }
          false
        }
      }

      // initialize view interactions
      binding.stop.setOnClickListener {
        val event = Arguments.createMap()
        event.putString("message", "Navigation Cancel")
        context.getJSModule(RCTEventEmitter::class.java)
                .receiveEvent(id, "onCancelNavigation", event)
      }

      binding.recenter.setOnClickListener {
        navigationCamera.requestNavigationCameraToFollowing()
        binding.routeOverview.showTextAndExtend(BUTTON_ANIMATION_DURATION)
      }
      binding.routeOverview.setOnClickListener {
        navigationCamera.requestNavigationCameraToOverview()
        binding.recenter.showTextAndExtend(BUTTON_ANIMATION_DURATION)
      }
      binding.soundButton.setOnClickListener {
        // mute/unmute voice instructions
        isVoiceInstructionsMuted = !isVoiceInstructionsMuted
      }

      // Check initial muted or not
      if (this.isVoiceInstructionsMuted) {
        binding.soundButton.mute()
        voiceInstructionsPlayer?.volume(SpeechVolume(0f))
      } else {
        binding.soundButton.unmute()
        voiceInstructionsPlayer?.volume(SpeechVolume(1f))
      }
    } catch (e: Exception) {
      navigationInitialized = false
      Log.e("MapboxNavigationView", "Erro ao inicializar navega√ß√£o", e)
      sendErrorToReact("Erro ao iniciar navega√ß√£o: ${e.message}")
    }
  }

  private fun onDestroy() {
    navigationInitialized = false
    isDestroyed = true
    try {
      maneuverApi?.cancel()
      routeLineApi.cancel()
      routeLineView.cancel()
      speechApi?.cancel()
      voiceInstructionsPlayer?.shutdown()
      mapboxNavigation?.stopTripSession()
    } catch (e: Exception) {
      Log.w("MapboxNavigationView", "onDestroy: ${e.message}")
    }
  }

  private fun startNavigation() {
    // initialize location puck
    binding.mapView.location.apply {
      setLocationProvider(navigationLocationProvider)
      this.locationPuck =
              LocationPuck2D(
                      bearingImage =
                              ImageHolder.Companion.from(
                                      com.mapbox
                                              .navigation
                                              .ui
                                              .maps
                                              .R
                                              .drawable
                                              .mapbox_navigation_puck_icon
                              )
              )
      puckBearingEnabled = true
      enabled = true
    }

    startRoute()
  }

  private val arrivalObserver =
          object : ArrivalObserver {

            override fun onWaypointArrival(routeProgress: RouteProgress) {
              onArrival(routeProgress)
            }

            override fun onNextRouteLegStart(routeLegProgress: RouteLegProgress) {
              // do something when the user starts a new leg
            }

            override fun onFinalDestinationArrival(routeProgress: RouteProgress) {
              onArrival(routeProgress)
            }
          }

  private fun onArrival(routeProgress: RouteProgress) {
    val leg = routeProgress.currentLegProgress
    if (leg != null) {
      val event = Arguments.createMap()
      event.putInt("index", leg.legIndex)
      event.putDouble("latitude", leg.legDestination?.location?.latitude() ?: 0.0)
      event.putDouble("longitude", leg.legDestination?.location?.longitude() ?: 0.0)
      context.getJSModule(RCTEventEmitter::class.java).receiveEvent(id, "onArrive", event)
    }
  }

  override fun requestLayout() {
    super.requestLayout()
    post(measureAndLayout)
  }

  private val measureAndLayout = Runnable {
    measure(
            MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY),
            MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY)
    )
    layout(left, top, right, bottom)
  }

  private fun findRoute(coordinates: List<Point>) {
    // Separate legs work
    val indices = mutableListOf<Int>()
    val names = mutableListOf<String>()
    indices.add(0)
    names.add("origin")
    indices.addAll(waypointLegs.map { it.index })
    names.addAll(waypointLegs.map { it.name })
    indices.add(coordinates.count() - 1)
    names.add(destinationTitle)

    mapboxNavigation?.requestRoutes(
            RouteOptions.builder()
                    .applyDefaultNavigationOptions()
                    .applyLanguageAndVoiceUnitOptions(context)
                    .coordinatesList(coordinates)
                    .waypointIndicesList(indices)
                    .waypointNamesList(names)
                    .language(locale.language)
                    .steps(true)
                    .voiceInstructions(true)
                    .voiceUnits(distanceUnit)
                    .alternatives(true) // Solicitar rotas alternativas
                    .annotationsList(
                            listOf(DirectionsCriteria.ANNOTATION_MAXSPEED)
                    ) // Necess√°rio para speedLimitInfo
                    .build(),
            object : NavigationRouterCallback {
              override fun onCanceled(
                      routeOptions: RouteOptions,
                      @RouterOrigin routerOrigin: String
              ) {
                // no implementation
              }

              override fun onFailure(reasons: List<RouterFailure>, routeOptions: RouteOptions) {
                sendErrorToReact("Error finding route $reasons")
              }

              override fun onRoutesReady(
                      routes: List<NavigationRoute>,
                      @RouterOrigin routerOrigin: String
              ) {
                if (isDestroyed) return
                // Armazenar rotas alternativas (at√© 3 melhores)
                alternativeRoutes = routes.take(3)
                currentRouteIndex = 0

                // Mostrar rotas alternativas no mapa antes de iniciar navega√ß√£o
                if (alternativeRoutes.size > 1) {
                  showAlternativeRoutes(alternativeRoutes)
                }

                setRouteAndStartNavigation(routes)
              }
            }
    )
  }

  @SuppressLint("MissingPermission")
  private fun setRouteAndStartNavigation(routes: List<NavigationRoute>) {
    if (routes.isEmpty()) {
      Log.w("MapboxNavigationView", "setRouteAndStartNavigation: lista de rotas vazia")
      return
    }
    try {
      // set routes, where the first route in the list is the primary route that
      // will be used for active guidance
      mapboxNavigation?.setNavigationRoutes(routes)

      // show UI elements
      binding.maneuverView.visibility = View.VISIBLE
      binding.soundButton.visibility = View.VISIBLE
      binding.routeOverview.visibility = View.VISIBLE
      binding.tripProgressCard.visibility = View.VISIBLE
      // binding.speedLimitView.visibility = View.VISIBLE

      mapboxNavigation?.startTripSession(withForegroundService = true)
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao iniciar sess√£o de navega√ß√£o", e)
      sendErrorToReact("Erro ao iniciar navega√ß√£o: ${e.message}")
    }
  }

  private fun startRoute() {
    // Create a list of coordinates that includes origin, destination
    val coordinatesList = mutableListOf<Point>()
    this.origin?.let { coordinatesList.add(it) }
    this.waypoints.let { coordinatesList.addAll(waypoints) }
    this.destination?.let { coordinatesList.add(it) }

    if (coordinatesList.size < 2) {
      Log.e(
              "MapboxNavigationView",
              "startRoute: origem e destino s√£o obrigat√≥rios (pontos=${coordinatesList.size})"
      )
      sendErrorToReact("Origem e destino s√£o obrigat√≥rios")
      return
    }

    // register event listeners
    mapboxNavigation?.registerRoutesObserver(routesObserver)
    mapboxNavigation?.registerArrivalObserver(arrivalObserver)
    mapboxNavigation?.registerRouteProgressObserver(routeProgressObserver)
    mapboxNavigation?.registerLocationObserver(locationObserver)
    mapboxNavigation?.registerVoiceInstructionsObserver(voiceInstructionsObserver)

    findRoute(coordinatesList)
  }

  override fun onDetachedFromWindow() {
    super.onDetachedFromWindow()
    mapboxNavigation?.unregisterRoutesObserver(routesObserver)
    mapboxNavigation?.unregisterArrivalObserver(arrivalObserver)
    mapboxNavigation?.unregisterLocationObserver(locationObserver)
    mapboxNavigation?.unregisterRouteProgressObserver(routeProgressObserver)
    mapboxNavigation?.unregisterVoiceInstructionsObserver(voiceInstructionsObserver)

    // Clear routs and end
    mapboxNavigation?.setNavigationRoutes(listOf())

    // hide UI elements
    binding.soundButton.visibility = View.INVISIBLE
    binding.maneuverView.visibility = View.INVISIBLE
    binding.routeOverview.visibility = View.INVISIBLE
    binding.tripProgressCard.visibility = View.INVISIBLE
    // binding.speedLimitView.visibility = View.INVISIBLE
  }

  private fun sendErrorToReact(error: String?) {
    val event = Arguments.createMap()
    event.putString("error", error)
    context.getJSModule(RCTEventEmitter::class.java).receiveEvent(id, "onError", event)
  }

  fun onDropViewInstance() {
    this.onDestroy()
  }

  fun setStartOrigin(origin: Point?) {
    this.origin = origin
    if (destination != null) initNavigation()
  }

  fun setDestination(destination: Point?) {
    this.destination = destination
    if (origin != null) initNavigation()
  }

  fun setDestinationTitle(title: String) {
    this.destinationTitle = title
  }

  fun setWaypointLegs(legs: List<WaypointLegs>) {
    this.waypointLegs = legs
  }

  fun setWaypoints(waypoints: List<Point>) {
    this.waypoints = waypoints
  }

  fun setDirectionUnit(unit: String) {
    this.distanceUnit = unit
    if (origin != null && destination != null) initNavigation()
  }

  fun setLocal(language: String) {
    val locals = language.split("-")
    when (locals.size) {
      1 -> locale = Locale(locals.first())
      2 -> locale = Locale(locals.first(), locals.last())
    }
  }

  fun setMute(mute: Boolean) {
    this.isVoiceInstructionsMuted = mute
  }

  fun setShowCancelButton(show: Boolean) {
    binding.stop.visibility = if (show) View.VISIBLE else View.INVISIBLE
  }

  // Setter methods for radar functionality
  fun setBottomPadding(padding: Double) {
    try {
      additionalBottomPadding = padding
      updateCameraPadding()
      Log.d("MapboxNavigationView", "‚¨áÔ∏è Bottom padding atualizado para: $padding")
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao definir bottom padding", e)
    }
  }

  fun setRadars(radars: List<RadarPoint>) {
    try {
      this.radars = radars
      Log.d("MapboxNavigationView", "üìç ${radars.size} radares definidos")

      // Filtrar radares se houver rota ativa
      if (currentRoute != null) {
        filterRadarsNearRoute()
        updateRadarsOnMap() // ‚úÖ Atualizar mapa IMEDIATAMENTE ap√≥s filtrar
      } else {
        filteredRadars = radars
        updateRadarsOnMap() // Atualizar mapa quando n√£o h√° rota
      }

      updateRadarAnnotations()
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao definir radares", e)
    }
  }

  fun setNearbyRadarIds(radarIds: Set<String>) {
    try {
      this.nearbyRadarIds = radarIds
      Log.d("MapboxNavigationView", "üì° ${radarIds.size} radares pr√≥ximos definidos")
      updateRadarAnimations()
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao definir radares pr√≥ximos", e)
    }
  }

  private fun isValidForOperations(): Boolean {
    return try {
      !isDestroyed && binding.mapView != null
    } catch (e: Exception) {
      false
    }
  }

  // Utility functions
  private fun getCurrentStyle(): com.mapbox.maps.Style? {
    return try {
      binding.mapView.mapboxMap.style
    } catch (e: Exception) {
      null
    }
  }

  private fun safeEmitEvent(eventName: String, event: com.facebook.react.bridge.WritableMap) {
    try {
      context.getJSModule(com.facebook.react.uimanager.events.RCTEventEmitter::class.java)
              .receiveEvent(id, eventName, event)
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao emitir evento $eventName", e)
    }
  }

  private fun updateCameraPadding() {
    try {
      val style = getCurrentStyle() ?: return

      // Atualizar padding da c√¢mera baseado no additionalBottomPadding
      // Usar l√≥gica diferencial para evitar ac√∫mulo infinito de padding
      val currentPadding = viewportDataSource.followingPadding
      
      // Aplicar densidade se necess√°rio (assumindo que entrada √© DP)
      // Mas para manter compatibilidade com comportamento atual (que usu√°rio disse "sobe um pouco"),
      // vamos manter a unidade crua por enquanto ou aplicar density se parecer muito pequeno.
      // O codigo anterior somava direto e funcionava "um pouco". Vamos manter a escala.
      // Se adicionalBottomPadding for DP, deveria ser * pixelDensity. 
      // Vamos assumir que o valor passado j√° est√° ok ou ajustar depois se precisar.
      
      val paddingToAdd = additionalBottomPadding * pixelDensity // Convertendo para pixels para garantir efeito correto

      // Recuperar base subtraindo o √∫ltimo aplicado
      val baseBottom = currentPadding.bottom - lastAppliedAdditionalPadding
      
      val newBottomPadding = baseBottom + paddingToAdd

      val newPadding =
              EdgeInsets(
                      currentPadding.top,
                      currentPadding.left,
                      newBottomPadding.coerceAtLeast(0.0), // Evitar valores negativos
                      currentPadding.right
              )

      viewportDataSource.followingPadding = newPadding
      viewportDataSource.evaluate()

      // Atualizar √∫ltimo valor aplicado
      lastAppliedAdditionalPadding = paddingToAdd

      Log.d("MapboxNavigationView", "‚úÖ Camera padding atualizado: bottom=$newBottomPadding (added: $paddingToAdd)")
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao atualizar camera padding", e)
    }
  }

  private fun updateRadarAnnotations() {
    updateRadarsOnMap()
  }

  private fun updateRadarAnimations() {
    updateNearbyRadarsInSource()
  }

  private fun loadRadarImagesWithRetry(style: com.mapbox.maps.Style) {
    loadRadarImages(style)
  }

  private fun loadRadarImages(style: com.mapbox.maps.Style) {
    try {
      val imageNames =
              listOf(
                      "placa0",
                      "placa10",
                      "placa20",
                      "placa30",
                      "placa40",
                      "placa50",
                      "placa60",
                      "placa70",
                      "placa80",
                      "placa90",
                      "placa100",
                      "placa110",
                      "placa120",
                      "placa130",
                      "placa140",
                      "placa150",
                      "placa160",
                      "placa",
                      "radar",           // Radar normal/reportado
                      "radar_semaforico", // Radar semaf√≥rico
                      "radarSemaforico", // Varia√ß√£o de nome
                      "radarMovel",       // Radar m√≥vel
                      "radar_movel",      // Varia√ß√£o de nome
                      "radarmovel"       // Varia√ß√£o de nome
              )

      imageNames.forEach { imageName ->
        try {
          var resourceName = "assets_images_$imageName"
          var resourceId =
                  context.resources.getIdentifier(resourceName, "drawable", context.packageName)
          
          // Se n√£o encontrar, tentar tudo min√∫sculo (comum no Android)
          if (resourceId == 0) {
              resourceName = "assets_images_${imageName.lowercase()}"
              resourceId = context.resources.getIdentifier(resourceName, "drawable", context.packageName)
          }

          if (resourceId == 0) {
            Log.w("MapboxNavigationView", "‚ö†Ô∏è Recurso n√£o encontrado: assets_images_$imageName")
            return@forEach
          }

          val bitmap = BitmapFactory.decodeResource(context.resources, resourceId)
          if (bitmap == null) {
            Log.w("MapboxNavigationView", "‚ö†Ô∏è Bitmap null para $resourceName")
            return@forEach
          }

          val imageExists =
                  try {
                    style.getStyleImage(imageName) != null
                  } catch (e: Exception) {
                    false
                  }

          if (!imageExists) {
            style.addImage(imageName, bitmap)
            Log.d("MapboxNavigationView", "‚úÖ Imagem $imageName carregada")
          }
        } catch (e: Exception) {
          Log.e("MapboxNavigationView", "‚ùå Erro ao carregar imagem $imageName", e)
        }
      }
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "‚ùå Erro geral ao carregar imagens", e)
    }
  }

  private fun registerImageMissingListener(style: com.mapbox.maps.Style) {
    if (imageMissingListenerRegistered) {
      return
    }

    try {
      binding.mapView.mapboxMap.subscribeStyleImageMissing { eventData ->
        val missingId = eventData.imageId
        val currentStyle = binding.mapView.mapboxMap.style ?: return@subscribeStyleImageMissing

        try {
          val resourceName = "assets_images_$missingId"
          val resourceId =
                  context.resources.getIdentifier(resourceName, "drawable", context.packageName)
          if (resourceId != 0) {
            val bitmap = BitmapFactory.decodeResource(context.resources, resourceId)
            if (bitmap != null) {
              val imageExists =
                      try {
                        currentStyle.getStyleImage(missingId) != null
                      } catch (e: Exception) {
                        false
                      }

              if (!imageExists) {
                currentStyle.addImage(missingId, bitmap)
                Log.d("MapboxNavigationView", "‚úÖ Imagem faltante $missingId carregada via listener")
              }
            }
          }
        } catch (e: Exception) {
          Log.e("MapboxNavigationView", "Erro ao processar imagem faltante $missingId", e)
        }
      }

      imageMissingListenerRegistered = true
      Log.d("MapboxNavigationView", "‚úÖ Listener de imagens faltantes registrado")
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao registrar listener de imagens faltantes", e)
    }
  }

  /** Filtra radares pr√≥ximos √† rota atual Usa dist√¢ncia perpendicular m√°xima de 100 metros */
  private fun filterRadarsNearRoute() {
    if (currentRoute == null || radars.isEmpty()) {
      filteredRadars = radars
      return
    }

    try {
      // Extrair coordenadas da rota usando directionsRoute
      val directionsRoute = currentRoute?.directionsRoute
      if (directionsRoute == null) {
        Log.w("MapboxNavigationView", "‚ö†Ô∏è directionsRoute √© null, mostrando todos os radares")
        filteredRadars = radars
        return
      }

      // Obter geometria da rota
      val routeGeometry = directionsRoute.geometry()
      if (routeGeometry == null) {
        Log.w("MapboxNavigationView", "‚ö†Ô∏è routeGeometry √© null, mostrando todos os radares")
        filteredRadars = radars
        return
      }

      // Converter geometria para LineString usando toString() e fromJson()
      // A geometria do DirectionsRoute pode ser convertida para JSON string
      try {
        val geoJsonString = routeGeometry.toString()
        val lineString = LineString.fromJson(geoJsonString)
        if (lineString == null) {
          Log.w(
                  "MapboxNavigationView",
                  "‚ö†Ô∏è N√£o foi poss√≠vel converter routeGeometry para LineString"
          )
          filteredRadars = radars
          return
        }

        val routeCoordinates = lineString.coordinates()

        if (routeCoordinates.isEmpty()) {
          Log.w(
                  "MapboxNavigationView",
                  "‚ö†Ô∏è routeCoordinates est√° vazio, mostrando todos os radares"
          )
          filteredRadars = radars
          return
        }

        // Converter coordenadas para lista de Points
        val routePoints =
                routeCoordinates.map { coord: Point ->
                  Point.fromLngLat(coord.longitude(), coord.latitude())
                }

        // Filtrar radares pr√≥ximos √† rota (dist√¢ncia perpendicular < 100m)
        val maxDistanceMeters = 100.0
        filteredRadars =
                radars.filter { radar ->
                  val radarPoint = Point.fromLngLat(radar.longitude, radar.latitude)
                  val minDistance = calculateMinDistanceToRoute(radarPoint, routePoints)
                  minDistance <= maxDistanceMeters
                }

        Log.d(
                "MapboxNavigationView",
                "üîç Filtrados ${filteredRadars.size} de ${radars.size} radares pr√≥ximos √† rota"
        )

        // Atualizar radares no mapa ap√≥s filtrar
        updateRadarsOnMap()
      } catch (e: Exception) {
        Log.e("MapboxNavigationView", "Erro ao extrair coordenadas da rota", e)
        filteredRadars = radars
        updateRadarsOnMap()
      }
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao filtrar radares pr√≥ximos √† rota", e)
      filteredRadars = radars // Fallback: mostrar todos os radares
      updateRadarsOnMap()
    }
  }

  /** Calcula a dist√¢ncia m√≠nima perpendicular de um ponto at√© a rota Retorna dist√¢ncia em metros */
  private fun calculateMinDistanceToRoute(point: Point, routePoints: List<Point>): Double {
    if (routePoints.size < 2) {
      return Double.MAX_VALUE
    }

    var minDistance = Double.MAX_VALUE

    // Verificar dist√¢ncia perpendicular para cada segmento da rota
    for (i in 0 until routePoints.size - 1) {
      val segmentStart = routePoints[i]
      val segmentEnd = routePoints[i + 1]

      val distance = calculatePerpendicularDistance(point, segmentStart, segmentEnd)
      if (distance < minDistance) {
        minDistance = distance
      }
    }

    return minDistance
  }

  /**
   * Calcula dist√¢ncia perpendicular de um ponto at√© um segmento de linha Usa f√≥rmula de dist√¢ncia
   * ponto-linha Retorna dist√¢ncia em metros usando f√≥rmula de Haversine
   */
  private fun calculatePerpendicularDistance(
          point: Point,
          lineStart: Point,
          lineEnd: Point
  ): Double {
    // Calcular dist√¢ncia usando f√≥rmula de Haversine
    val R = 6371000.0 // Raio da Terra em metros

    // Converter para radianos
    val lat1 = Math.toRadians(point.latitude())
    val lon1 = Math.toRadians(point.longitude())
    val lat2 = Math.toRadians(lineStart.latitude())
    val lon2 = Math.toRadians(lineStart.longitude())
    val lat3 = Math.toRadians(lineEnd.latitude())
    val lon3 = Math.toRadians(lineEnd.longitude())

    // Calcular vetor do segmento
    val dLat = lat3 - lat2
    val dLon = lon3 - lon2

    // Calcular produto escalar para encontrar ponto mais pr√≥ximo no segmento
    val t =
            if (dLat * dLat + dLon * dLon > 0) {
              val dot = (lat1 - lat2) * dLat + (lon1 - lon2) * dLon
              val lenSq = dLat * dLat + dLon * dLon
              (dot / lenSq).coerceIn(0.0, 1.0)
            } else {
              0.0
            }

    // Ponto mais pr√≥ximo no segmento
    val closestLat = lat2 + t * dLat
    val closestLon = lon2 + t * dLon

    // Calcular dist√¢ncia Haversine entre ponto e ponto mais pr√≥ximo
    val dLat2 = lat1 - closestLat
    val dLon2 = lon1 - closestLon

    val a =
            Math.sin(dLat2 / 2) * Math.sin(dLat2 / 2) +
                    Math.cos(lat1) *
                            Math.cos(closestLat) *
                            Math.sin(dLon2 / 2) *
                            Math.sin(dLon2 / 2)
    val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))

    return R * c
  }

  private fun updateRadarsOnMap() {
    val style = getCurrentStyle() ?: return

    // Durante navega√ß√£o: usar radares dispon√≠veis imediatamente (n√£o esperar filteredRadars)
    // Isso garante que radares apare√ßam instantaneamente
    // ESTABILIDADE: Ordenar por ID para evitar "pisca-pisca" quando a lista muda de ordem
    val radarsToDisplay = if (currentRoute != null) {
      // Durante navega√ß√£o: pegar primeiros 1000 radares (aumentado de 300)
      radars.sortedBy { it.id }.take(1000)
    } else {
      // Fora de navega√ß√£o: limitar a 1000 radares para performance
      radars.sortedBy { it.id }.take(1000)
    }

    if (radarsToDisplay.isEmpty()) {
      return
    }

    try {
      val features =
              radarsToDisplay.map { radar: RadarPoint ->
                val speedLimit = radar.speedLimit ?: 0.0

                // Determinar imagem baseado no tipo do radar
                val radarType = radar.type?.lowercase()?.replace("√°", "a")?.replace("√©", "e")?.replace("√≠", "i")?.replace("√≥", "o")?.replace("√∫", "u") ?: ""
                
                // Determinar √≠cone, tamanho e ROTA√á√ÉO baseado no tipo
                // O usu√°rio reportou: Placas em 0.0 est√£o certas, outros em 0.0 est√£o para baixo.
                // Logo: Placas = 0.0, Outros = 180.0 (para inverter o que est√° para baixo).
                val (iconImage, iconSize, iconRotate) = when {
                  radarType.contains("semaforo") -> Triple("radar_semaforico", 0.05, 180.0)
                  radarType.contains("movel") || radarType.contains("mobile") -> Triple("radarMovel", 0.05, 180.0)
                  radarType.contains("fixo") || radarType.contains("placa") -> {
                    // Para radares fixos ou placas, usar placa com velocidade
                    val speeds = listOf(20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160)
                    val closestSpeed =
                            if (speedLimit > 0) {
                              speeds.minByOrNull { kotlin.math.abs(it - speedLimit) } ?: 0
                            } else {
                              0
                            }
                    // Se for fixo mas n√£o tiver velocidade, ainda assim usar √≠cone de radar fixo/placa (default 60 ou gen√©rico)
                    val icon = if (closestSpeed > 0) "placa$closestSpeed" else "radar"
                    Triple(icon, 0.15, 0.0) // Placas ja estao certas em 0.0
                  }
                  radarType.contains("lombada") -> Triple("radar", 0.06, 180.0)
                  radarType.contains("policia") -> Triple("radar", 0.09, 180.0)
                  radarType.contains("reportado") -> Triple("radar", 0.05, 180.0)
                  else -> {
                    // Padr√£o: tentar usar velocidade se dispon√≠vel, sen√£o radar gen√©rico
                    val speeds = listOf(20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160)
                    val closestSpeed =
                            if (speedLimit > 0) {
                              speeds.minByOrNull { kotlin.math.abs(it - speedLimit) } ?: 0
                            } else {
                              0
                            }
                    
                    if (closestSpeed > 0) {
                        Triple("placa$closestSpeed", 0.15, 0.0)
                    } else {
                        Triple("radar", 0.05, 180.0)
                    }
                  }
                }

                // Log apenas dos primeiros radares para n√£o poluir
                if (radarsToDisplay.indexOf(radar) < 5) {
                    Log.d("MapboxNavigationView", "üìç Mapeado: id=${radar.id}, type=${radar.type}, icon=$iconImage, speed=$speedLimit")
                }

                val isNearby = nearbyRadarIds.contains(radar.id)

                Feature.fromGeometry(
                        Point.fromLngLat(radar.longitude, radar.latitude),
                        JsonObject().apply {
                          addProperty("id", radar.id)
                          addProperty("speedLimit", radar.speedLimit?.toString() ?: "")
                          addProperty("iconImage", iconImage)
                          addProperty("iconSize", iconSize)  // Tamanho din√¢mico
                          addProperty("iconRotate", iconRotate) // Rota√ß√£o din√¢mica
                          addProperty("isNearby", java.lang.Boolean.valueOf(isNearby))
                          addProperty("radarType", radar.type ?: "")
                        }
                )
              }

      val featureCollection = FeatureCollection.fromFeatures(features.toList())
      val geoJsonString = featureCollection.toJson()
      
      // Maneira segura e eficiente de atualizar a fonte sem recriar (evita piscar/recarregar)
      if (style.styleSourceExists("radars-source")) {
           // Apenas atualizar a propriedade "data" do GeoJSON (null-safe)
           val dataValue = com.mapbox.bindgen.Value.fromJson(geoJsonString)
           dataValue.value?.let { value ->
               val result = style.setStyleSourceProperty("radars-source", "data", value)
               if (result.isError) {
                   Log.e("MapboxNavigationView", "‚ùå Erro ao atualizar dados da source: ${result.error}")
               } else {
                   Log.d("MapboxNavigationView", "‚úÖ Dados de radares atualizados via setStyleSourceProperty")
               }
           } ?: Log.w("MapboxNavigationView", "‚ö†Ô∏è dataValue.value √© null, pulando atualiza√ß√£o de radares")
      } else {
          // Criar fonte pela primeira vez
          val sourceJson =
                  """
            {
              "type": "geojson",
              "data": $geoJsonString
            }
          """.trimIndent()
    
          val sourceValueResult = com.mapbox.bindgen.Value.fromJson(sourceJson)
          when (val value = sourceValueResult.value) {
            null -> {
              Log.e("MapboxNavigationView", "Erro ao criar Value do JSON: ${sourceValueResult.error}")
            }
            else -> {
              style.addStyleSource("radars-source", value)
              Log.d("MapboxNavigationView", "‚úÖ Source 'radars-source' criada inicialmente")
              
              // Garantir images
              loadRadarImages(style)
              
              // Criar layerapenas se n√£o existir
              if (!style.styleLayerExists("radars-layer-symbol")) {
                try {
                    val layerJson =
                            """
                      {
                        "id": "radars-layer-symbol",
                        "type": "symbol",
                        "source": "radars-source",
                        "layout": {
                          "icon-image": ["get", "iconImage"],
                          "icon-size": ["get", "iconSize"],
                          "icon-allow-overlap": true,
                          "icon-ignore-placement": true,
                          "icon-anchor": "bottom",
                          "icon-pitch-alignment": "viewport",
                          "icon-rotation-alignment": "viewport",
                          "icon-rotate": ["get", "iconRotate"]
                        },
                        "paint": {}
                      }
                    """.trimIndent()
        
                    val layerValueResult = com.mapbox.bindgen.Value.fromJson(layerJson)
                    layerValueResult.value?.let { value ->
                        val layerPosition = if (style.styleLayerExists(TOP_LEVEL_ROUTE_LINE_LAYER_ID)) {
                                  LayerPosition(TOP_LEVEL_ROUTE_LINE_LAYER_ID, null, null)
                                } else { null }
                        style.addStyleLayer(value, layerPosition)
                        Log.d("MapboxNavigationView", "‚úÖ Layer 'radars-layer-symbol' adicionado")
                    } ?: Log.w("MapboxNavigationView", "‚ö†Ô∏è layerValueResult.value √© null, layer n√£o criado")
                } catch (e: Exception) {
                    Log.e("MapboxNavigationView", "‚ùå Erro ao criar layer", e)
                }
              }
            }
          }
      }
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao atualizar radares no mapa", e)
    }
  }

  private fun updateNearbyRadarsInSource() {
    // Reutilizar l√≥gica centralizada do updateRadarsOnMap
    // Isso garante consist√™ncia e evita duplica√ß√£o de c√≥digo
    updateRadarsOnMap()
  }

  /** Mostra rotas alternativas no mapa com callouts e informa√ß√µes */
  private fun showAlternativeRoutes(routes: List<NavigationRoute>) {
    val style = getCurrentStyle() ?: return

    try {
      // Criar features para cada rota alternativa com informa√ß√µes
      val alternativeRouteFeatures = mutableListOf<Feature>()

      routes.forEachIndexed { index, route ->
        val directionsRoute = route.directionsRoute
        val routeGeometry = directionsRoute.geometry() ?: return@forEachIndexed

        // Converter geometria para LineString
        val routeGeoJsonString = routeGeometry.toString()
        val lineString = LineString.fromJson(routeGeoJsonString)
        if (lineString == null) return@forEachIndexed

        val routeCoordinates = lineString.coordinates()
        if (routeCoordinates.isEmpty()) return@forEachIndexed

        // Obter informa√ß√µes da rota
        val totalDistance = directionsRoute.distance() ?: 0.0
        val totalDuration = directionsRoute.duration() ?: 0.0

        // Criar callout no ponto m√©dio da rota
        val midPointIndex = routeCoordinates.size / 2
        val midCoord: Point = routeCoordinates[midPointIndex]
        val midPoint = Point.fromLngLat(midCoord.longitude(), midCoord.latitude())

        // Formatar informa√ß√µes
        val distanceKm = totalDistance / 1000.0
        val durationMinutes = (totalDuration / 60).toInt()

        val distanceText =
                if (distanceKm < 1.0) {
                  "${totalDistance.toInt()}m"
                } else {
                  String.format("%.1f", distanceKm) + "km"
                }

        val timeText =
                when {
                  durationMinutes < 60 -> "${durationMinutes}min"
                  else -> "${durationMinutes / 60}h ${durationMinutes % 60}min"
                }

        val routeLabel =
                when (index) {
                  0 -> "Rota 1 (Recomendada)"
                  1 -> "Rota 2"
                  2 -> "Rota 3"
                  else -> "Rota ${index + 1}"
                }

        val feature =
                Feature.fromGeometry(
                        midPoint,
                        JsonObject().apply {
                          addProperty("routeIndex", index.toString())
                          addProperty("distance", distanceText)
                          addProperty("time", timeText)
                          addProperty("label", routeLabel)
                          addProperty("distanceKm", java.lang.Double.valueOf(distanceKm))
                          addProperty("durationMinutes", java.lang.Integer.valueOf(durationMinutes))
                        }
                )
        alternativeRouteFeatures.add(feature)
      }

      if (alternativeRouteFeatures.isEmpty()) {
        return
      }

      val featureCollection = FeatureCollection.fromFeatures(alternativeRouteFeatures.toList())
      val geoJsonString = featureCollection.toJson()
      val sourceJson =
              """
        {
          "type": "geojson",
          "data": $geoJsonString
        }
      """.trimIndent()

      val sourceValueResult = com.mapbox.bindgen.Value.fromJson(sourceJson)
      when (val value = sourceValueResult.value) {
        null -> {
          Log.e(
                  "MapboxNavigationView",
                  "Erro ao criar source de rotas alternativas: ${sourceValueResult.error}"
          )
        }
        else -> {
          // Remover source e layer existentes
          if (style.styleSourceExists("alternative-routes-callouts-source")) {
            style.removeStyleSource("alternative-routes-callouts-source")
          }
          if (style.styleLayerExists("alternative-routes-callouts-layer")) {
            style.removeStyleLayer("alternative-routes-callouts-layer")
          }

          // Adicionar source
          style.addStyleSource("alternative-routes-callouts-source", value)

          // Criar SymbolLayer para callouts das rotas alternativas
          val layerJson =
                  """
            {
              "id": "alternative-routes-callouts-layer",
              "type": "symbol",
              "source": "alternative-routes-callouts-source",
              "layout": {
                "text-field": ["concat", ["get", "label"], "\n", ["get", "distance"], " ‚Ä¢ ", ["get", "time"]],
                "text-size": 12,
                "text-anchor": "center",
                "text-offset": [0, 0],
                "text-allow-overlap": true,
                "text-ignore-placement": true
              },
              "paint": {
                "text-color": "#60A5FA",
                "text-halo-color": "#1F2937",
                "text-halo-width": 2
              }
            }
          """.trimIndent()

          val layerValueResult = com.mapbox.bindgen.Value.fromJson(layerJson)
          when (val layerValue = layerValueResult.value) {
            null -> {
              Log.e(
                      "MapboxNavigationView",
                      "Erro ao criar layer de rotas alternativas: ${layerValueResult.error}"
              )
            }
            else -> {
              style.addStyleLayer(layerValue, null)
              Log.d(
                      "MapboxNavigationView",
                      "‚úÖ Rotas alternativas exibidas: ${alternativeRouteFeatures.size} rotas"
              )
            }
          }
        }
      }
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao mostrar rotas alternativas", e)
    }
  }

  /**
   * Promove uma rota alternativa para ser a rota principal. A sele√ß√£o √© feita tocando no callout da
   * rota alternativa no mapa.
   */
  private fun selectAlternativeRoute(selectedIndex: Int, source: String) {
    if (selectedIndex < 0 || selectedIndex >= alternativeRoutes.size) {
      return
    }

    // J√° √© a rota principal
    if (selectedIndex == 0) {
      return
    }

    try {
      val selected = alternativeRoutes[selectedIndex]
      val reordered = mutableListOf<NavigationRoute>()
      reordered.add(selected)
      alternativeRoutes.forEachIndexed { index, route ->
        if (index != selectedIndex) {
          reordered.add(route)
        }
      }
      alternativeRoutes = reordered.take(3)
      currentRouteIndex = 0

      mapboxNavigation?.setNavigationRoutes(alternativeRoutes)
      Log.d(
              "MapboxNavigationView",
              "‚úÖ Rota alternativa selecionada: index=$selectedIndex (source=$source)"
      )
      
      // Atualiza a interface para mostrar a rota selecionada como principal
      updateRouteVisualizationAfterSelection(selectedIndex)

      // Notificar React (se quiser mostrar UI / estado)
      val ev = Arguments.createMap()
      ev.putInt("routeIndex", selectedIndex)
      ev.putString("source", source)
      safeEmitEvent("onRouteAlternativeSelected", ev)
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao selecionar rota alternativa", e)
    }
  }
  
  /**
   * Atualiza a visualiza√ß√£o das rotas ap√≥s uma rota alternativa ser selecionada como principal
   */
  private fun updateRouteVisualizationAfterSelection(selectedIndex: Int) {
    try {
      // Atualiza a apar√™ncia das rotas para mostrar qual √© a principal
      Log.d("MapboxNavigationView", "üîÑ Atualizando visualiza√ß√£o ap√≥s sele√ß√£o da rota: $selectedIndex")
      
      // Aqui poder√≠amos atualizar a opacidade ou cor das rotas alternativas
      // para destacar a rota principal
      
      // Por exemplo, poder√≠amos alterar a espessura ou cor da rota principal
      // em rela√ß√£o √†s demais rotas alternativas
      
      // Atualizar tamb√©m os callouts para refletir a nova ordem
      val style = binding.mapView.mapboxMap.style
      if (style != null) {
        // Atualizar os callouts das rotas alternativas
        showAlternativeRoutes(alternativeRoutes)
      }
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao atualizar visualiza√ß√£o ap√≥s sele√ß√£o", e)
    }
  }
  
  private fun setupRouteAndCalloutClickListener() {
    // Adiciona listener de clique no mapa para permitir sele√ß√£o de rota alternativa
    binding.mapView.getMapboxMap().addOnMapClickListener { point ->
      try {
        Log.d("MapboxNavigationView", "üñ±Ô∏è Mapa clicado - verificando se √© clique em rota alternativa")
        
        // A funcionalidade de sele√ß√£o de rota por clique est√° implementada
        // Apenas alternamos entre as rotas dispon√≠veis quando o usu√°rio clica no mapa
        if (alternativeRoutes.size > 1) {
          // Seleciona a pr√≥xima rota na lista
          val currentIndex = currentRouteIndex
          val nextIndex = if (currentIndex < alternativeRoutes.size - 1) currentIndex + 1 else 0
          
          Log.d("MapboxNavigationView", "üîÑ Alternando rota: $currentIndex -> $nextIndex")
          selectAlternativeRoute(nextIndex, "map_click")
        }
        
        // Notificar que o clique foi detectado
        val event = Arguments.createMap()
        event.putDouble("longitude", point.longitude())
        event.putDouble("latitude", point.latitude())
        safeEmitEvent("onMapClick", event)
        
      } catch (e: Exception) {
        Log.e("MapboxNavigationView", "Erro ao processar clique no mapa", e)
      }
      false // Permitir que outros listeners processem o clique tamb√©m
    }
  }
  


  
}
