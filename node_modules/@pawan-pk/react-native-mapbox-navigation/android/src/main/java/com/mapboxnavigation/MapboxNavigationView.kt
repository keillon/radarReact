package com.mapboxnavigation

import android.annotation.SuppressLint
import android.app.AlertDialog
import android.content.res.Configuration
import android.content.res.Resources
import android.graphics.BitmapFactory
import android.os.SystemClock
import android.util.Log
import android.view.Choreographer
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.FrameLayout
import android.widget.TextView
import com.facebook.react.bridge.Arguments
import com.facebook.react.uimanager.ThemedReactContext
import com.facebook.react.uimanager.events.RCTEventEmitter
import com.google.gson.JsonObject
import com.mapbox.api.directions.v5.DirectionsCriteria
import com.mapbox.api.directions.v5.models.RouteOptions
import com.mapbox.bindgen.Expected
import com.mapbox.common.location.Location
import com.mapbox.geojson.Feature
import com.mapbox.geojson.FeatureCollection
import com.mapbox.geojson.LineString
import com.mapbox.geojson.Point
import com.mapbox.maps.CameraOptions
import com.mapbox.maps.EdgeInsets
import com.mapbox.maps.ImageHolder
import com.mapbox.maps.LayerPosition
import com.mapbox.maps.plugin.LocationPuck2D
import com.mapbox.maps.plugin.animation.camera
import com.mapbox.maps.plugin.compass.compass
import com.mapbox.maps.plugin.locationcomponent.location
import com.mapbox.maps.plugin.gestures.addOnMapClickListener
import com.mapbox.maps.extension.style.sources.getSourceAs
import com.mapbox.maps.RenderedQueryGeometry
import com.mapbox.maps.RenderedQueryOptions
import com.mapbox.maps.ScreenCoordinate
import com.mapbox.maps.viewannotation.ViewAnnotationManager
import com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI
import com.mapbox.navigation.base.TimeFormat
import com.mapbox.navigation.base.extensions.applyDefaultNavigationOptions
import com.mapbox.navigation.base.extensions.applyLanguageAndVoiceUnitOptions
import com.mapbox.navigation.base.formatter.DistanceFormatterOptions
import com.mapbox.navigation.base.formatter.UnitType
import com.mapbox.navigation.base.options.NavigationOptions
import com.mapbox.navigation.base.route.NavigationRoute
import com.mapbox.navigation.base.route.NavigationRouterCallback
import com.mapbox.navigation.base.route.RouterFailure
import com.mapbox.navigation.base.route.RouterOrigin
import com.mapbox.navigation.base.trip.model.RouteLegProgress
import com.mapbox.navigation.base.trip.model.RouteProgress
import com.mapbox.navigation.core.MapboxNavigation
import com.mapbox.navigation.core.MapboxNavigationProvider
import com.mapbox.navigation.core.arrival.ArrivalObserver
import com.mapbox.navigation.core.directions.session.RoutesObserver
import com.mapbox.navigation.core.formatter.MapboxDistanceFormatter
import com.mapbox.navigation.core.trip.session.LocationMatcherResult
import com.mapbox.navigation.core.trip.session.LocationObserver
import com.mapbox.navigation.core.trip.session.RouteProgressObserver
import com.mapbox.navigation.core.trip.session.VoiceInstructionsObserver
import com.mapbox.navigation.tripdata.maneuver.api.MapboxManeuverApi
import com.mapbox.navigation.tripdata.progress.api.MapboxTripProgressApi
import com.mapbox.navigation.tripdata.progress.model.DistanceRemainingFormatter
import com.mapbox.navigation.tripdata.progress.model.EstimatedTimeToArrivalFormatter
import com.mapbox.navigation.tripdata.progress.model.PercentDistanceTraveledFormatter
import com.mapbox.navigation.tripdata.progress.model.TimeRemainingFormatter
import com.mapbox.navigation.tripdata.progress.model.TripProgressUpdateFormatter
import com.mapbox.navigation.tripdata.speedlimit.api.MapboxSpeedInfoApi
import com.mapbox.navigation.ui.base.util.MapboxNavigationConsumer
import com.mapbox.navigation.ui.components.maneuver.model.ManeuverPrimaryOptions
import com.mapbox.navigation.ui.components.maneuver.model.ManeuverSecondaryOptions
import com.mapbox.navigation.ui.components.maneuver.model.ManeuverSubOptions
import com.mapbox.navigation.ui.components.maneuver.model.ManeuverViewOptions
import com.mapbox.navigation.ui.components.maneuver.view.MapboxManeuverView
import com.mapbox.navigation.ui.maps.NavigationStyles
import com.mapbox.navigation.ui.maps.camera.NavigationCamera
import com.mapbox.navigation.ui.maps.camera.data.MapboxNavigationViewportDataSource
import com.mapbox.navigation.ui.maps.camera.lifecycle.NavigationBasicGesturesHandler
import com.mapbox.navigation.ui.maps.camera.state.NavigationCameraState
import com.mapbox.navigation.ui.maps.camera.transition.NavigationCameraTransitionOptions
import com.mapbox.navigation.ui.maps.location.NavigationLocationProvider
import com.mapbox.navigation.ui.maps.route.RouteLayerConstants.TOP_LEVEL_ROUTE_LINE_LAYER_ID
import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowApi
import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowView
import com.mapbox.navigation.ui.maps.route.arrow.model.RouteArrowOptions
import com.mapbox.navigation.ui.maps.route.callout.api.DefaultRouteCalloutAdapter
import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineApi
import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineView
import com.mapbox.navigation.ui.maps.route.line.model.MapboxRouteLineApiOptions
import com.mapbox.navigation.ui.maps.route.line.model.MapboxRouteLineViewOptions
import com.mapbox.navigation.ui.maps.route.line.model.RouteLineColorResources
import com.mapbox.navigation.voice.api.MapboxSpeechApi
import com.mapbox.navigation.voice.api.MapboxVoiceInstructionsPlayer
import com.mapbox.navigation.voice.model.SpeechAnnouncement
import com.mapbox.navigation.voice.model.SpeechError
import com.mapbox.navigation.voice.model.SpeechValue
import com.mapbox.navigation.voice.model.SpeechVolume
import com.mapboxnavigation.databinding.NavigationViewBinding
import java.util.Locale
import java.text.Normalizer
import java.util.regex.Pattern
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import java.util.concurrent.TimeUnit

/** Ponto de radar para exibi√ß√£o no mapa (id, coordenadas, limite de velocidade, tipo). */
data class RadarPoint(
        val id: String,
        val latitude: Double,
        val longitude: Double,
        val speedLimit: Double? = null,
        val type: String? = null // Tipo do radar: "semaforico", "fixo", "m√≥vel", etc.
)

@SuppressLint("ViewConstructor")
@OptIn(ExperimentalPreviewMapboxNavigationAPI::class)
class MapboxNavigationView(private val context: ThemedReactContext) :
        FrameLayout(context.baseContext) {
  private companion object {
    private const val BUTTON_ANIMATION_DURATION = 1500L
  }

  private var origin: Point? = null
  private var destination: Point? = null
  private var destinationTitle: String = "Destination"
  private var waypoints: List<Point> = listOf()
  private var waypointLegs: List<WaypointLegs> = listOf()
  private var distanceUnit: String = DirectionsCriteria.METRIC
  private var locale = Locale("pt", "BR")

  /** Bindings to the example layout. */
  private var binding: NavigationViewBinding =
          NavigationViewBinding.inflate(LayoutInflater.from(context), this, true)

  /**
   * Produces the camera frames based on the location and routing data for the [navigationCamera] to
   * execute.
   */
  private var viewportDataSource = MapboxNavigationViewportDataSource(binding.mapView.mapboxMap)

  /**
   * Used to execute camera transitions based on the data generated by the [viewportDataSource].
   * This includes transitions from route overview to route following and continuously updating the
   * camera as the location changes.
   */
  private var navigationCamera =
          NavigationCamera(binding.mapView.mapboxMap, binding.mapView.camera, viewportDataSource)

  /**
   * Mapbox Navigation entry point. There should only be one instance of this object for the app.
   * You can use [MapboxNavigationProvider] to help create and obtain that instance.
   */
  private var mapboxNavigation: MapboxNavigation? = null

  /*
   * Padding da c√¢mera: estilo Waze ‚Äî modal fixo embaixo, posi√ß√£o do usu√°rio jogada para cima.
   * Bottom = altura do modal (trip progress + speed + margens); top/laterais m√≠nimos.
   * Assim a c√¢mera mant√©m o usu√°rio na √°rea vis√≠vel acima do modal, sem sobreposi√ß√£o.
   */
  private val pixelDensity = Resources.getSystem().displayMetrics.density
  // Overview: rota inteira na tela; bottom um pouco maior para o modal
  private val overviewPadding: EdgeInsets by lazy {
    EdgeInsets(60.0 * pixelDensity, 40.0 * pixelDensity, 200.0 * pixelDensity, 40.0 * pixelDensity)
  }
  private val landscapeOverviewPadding: EdgeInsets by lazy {
    EdgeInsets(30.0 * pixelDensity, 380.0 * pixelDensity, 120.0 * pixelDensity, 20.0 * pixelDensity)
  }
  // Following: usu√°rio na √°rea acima do modal (~220dp para acomodar o floating card + margens)
  private val followingPadding: EdgeInsets by lazy {
    EdgeInsets(70.0 * pixelDensity, 44.0 * pixelDensity, 220.0 * pixelDensity, 44.0 * pixelDensity)
  }
  private val landscapeFollowingPadding: EdgeInsets by lazy {
    EdgeInsets(40.0 * pixelDensity, 400.0 * pixelDensity, 140.0 * pixelDensity, 40.0 * pixelDensity)
  }

  // Properties for radar functionality
  private var radars: List<RadarPoint> = listOf()
  private var filteredRadars: List<RadarPoint> = listOf() // Radares filtrados pr√≥ximos √† rota
  private var nearbyRadarIds: Set<String> = setOf()
  private val loadedIconNames = mutableSetOf<String>()
  private var additionalBottomPadding: Double = 0.0
  private var lastAppliedAdditionalPadding: Double = 0.0
  private var isDestroyed: Boolean = false
  @Volatile private var isUpdatingRadars: Boolean = false // Flag for threading safety
  private var hasPendingUpdate: Boolean = false // If an update was requested during processing
  private var isStyleLoading: Boolean = false
  private val throttleHandler = android.os.Handler(android.os.Looper.getMainLooper())
  private var throttledUpdateRunnable: Runnable? = null
  private var imageMissingListenerRegistered: Boolean = false
  private var alternativeRoutes: List<NavigationRoute> = listOf()
  private var currentRouteIndex: Int = 0
  private var currentRoute: NavigationRoute? = null // Rota atual para filtrar radares
  private var navigationInitialized: Boolean = false
  private var isCameraInIdleMode: Boolean = false
  private var lastAutoRecenterTime: Long = 0
  private var isManualOverview: Boolean = false
  private var initialFocusHandled: Boolean = false
  
  // Pulse animation for radar highlight
  private val pulseHandler = android.os.Handler(android.os.Looper.getMainLooper())
  private var pulseAnimationRunnable: Runnable? = null
  private var pulseAnimationValue = 0f // 0.0 to 1.0

  // Auto-recenter timer logic
  private val autoRecenterHandler = android.os.Handler(android.os.Looper.getMainLooper())
  private var autoRecenterRunnable: Runnable? = null
  private val AUTO_RECENTER_DELAY = 10000L // 10 segundos

  // Throttle eventos enviados ao JS para evitar travamento (bridge n√£o aguenta dezenas por segundo)
  private var lastOnLocationChangeEmitTimeMs: Long = 0
  private val LOCATION_CHANGE_EMIT_INTERVAL_MS = 500L
  private var lastOnRouteProgressEmitTimeMs: Long = 0
  private val ROUTE_PROGRESS_EMIT_INTERVAL_MS = 1000L
  private var lastViewportLocationUpdateMs: Long = 0
  private val VIEWPORT_LOCATION_UPDATE_INTERVAL_MS = 120L
  private var lastViewportRouteProgressUpdateMs: Long = 0
  private val VIEWPORT_ROUTE_PROGRESS_INTERVAL_MS = 220L
  private var lastSpeedInfoUpdateMs: Long = 0
  private val SPEED_INFO_UPDATE_INTERVAL_MS = 350L
  private var lastManeuverRenderMs: Long = 0
  private val MANEUVER_RENDER_INTERVAL_MS = 250L
  private var lastArrowRenderMs: Long = 0
  private val ARROW_RENDER_INTERVAL_MS = 250L
  private var lastTripProgressUiUpdateMs: Long = 0
  private val TRIP_PROGRESS_UI_INTERVAL_MS = 300L
  private var lastRouteChangedEmitTimeMs: Long = 0
  private val ROUTE_CHANGED_EMIT_INTERVAL_MS = 1500L
  private var lastRouteGeometryHash: Int = 0
  private var lastNearbyRadarIdsHash: Int = 0
  private var lastAppliedRadarsDataHash: Int = 0
  private var lastRadarsApplyTimeMs: Long = 0
  private val RADARS_UPDATE_DEBOUNCE_MS = 150L
  private val RADARS_APPLY_MIN_INTERVAL_MS = 300L
  private var lastNearbyRadarApplyMs: Long = 0
  private val NEARBY_RADARS_APPLY_INTERVAL_MS = 250L
  private var pendingNearbyRadarIds: Set<String>? = null
  private var nearbyRadarApplyRunnable: Runnable? = null

  /**
   * Generates updates for the [MapboxManeuverView] to display the upcoming maneuver instructions
   * and remaining distance to the maneuver point.
   */
  private lateinit var maneuverApi: MapboxManeuverApi

  /**
   * Generates updates for the [MapboxTripProgressView] that include remaining time and distance to
   * the destination.
   */
  private var tripProgressApi: MapboxTripProgressApi? = null

  /**
   * Speed Limit API: formata dados de limite de velocidade para o MapboxSpeedInfoView. Ver:
   * https://docs.mapbox.com/android/navigation/guides/ui-components/speed-limit/
   */
  private val speedInfoApi: MapboxSpeedInfoApi by lazy { MapboxSpeedInfoApi() }

  /** Op√ß√µes de formata√ß√£o de dist√¢ncia (usadas tamb√©m pelo Speed Limit API). */
  private var distanceFormatterOptions: DistanceFormatterOptions? = null

  /**
   * Stores and updates the state of whether the voice instructions should be played as they come or
   * muted.
   */
  private var isVoiceInstructionsMuted = false
    set(value) {
      field = value
      if (value) {
        binding.soundButton.muteAndExtend(BUTTON_ANIMATION_DURATION)
        voiceInstructionsPlayer?.volume(SpeechVolume(0f))
      } else {
        binding.soundButton.unmuteAndExtend(BUTTON_ANIMATION_DURATION)
        voiceInstructionsPlayer?.volume(SpeechVolume(1f))
      }
    }

  /**
   * Extracts message that should be communicated to the driver about the upcoming maneuver. When
   * possible, downloads a synthesized audio file that can be played back to the driver.
   */
  private var speechApi: MapboxSpeechApi? = null

  /**
   * Plays the synthesized audio files with upcoming maneuver instructions or uses an on-device
   * Text-To-Speech engine to communicate the message to the driver. NOTE: do not use lazy
   * initialization for this class since it takes some time to initialize the system services
   * required for on-device speech synthesis. With lazy initialization there is a high risk that
   * said services will not be available when the first instruction has to be played.
   * [MapboxVoiceInstructionsPlayer] should be instantiated in `Activity#onCreate`.
   */
  private var voiceInstructionsPlayer: MapboxVoiceInstructionsPlayer? = null

  /** Observes when a new voice instruction should be played. */
  private val voiceInstructionsObserver = VoiceInstructionsObserver { voiceInstructions ->
    speechApi?.generate(voiceInstructions, speechCallback)
  }

  /**
   * Based on whether the synthesized audio file is available, the callback plays the file or uses
   * the fall back which is played back using the on-device Text-To-Speech engine.
   */
  private val speechCallback =
          MapboxNavigationConsumer<Expected<SpeechError, SpeechValue>> { expected ->
            expected.fold(
                    { error ->
                      // play the instruction via fallback text-to-speech engine
                      voiceInstructionsPlayer?.play(error.fallback, voiceInstructionsPlayerCallback)
                    },
                    { value ->
                      // play the sound file from the external generator
                      voiceInstructionsPlayer?.play(
                              value.announcement,
                              voiceInstructionsPlayerCallback
                      )
                    }
            )
          }

  /**
   * When a synthesized audio file was downloaded, this callback cleans up the disk after it was
   * played.
   */
  private val voiceInstructionsPlayerCallback =
          MapboxNavigationConsumer<SpeechAnnouncement> { value ->
            // remove already consumed file to free-up space
            speechApi?.clean(value)
          }

  /**
   * [NavigationLocationProvider] is a utility class that helps to provide location updates
   * generated by the Navigation SDK to the Maps SDK in order to update the user location indicator
   * on the map.
   */
  private val navigationLocationProvider = NavigationLocationProvider()

  // Observers
  private val offRouteObserver =
          com.mapbox.navigation.core.trip.session.OffRouteObserver { offRoute ->
            if (offRoute) {
              Log.d("MapboxNavigationView", "üöó Usu√°rio saiu da rota")
              val event = Arguments.createMap()
              event.putBoolean("offRoute", true)
              safeEmitEvent("onOffRoute", event)
            }
          }

  /**
   * RouteLine: Additional route line options are available through the [MapboxRouteLineViewOptions]
   * and [MapboxRouteLineApiOptions]. Notice here the
   * [MapboxRouteLineViewOptions.routeLineBelowLayerId] option. The map is made up of layers. In
   * this case the route line will be placed below the "road-label" layer which is a good default
   * for the most common Mapbox navigation related maps. You should consider if this should be
   * changed for your use case especially if you are using a custom map style.
   */
  private val routeLineViewOptions: MapboxRouteLineViewOptions by lazy {
    MapboxRouteLineViewOptions.Builder(context)
            /**
             * Route line related colors can be customized via the [RouteLineColorResources]. If
             * using the default colors the [RouteLineColorResources] does not need to be set as
             * seen here, the defaults will be used internally by the builder.
             */
            .routeLineColorResources(RouteLineColorResources.Builder().build())
            .routeLineBelowLayerId("road-label-navigation")
            .build()
  }

  private val routeLineApiOptions: MapboxRouteLineApiOptions by lazy {
    MapboxRouteLineApiOptions.Builder()
      .isRouteCalloutsEnabled(true)
      .build()
  }

  /**
   * RouteLine: This class is responsible for rendering route line related mutations generated by
   * the [routeLineApi]
   */
  private val routeLineView by lazy { MapboxRouteLineView(routeLineViewOptions) }

  /**
   * RouteLine: This class is responsible for generating route line related data which must be
   * rendered by the [routeLineView] in order to visualize the route line on the map.
   */
  private val routeLineApi: MapboxRouteLineApi by lazy { MapboxRouteLineApi(routeLineApiOptions) }

  /**
   * RouteArrow: This class is responsible for generating data related to maneuver arrows. The data
   * generated must be rendered by the [routeArrowView] in order to apply mutations to the map.
   */
  private val routeArrowApi: MapboxRouteArrowApi by lazy { MapboxRouteArrowApi() }

  /**
   * RouteArrow: Customization of the maneuver arrow(s) can be done using the [RouteArrowOptions].
   * Here the above layer ID is used to determine where in the map layer stack the arrows appear.
   * Above the layer of the route traffic line is being used here. Your use case may necessitate
   * adjusting this to a different layer position.
   */
  private val routeArrowOptions by lazy {
    RouteArrowOptions.Builder(context).withAboveLayerId(TOP_LEVEL_ROUTE_LINE_LAYER_ID).build()
  }

  /**
   * RouteArrow: This class is responsible for rendering the arrow related mutations generated by
   * the [routeArrowApi]
   */
  private val routeArrowView: MapboxRouteArrowView by lazy {
    MapboxRouteArrowView(routeArrowOptions)
  }

  /**
   * Gets notified with location updates.
   *
   * Exposes raw updates coming directly from the location services and the updates enhanced by the
   * Navigation SDK (cleaned up and matched to the road).
   */
  private val locationObserver =
          object : LocationObserver {
            var firstLocationUpdateReceived = false

            override fun onNewRawLocation(rawLocation: Location) {
              // not handled
            }

            override fun onNewLocationMatcherResult(locationMatcherResult: LocationMatcherResult) {
              val enhancedLocation = locationMatcherResult.enhancedLocation
              // update location puck's position on the map
              navigationLocationProvider.changePosition(
                      location = enhancedLocation,
                      keyPoints = locationMatcherResult.keyPoints,
              )

              // update camera position (throttled para evitar travar UI em devices mais fracos)
              val nowViewportMs = System.currentTimeMillis()
              if (nowViewportMs - lastViewportLocationUpdateMs >= VIEWPORT_LOCATION_UPDATE_INTERVAL_MS) {
                lastViewportLocationUpdateMs = nowViewportMs
                viewportDataSource.onLocationChanged(enhancedLocation)
                viewportDataSource.evaluate()
              }

              // if this is the first location update the activity has received,
              // it's best to immediately move the camera to the current user location
              if (!firstLocationUpdateReceived) {
                firstLocationUpdateReceived = true
                Log.d("MapboxNavigationView", "üìç Primeiro sinal: Iniciando em vis√£o geral")
                navigationCamera.requestNavigationCameraToOverview()
                
                // OTIMIZA√á√ÉO: Foco autom√°tico inicial ap√≥s 4 segundos (tempo para ver a rota)
                postDelayed({
                    if (navigationInitialized && !isDestroyed && !isManualOverview && !initialFocusHandled) {
                        Log.d("MapboxNavigationView", "üïí Foco autom√°tico inicial (delay p√≥s-sinal)")
                        navigationCamera.requestNavigationCameraToFollowing()
                        initialFocusHandled = true
                    }
                }, 4000)
              }

              // Throttle: enviar onLocationChange ao JS no m√°x. a cada 500ms (evita travamento da bridge)
              val nowMs = System.currentTimeMillis()
              if (nowMs - lastOnLocationChangeEmitTimeMs >= LOCATION_CHANGE_EMIT_INTERVAL_MS) {
                lastOnLocationChangeEmitTimeMs = nowMs
                val event = Arguments.createMap()
                event.putDouble("longitude", enhancedLocation.longitude)
                event.putDouble("latitude", enhancedLocation.latitude)
                event.putDouble("heading", enhancedLocation.bearing ?: 0.0)
                event.putDouble("accuracy", enhancedLocation.horizontalAccuracy ?: 0.0)
                safeEmitEvent("onLocationChange", event)
              }

              // OTIMIZA√á√ÉO: Recentrar autom√°tico se o usu√°rio se mover e a c√¢mera estiver parada (IDLE)
              val speed = enhancedLocation.speed // em m/s
              if (isCameraInIdleMode && !isManualOverview && speed != null && speed > (5.0 / 3.6)) { // > 5km/h
                  val now = System.currentTimeMillis()
                  if (now - lastAutoRecenterTime > 5000) { // Throttle de 5s
                      Log.d("MapboxNavigationView", "üöó Movimento detectado ($speed m/s), recentrando c√¢mera automaticamente")
                      navigationCamera.requestNavigationCameraToFollowing()
                      lastAutoRecenterTime = now
                  }
              }

              // Speed: sempre vis√≠vel ‚Äî limite da via (SpeedInfoView) ou velocidade atual
              // (TextView)
              val opts = distanceFormatterOptions
              if (opts != null) {
                try {
                  val nowSpeedMs = System.currentTimeMillis()
                  if (nowSpeedMs - lastSpeedInfoUpdateMs >= SPEED_INFO_UPDATE_INTERVAL_MS) {
                    lastSpeedInfoUpdateMs = nowSpeedMs
                    val value =
                            speedInfoApi.updatePostedAndCurrentSpeed(
                                    locationMatcherResult,
                                    opts,
                            )
                    value?.let {
                      binding.speedLimitView.render(it)
                      binding.speedLimitView.visibility = View.VISIBLE
                    }
                  }
                } catch (e: Exception) {
                  Log.w("MapboxNavigationView", "Speed update: ${e.message}")
                }
              }
            }
          }

  /** Gets notified with progress along the currently active route. */
  private val routeProgressObserver = RouteProgressObserver { routeProgress ->
    // Atualizar rota atual se necess√°rio (pode mudar durante navega√ß√£o)
    val currentNavRoute = routeProgress.navigationRoute
    if (currentNavRoute != currentRoute) {
      currentRoute = currentNavRoute
      // N√ÉO filtrar radares - mostrar todos sempre
    }

    // update the current road name display
    try {
      val leg = routeProgress.currentLegProgress
      val step = leg?.currentStepProgress?.step
      val streetName = step?.name()
      
      binding.roadNameText?.let { view ->
        if (!streetName.isNullOrEmpty()) {
          view.text = streetName
          view.visibility = View.VISIBLE
        } else {
          view.visibility = View.GONE
        }
      }
    } catch (e: Exception) {
      Log.w("MapboxNavigationView", "Erro ao atualizar nome da rua: ${e.message}")
    }

    // update camera using route progress (throttled)
    val nowViewportMs = System.currentTimeMillis()
    if (nowViewportMs - lastViewportRouteProgressUpdateMs >= VIEWPORT_ROUTE_PROGRESS_INTERVAL_MS) {
      lastViewportRouteProgressUpdateMs = nowViewportMs
      if (routeProgress.fractionTraveled.toDouble() != 0.0) {
        viewportDataSource.onRouteProgressChanged(routeProgress)
      }
      viewportDataSource.evaluate()
    }

    val nowHeavyUiMs = System.currentTimeMillis()

    // draw the upcoming maneuver arrow on the map (throttled)
    if (nowHeavyUiMs - lastArrowRenderMs >= ARROW_RENDER_INTERVAL_MS) {
      lastArrowRenderMs = nowHeavyUiMs
      try {
        val style = binding.mapView.mapboxMap.style
        if (style != null) {
          val maneuverArrowResult = routeArrowApi.addUpcomingManeuverArrow(routeProgress)
          routeArrowView.renderManeuverUpdate(style, maneuverArrowResult)
        }
      } catch (e: Exception) {
        Log.w("MapboxNavigationView", "Erro ao renderizar seta de manobra: ${e.message}")
      }
    }

    // update top banner with maneuver instructions (throttled)
    if (nowHeavyUiMs - lastManeuverRenderMs >= MANEUVER_RENDER_INTERVAL_MS) {
      lastManeuverRenderMs = nowHeavyUiMs
      try {
        if (::maneuverApi.isInitialized && binding.maneuverView != null) {
          val maneuvers = maneuverApi.getManeuvers(routeProgress)
          maneuvers.fold(
                  { error -> Log.w("Maneuvers error:", error.throwable) },
                  {
                    val maneuverViewOptions =
                            ManeuverViewOptions.Builder()
                                    .primaryManeuverOptions(
                                            ManeuverPrimaryOptions.Builder()
                                                    .textAppearance(
                                                            R.style.PrimaryManeuverTextAppearance
                                                    )
                                                    .build()
                                    )
                                    .secondaryManeuverOptions(
                                            ManeuverSecondaryOptions.Builder()
                                                    .textAppearance(R.style.ManeuverTextAppearance)
                                                    .build()
                                    )
                                    .subManeuverOptions(
                                            ManeuverSubOptions.Builder()
                                                    .textAppearance(R.style.ManeuverTextAppearance)
                                                    .build()
                                    )
                                    .stepDistanceTextAppearance(
                                            R.style.StepDistanceRemainingAppearance
                                    )
                                    .build()

                    binding.maneuverView.updateManeuverViewOptions(maneuverViewOptions)
                    binding.maneuverView.renderManeuvers(maneuvers)
                    Unit
                  }
          )
        }
      } catch (e: Exception) {
        Log.w("MapboxNavigationView", "Erro ao atualizar maneuver: ${e.message}")
      }
    }

    // update trip progress UI (throttled)
    if (nowHeavyUiMs - lastTripProgressUiUpdateMs >= TRIP_PROGRESS_UI_INTERVAL_MS) {
      lastTripProgressUiUpdateMs = nowHeavyUiMs
      updateTripProgressUi(routeProgress)
    }

    // Throttle: enviar onRouteProgressChange ao JS no m√°x. a cada 1s (evita travamento da bridge)
    val nowMs = System.currentTimeMillis()
    if (nowMs - lastOnRouteProgressEmitTimeMs >= ROUTE_PROGRESS_EMIT_INTERVAL_MS) {
      lastOnRouteProgressEmitTimeMs = nowMs
      val event = Arguments.createMap()
      event.putDouble("distanceTraveled", routeProgress.distanceTraveled.toDouble())
      event.putDouble("durationRemaining", routeProgress.durationRemaining)
      event.putDouble("fractionTraveled", routeProgress.fractionTraveled.toDouble())
      event.putDouble("distanceRemaining", routeProgress.distanceRemaining.toDouble())
      safeEmitEvent("onRouteProgressChange", event)
    }
  }

  /**
   * Atualiza a barra de trip progress manualmente usando TextViews personalizados
   */
  private fun updateTripProgressUi(routeProgress: RouteProgress) {
    try {
      val distanceRemaining = routeProgress.distanceRemaining
      val durationRemaining = routeProgress.durationRemaining
      
      // 1. Duranc√£o (Tempo restante)
      val minutes = (durationRemaining / 60).toInt()
      val durationText = when {
          minutes < 1 -> "Pr√≥ximo"
          minutes < 60 -> "$minutes min"
          else -> {
              val hours = minutes / 60
              val remainingMinutes = minutes % 60
              "${hours}h ${remainingMinutes}m"
          }
      }
      binding.timeRemainingText.text = durationText

      // 2. Dist√¢ncia restante
      val distanceText = if (distanceRemaining < 1000) {
          "${distanceRemaining.toInt()} m"
      } else {
          String.format("%.1f km", distanceRemaining / 1000.0)
      }
      binding.distanceRemainingText.text = distanceText

      // 3. ETA (Hora de chegada)
      val calendar = Calendar.getInstance()
      calendar.add(Calendar.SECOND, durationRemaining.toInt())
      val sdf = SimpleDateFormat("HH:mm", Locale.getDefault())
      binding.etaText.text = sdf.format(calendar.time)

    } catch (e: Exception) {
      Log.w("MapboxNavigationView", "updateTripProgressUi error: ${e.message}")
    }
  }



  /**
   * Gets notified whenever the tracked routes change.
   *
   * A change can mean:
   * - routes get changed with [MapboxNavigation.setNavigationRoutes]
   * - routes annotations get refreshed (for example, congestion annotation that indicate the live
   * traffic along the route)
   * - driver got off route and a reroute was executed
   */
  private val routesObserver = RoutesObserver { routeUpdateResult ->
    try {
      if (!isValidForOperations()) return@RoutesObserver

      if (routeUpdateResult.navigationRoutes.isNotEmpty()) {
        // Armazenar rota atual para refer√™ncia
        currentRoute = routeUpdateResult.navigationRoutes.first()

        // N√ÉO filtrar radares - mostrar todos sempre

        // generate route geometries with SDK default callouts (duration/ETA per route)
        val style = binding.mapView.mapboxMap.style
        if (style != null) {
          val alternativesMetadata =
                  mapboxNavigation?.getAlternativeMetadataFor(routeUpdateResult.navigationRoutes)
          routeLineApi.setNavigationRoutes(
                  routeUpdateResult.navigationRoutes,
                  alternativesMetadata ?: emptyList()
          ) { value -> 
            if (binding.mapView != null) {
              routeLineView.renderRouteDrawData(style, value) 
            }
          }
        }

        // update the camera position to account for the new route
        viewportDataSource.onRouteChanged(routeUpdateResult.navigationRoutes.first())
        viewportDataSource.evaluate()

        // Emit onRouteChanged event with updated geometry
        val activeRoute = routeUpdateResult.navigationRoutes.first()
        val geometry = activeRoute.directionsRoute.geometry()
        if (geometry != null) {
            val nowEmitMs = System.currentTimeMillis()
            val geometryHash = geometry.hashCode()
            val shouldEmit =
              geometryHash != lastRouteGeometryHash ||
              (nowEmitMs - lastRouteChangedEmitTimeMs >= ROUTE_CHANGED_EMIT_INTERVAL_MS)
            if (shouldEmit) {
              lastRouteGeometryHash = geometryHash
              lastRouteChangedEmitTimeMs = nowEmitMs
              val event = Arguments.createMap()
              try {
                val lineString = LineString.fromPolyline(geometry, 6)
                event.putString("geometry", lineString.toJson())
              } catch (e: Exception) {
                event.putString("geometry", geometry)
              }
              safeEmitEvent("onRouteChanged", event)
            }
        }
      } else {
        // Limpar rota atual e mostrar todos os radares
        currentRoute = null
        filteredRadars = radars
        updateRadarsOnMap()

        // remove the route line and route arrow from the map
        try {
          val style = binding.mapView.mapboxMap.style
          if (style != null) {
            routeLineApi.clearRouteLine { value ->
              if (binding.mapView != null) {
                routeLineView.renderClearRouteLineValue(style, value)
              }
            }
            routeArrowView.render(style, routeArrowApi.clearArrows())
          }
        } catch (e: Exception) {
          Log.w("MapboxNavigationView", "Erro ao limpar rota: ${e.message}")
        }

        // remove the route reference from camera position evaluations
        viewportDataSource.clearRouteData()
        viewportDataSource.evaluate()
      }
    } catch (e: Exception) {
      Log.w("MapboxNavigationView", "Erro no routesObserver: ${e.message}")
    }
  }

  init {
    onCreate()
  }

  private fun onCreate() {
    // initialize Mapbox Navigation v3.18.0 (token lido de res/values ou MapboxOptions)
    if (!MapboxNavigationProvider.isCreated()) {
      val navigationOptions = NavigationOptions.Builder(context).build()
      MapboxNavigationProvider.create(navigationOptions)
    }
    mapboxNavigation = MapboxNavigationProvider.retrieve()
  }

  @SuppressLint("MissingPermission")
  private fun initNavigation() {
    if (origin == null || destination == null) {
      return
    }
    if (navigationInitialized) {
      return
    }
    try {
      navigationInitialized = true
      Log.d("MapboxNavigationView", "Iniciando navega√ß√£o: origin=$origin, destination=$destination")

      // Recenter Camera
      val initialCameraOptions = CameraOptions.Builder().zoom(14.0).center(origin).build()
      binding.mapView.mapboxMap.setCamera(initialCameraOptions)

      // Start Navigation
      startNavigation()

      // set the animations lifecycle listener to ensure the NavigationCamera stops
      // automatically following the user location when the map is interacted with
      binding.mapView.camera.addCameraAnimationsLifecycleListener(
              NavigationBasicGesturesHandler(navigationCamera)
      )
      navigationCamera.registerNavigationCameraStateChangeObserver { navigationCameraState ->
        // shows/hide the recenter button depending on the camera state
        when (navigationCameraState) {
          NavigationCameraState.TRANSITION_TO_FOLLOWING, NavigationCameraState.FOLLOWING -> {
                  binding.recenter.visibility = View.INVISIBLE
                  isCameraInIdleMode = false
                  isManualOverview = false // Reset ao voltar a seguir
                  stopAutoRecenterTimer()
          }
          NavigationCameraState.TRANSITION_TO_OVERVIEW,
          NavigationCameraState.OVERVIEW,
          NavigationCameraState.IDLE -> {
                  binding.recenter.visibility = View.VISIBLE
                  isCameraInIdleMode = true
                  startAutoRecenterTimer()
          }
        }
      }

      // Remover delay antigo aqui (movido para o locationObserver)
      // set the padding values depending on screen orientation and visible view layout
      if (this.resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {
        viewportDataSource.overviewPadding = landscapeOverviewPadding
      } else {
        viewportDataSource.overviewPadding = overviewPadding
      }
      if (this.resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {
        viewportDataSource.followingPadding = landscapeFollowingPadding
      } else {
        viewportDataSource.followingPadding = followingPadding
      }

      // make sure to use the same DistanceFormatterOptions across different features (incl. Speed
      // Limit API)
      val unitType = if (distanceUnit == "imperial") UnitType.IMPERIAL else UnitType.METRIC
      val options = DistanceFormatterOptions.Builder(context).unitType(unitType).build()
      distanceFormatterOptions = options

      // initialize maneuver api that feeds the data to the top banner maneuver view
      maneuverApi = MapboxManeuverApi(MapboxDistanceFormatter(options))

      // initialize bottom progress view
      tripProgressApi =
              MapboxTripProgressApi(
                      TripProgressUpdateFormatter.Builder(context)
                              .distanceRemainingFormatter(DistanceRemainingFormatter(options))
                              .timeRemainingFormatter(TimeRemainingFormatter(context))
                              .percentRouteTraveledFormatter(PercentDistanceTraveledFormatter())
                              .estimatedTimeToArrivalFormatter(
                                      EstimatedTimeToArrivalFormatter(
                                              context,
                                              TimeFormat.NONE_SPECIFIED
                                      )
                              )
                              .build()
              )



      // initialize voice instructions api and the voice instruction player (pt-BR)
      val voiceLanguage = locale.toLanguageTag()
      speechApi = MapboxSpeechApi(context, voiceLanguage)
      try {
        voiceInstructionsPlayer = MapboxVoiceInstructionsPlayer(context, voiceLanguage)
      } catch (e: Exception) {
        Log.w("MapboxNavigationView", "Voice instructions n√£o dispon√≠veis: ${e.message}")
        voiceInstructionsPlayer = null
      }

      // load map style
      binding.mapView.mapboxMap.loadStyle(NavigationStyles.NAVIGATION_DAY_STYLE) { style ->
        // Ensure that the route line related layers are present before the route arrow
        routeLineView.initializeLayers(style)
        // Callouts padr√£o do SDK: bolha com dura√ß√£o/ETA na rota
        try {
          routeLineView.setCalloutAdapter(
            binding.mapView.viewAnnotationManager,
            DefaultRouteCalloutAdapter(context)
          )
        } catch (e: Exception) {
          Log.w("MapboxNavigationView", "Erro ao configurar callouts: ${e.message}")
        }

        // Carregar imagens de radar e registrar listener
        try {
          loadRadarImages(style)
          registerImageMissingListener(style)
          // Atualizar radares se j√° houver algum definido
          if (radars.isNotEmpty()) {
            updateRadarsOnMap()
          }
        } catch (e: Exception) {
          Log.e("MapboxNavigationView", "Erro ao inicializar radares no estilo", e)
        }
        // Compass: posi√ß√£o abaixo dos controles (recenter/overview/sound), canto inferior direito
        try {
          val density = pixelDensity.toFloat()
          binding.mapView.compass.updateSettings {
            position = Gravity.BOTTOM or Gravity.START
            marginRight = 16f * density
            marginBottom = 380f * density
            marginTop = 4f * density
            marginLeft = 4f * density
          }
        } catch (e: Exception) {
          Log.d("MapboxNavigationView", "Compass position: ${e.message}")
        }

        // Registrar listener de click no mapa para selecionar rota alternativa
        binding.mapView.mapboxMap.addOnMapClickListener { point ->
          try {
            val mapboxMap = binding.mapView.mapboxMap
            val pixel = mapboxMap.pixelForCoordinate(point)
            
            // Consultar features na camada de rota
            mapboxMap.queryRenderedFeatures(
              RenderedQueryGeometry(ScreenCoordinate(pixel.x, pixel.y)),
              RenderedQueryOptions(
                   listOf(
                     "mapbox-navigation-route-line", 
                     "mapbox-navigation-route-line-casing"
                   ), 
                   null
              )
            ) { expected ->
              if (expected.isValue) {
                val features = expected.value
                if (features != null && features.isNotEmpty()) {
                   val routes = mapboxNavigation?.getNavigationRoutes()
                   if (routes != null && routes.size > 1) {
                      // Melhor: Pegar a rota de √≠ndice 1 (primeira alternativa) e definir como prim√°ria.
                      val newRoutes = routes.toMutableList()
                      val alternative = newRoutes.removeAt(1)
                      newRoutes.add(0, alternative)
                      
                      mapboxNavigation?.setNavigationRoutes(newRoutes)
                      Log.i("MapboxNavigationView", "Rota alternativa selecionada via click!")
                      
                      // Emitir evento para React Native
                      val event = Arguments.createMap()
                      event.putBoolean("alternativeSelected", true)
                      
                      safeEmitEvent("onRouteAlternativeSelected", event)
                   }
                }
              }
            }
            // Retornar false para permitir que o mapa processe outros clicks se necess√°rio
            return@addOnMapClickListener false
          } catch(e: Exception) {
             Log.w("MapboxNavigationView", "Erro no click do mapa: ${e.message}")
          }
          false
        }
      }

      // initialize view interactions
      binding.stop.setOnClickListener {
        // Enviar pedido de cancelamento para o React Native tratar com modal personalizado
        val event = Arguments.createMap()
        event.putString("message", "Request Cancel")
        safeEmitEvent("onCancelNavigation", event)
      }

      binding.recenter.setOnClickListener {
        isManualOverview = false
        initialFocusHandled = true
        navigationCamera.requestNavigationCameraToFollowing()
        binding.routeOverview.showTextAndExtend(BUTTON_ANIMATION_DURATION)
      }
      binding.routeOverview.setOnClickListener {
        isManualOverview = true
        navigationCamera.requestNavigationCameraToOverview()
        binding.recenter.showTextAndExtend(BUTTON_ANIMATION_DURATION)
      }
      binding.soundButton.setOnClickListener {
        // mute/unmute voice instructions
        isVoiceInstructionsMuted = !isVoiceInstructionsMuted
      }

      // Check initial muted or not
      if (this.isVoiceInstructionsMuted) {
        binding.soundButton.mute()
        voiceInstructionsPlayer?.volume(SpeechVolume(0f))
      } else {
        binding.soundButton.unmute()
        voiceInstructionsPlayer?.volume(SpeechVolume(1f))
      }
    } catch (e: Exception) {
      navigationInitialized = false
      Log.e("MapboxNavigationView", "Erro ao inicializar navega√ß√£o", e)
      sendErrorToReact("Erro ao iniciar navega√ß√£o: ${e.message}")
    }
  }

  private fun onDestroy() {
    navigationInitialized = false
    isDestroyed = true
    cleanup()
    try {
      maneuverApi?.cancel()
      routeLineApi.cancel()
      routeLineView.cancel()
      speechApi?.cancel()
      voiceInstructionsPlayer?.shutdown()
      mapboxNavigation?.stopTripSession()
    } catch (e: Exception) {
      Log.w("MapboxNavigationView", "onDestroy: ${e.message}")
    }
  }

  private fun startNavigation() {
    // initialize location puck
    binding.mapView.location.apply {
      setLocationProvider(navigationLocationProvider)
      this.locationPuck =
              LocationPuck2D(
                      bearingImage =
                              ImageHolder.Companion.from(
                                      com.mapbox
                                              .navigation
                                              .ui
                                              .maps
                                              .R
                                              .drawable
                                              .mapbox_navigation_puck_icon
                              )
              )
      puckBearingEnabled = true
      enabled = true
    }

    startRoute()
  }

  private val arrivalObserver =
          object : ArrivalObserver {

            override fun onWaypointArrival(routeProgress: RouteProgress) {
              onArrival(routeProgress)
            }

            override fun onNextRouteLegStart(routeLegProgress: RouteLegProgress) {
              // do something when the user starts a new leg
            }

            override fun onFinalDestinationArrival(routeProgress: RouteProgress) {
              onArrival(routeProgress)
            }
          }

  private fun onArrival(routeProgress: RouteProgress) {
    try {
      val leg = routeProgress.currentLegProgress
      if (leg != null) {
        val event = Arguments.createMap()
        event.putInt("index", leg.legIndex)
        event.putDouble("latitude", leg.legDestination?.location?.latitude() ?: 0.0)
        event.putDouble("longitude", leg.legDestination?.location?.longitude() ?: 0.0)
        safeEmitEvent("onArrive", event)
      }
    } catch (e: Exception) {
      Log.w("MapboxNavigationView", "onArrival error: ${e.message}")
    }
  }

  override fun requestLayout() {
    super.requestLayout()
    post(measureAndLayout)
  }

  private val measureAndLayout = Runnable {
    measure(
            MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY),
            MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY)
    )
    layout(left, top, right, bottom)
  }

  private fun findRoute(coordinates: List<Point>) {
    // Separate legs work
    val indices = mutableListOf<Int>()
    val names = mutableListOf<String>()
    indices.add(0)
    names.add("origin")
    indices.addAll(waypointLegs.map { it.index })
    names.addAll(waypointLegs.map { it.name })
    indices.add(coordinates.count() - 1)
    names.add(destinationTitle)

    mapboxNavigation?.requestRoutes(
            RouteOptions.builder()
                    .applyDefaultNavigationOptions()
                    .applyLanguageAndVoiceUnitOptions(context)
                    .coordinatesList(coordinates)
                    .waypointIndicesList(indices)
                    .waypointNamesList(names)
                    .language(locale.language)
                    .steps(true)
                    .voiceInstructions(true)
                    .voiceUnits(distanceUnit)
                    .alternatives(true) // Solicitar rotas alternativas
                    .annotationsList(
                            listOf(DirectionsCriteria.ANNOTATION_MAXSPEED)
                    ) // Necess√°rio para speedLimitInfo
                    .build(),
            object : NavigationRouterCallback {
              override fun onCanceled(
                      routeOptions: RouteOptions,
                      @RouterOrigin routerOrigin: String
              ) {
                // no implementation
              }

              override fun onFailure(reasons: List<RouterFailure>, routeOptions: RouteOptions) {
                sendErrorToReact("Error finding route $reasons")
              }

              override fun onRoutesReady(
                      routes: List<NavigationRoute>,
                      @RouterOrigin routerOrigin: String
              ) {
                if (isDestroyed) return
                // Armazenar rotas alternativas (at√© 3 melhores)
                alternativeRoutes = routes.take(3)
                currentRouteIndex = 0

                // Mostrar rotas alternativas no mapa antes de iniciar navega√ß√£o
                if (alternativeRoutes.size > 1) {
                  showAlternativeRoutes(alternativeRoutes)
                }

                setRouteAndStartNavigation(routes)
              }
            }
    )
  }

  @SuppressLint("MissingPermission")
  private fun setRouteAndStartNavigation(routes: List<NavigationRoute>) {
    if (routes.isEmpty()) {
      Log.w("MapboxNavigationView", "setRouteAndStartNavigation: lista de rotas vazia")
      return
    }
    try {
      // set routes, where the first route in the list is the primary route that
      // will be used for active guidance
      mapboxNavigation?.setNavigationRoutes(routes)

      // show UI elements
      binding.maneuverView.visibility = View.VISIBLE
      binding.soundButton.visibility = View.VISIBLE
      binding.routeOverview.visibility = View.VISIBLE
      binding.tripProgressCard.visibility = View.VISIBLE
      // binding.speedLimitView.visibility = View.VISIBLE

      mapboxNavigation?.startTripSession(withForegroundService = true)
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao iniciar sess√£o de navega√ß√£o", e)
      sendErrorToReact("Erro ao iniciar navega√ß√£o: ${e.message}")
    }
  }

  private fun startRoute() {
    // Create a list of coordinates that includes origin, destination
    val coordinatesList = mutableListOf<Point>()
    this.origin?.let { coordinatesList.add(it) }
    this.waypoints.let { coordinatesList.addAll(waypoints) }
    this.destination?.let { coordinatesList.add(it) }

    if (coordinatesList.size < 2) {
      Log.e(
              "MapboxNavigationView",
              "startRoute: origem e destino s√£o obrigat√≥rios (pontos=${coordinatesList.size})"
      )
      sendErrorToReact("Origem e destino s√£o obrigat√≥rios")
      return
    }

    // register event listeners
    mapboxNavigation?.registerRoutesObserver(routesObserver)
    mapboxNavigation?.registerArrivalObserver(arrivalObserver)
    mapboxNavigation?.registerRouteProgressObserver(routeProgressObserver)
    mapboxNavigation?.registerLocationObserver(locationObserver)
    mapboxNavigation?.registerVoiceInstructionsObserver(voiceInstructionsObserver)

    findRoute(coordinatesList)
  }

  override fun onDetachedFromWindow() {
    super.onDetachedFromWindow()
    stopAutoRecenterTimer()
    mapboxNavigation?.unregisterRoutesObserver(routesObserver)
    mapboxNavigation?.unregisterArrivalObserver(arrivalObserver)
    mapboxNavigation?.unregisterLocationObserver(locationObserver)
    mapboxNavigation?.unregisterRouteProgressObserver(routeProgressObserver)
    mapboxNavigation?.unregisterVoiceInstructionsObserver(voiceInstructionsObserver)
    onDestroy()
  }

  private fun startAutoRecenterTimer() {
    stopAutoRecenterTimer()
    autoRecenterRunnable = Runnable {
      if (navigationInitialized && isCameraInIdleMode && !isManualOverview && !isDestroyed) {
        Log.d("MapboxNavigationView", "üïí Auto-recenter: Tempo de inatividade atingido (10s)")
        navigationCamera.requestNavigationCameraToFollowing()
      }
    }
    autoRecenterRunnable?.let {
      autoRecenterHandler.postDelayed(it, AUTO_RECENTER_DELAY)
    }
  }

  private fun stopAutoRecenterTimer() {
    autoRecenterRunnable?.let {
      autoRecenterHandler.removeCallbacks(it)
    }
    autoRecenterRunnable = null
  }


  private fun cleanup() {
    try {
        pulseHandler.removeCallbacksAndMessages(null)
    } catch (e: Exception) {
        Log.w("MapboxNavigationView", "Cleanup error: ${e.message}")
    }
  }

  private fun sendErrorToReact(error: String?) {
    val event = Arguments.createMap()
    event.putString("error", error)
    safeEmitEvent("onError", event)
  }

  fun onDropViewInstance() {
    this.onDestroy()
  }

  fun setStartOrigin(origin: Point?) {
    this.origin = origin
    if (destination != null) initNavigation()
  }

  fun setDestination(destination: Point?) {
    this.destination = destination
    if (origin != null) initNavigation()
  }

  fun setDestinationTitle(title: String) {
    this.destinationTitle = title
  }

  fun setWaypointLegs(legs: List<WaypointLegs>) {
    this.waypointLegs = legs
  }

  fun setWaypoints(waypoints: List<Point>) {
    this.waypoints = waypoints
  }

  fun setDirectionUnit(unit: String) {
    this.distanceUnit = unit
    if (origin != null && destination != null) initNavigation()
  }

  fun setLocal(language: String) {
    val locals = language.split("-")
    when (locals.size) {
      1 -> locale = Locale(locals.first())
      2 -> locale = Locale(locals.first(), locals.last())
    }
  }

  fun setMute(mute: Boolean) {
    this.isVoiceInstructionsMuted = mute
  }

  fun setShowCancelButton(show: Boolean) {
    binding.stop.visibility = if (show) View.VISIBLE else View.INVISIBLE
  }

  // Setter methods for radar functionality
  fun setBottomPadding(padding: Double) {
    try {
      additionalBottomPadding = padding
      updateCameraPadding()
      Log.d("MapboxNavigationView", "‚¨áÔ∏è Bottom padding atualizado para: $padding")
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao definir bottom padding", e)
    }
  }

  private var lastRadarsSignature: String = ""

  fun setRadars(radars: List<RadarPoint>) {
    try {
      if (this.radars.isEmpty() && radars.isEmpty()) return
      val signature = radars.joinToString("|") {
        "${it.id}:${it.latitude}:${it.longitude}:${it.speedLimit ?: 0.0}:${it.type ?: ""}"
      }
      if (signature == lastRadarsSignature) return
      lastRadarsSignature = signature
      this.radars = radars
      updateRadarsOnMap()
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao definir radares", e)
    }
  }

  fun setNearbyRadarIds(radarIds: Set<String>) {
    try {
      val newHash = radarIds.toList().sorted().joinToString("|").hashCode()
      if (newHash == lastNearbyRadarIdsHash) {
        return
      }
      lastNearbyRadarIdsHash = newHash
      pendingNearbyRadarIds = radarIds
      nearbyRadarApplyRunnable?.let { throttleHandler.removeCallbacks(it) }

      val now = SystemClock.uptimeMillis()
      val elapsed = now - lastNearbyRadarApplyMs
      val delay = if (elapsed >= NEARBY_RADARS_APPLY_INTERVAL_MS) 0L else NEARBY_RADARS_APPLY_INTERVAL_MS - elapsed

      nearbyRadarApplyRunnable = Runnable {
        val idsToApply = pendingNearbyRadarIds ?: emptySet()
        pendingNearbyRadarIds = null
        this.nearbyRadarIds = idsToApply
        lastNearbyRadarApplyMs = SystemClock.uptimeMillis()
        Log.d("MapboxNavigationView", "üì° ${idsToApply.size} radares pr√≥ximos definidos")
        updateRadarAnimations()
      }

      throttleHandler.postDelayed(nearbyRadarApplyRunnable!!, delay)
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao definir radares pr√≥ximos", e)
    }
  }

  private fun isValidForOperations(): Boolean {
    return try {
      !isDestroyed && binding.mapView != null
    } catch (e: Exception) {
      false
    }
  }

  // Utility functions
  private fun getCurrentStyle(): com.mapbox.maps.Style? {
    return try {
      binding.mapView.mapboxMap.style
    } catch (e: Exception) {
      null
    }
  }

  private fun safeEmitEvent(eventName: String, event: com.facebook.react.bridge.WritableMap) {
    if (isDestroyed || id == View.NO_ID) return
    
    try {
      val reactContext = context as? ThemedReactContext ?: return
      if (!reactContext.hasActiveCatalystInstance()) return

      val emitter = reactContext.getJSModule(com.facebook.react.uimanager.events.RCTEventEmitter::class.java)
      if (emitter != null) {
        emitter.receiveEvent(id, eventName, event)
      }
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao emitir evento $eventName", e)
    }
  }

  private fun updateCameraPadding() {
    try {
      val style = getCurrentStyle() ?: return

      // Atualizar padding da c√¢mera baseado no additionalBottomPadding
      // Usar l√≥gica diferencial para evitar ac√∫mulo infinito de padding
      val currentPadding = viewportDataSource.followingPadding
      
      // Aplicar densidade se necess√°rio (assumindo que entrada √© DP)
      // Mas para manter compatibilidade com comportamento atual (que usu√°rio disse "sobe um pouco"),
      // vamos manter a unidade crua por enquanto ou aplicar density se parecer muito pequeno.
      // O codigo anterior somava direto e funcionava "um pouco". Vamos manter a escala.
      // Se adicionalBottomPadding for DP, deveria ser * pixelDensity. 
      // Vamos assumir que o valor passado j√° est√° ok ou ajustar depois se precisar.
      
      val paddingToAdd = additionalBottomPadding * pixelDensity // Convertendo para pixels para garantir efeito correto

      // Recuperar base subtraindo o √∫ltimo aplicado
      val baseBottom = currentPadding.bottom - lastAppliedAdditionalPadding
      
      val newBottomPadding = baseBottom + paddingToAdd

      val newPadding =
              EdgeInsets(
                      currentPadding.top,
                      currentPadding.left,
                      newBottomPadding.coerceAtLeast(0.0), // Evitar valores negativos
                      currentPadding.right
              )

      viewportDataSource.followingPadding = newPadding
      viewportDataSource.evaluate()

      // Atualizar √∫ltimo valor aplicado
      lastAppliedAdditionalPadding = paddingToAdd

      Log.d("MapboxNavigationView", "‚úÖ Camera padding atualizado: bottom=$newBottomPadding (added: $paddingToAdd)")
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao atualizar camera padding", e)
    }
  }

  private fun updateRadarAnnotations() {
    updateRadarsOnMap()
  }

  private fun updateRadarAnimations() {
    updateNearbyRadarsInSource()
  }

  private fun buildNearbyOpacityExpressionJson(opacityWhenNearby: Double): String {
    if (nearbyRadarIds.isEmpty()) {
      return """["literal", 0.0]"""
    }
    val idsJson = nearbyRadarIds.joinToString(",") { "\"$it\"" }
    return """["case",["in",["get","id"],["literal",[$idsJson]]],$opacityWhenNearby,0.0]"""
  }

  private fun loadRadarImagesWithRetry(style: com.mapbox.maps.Style) {
    loadRadarImages(style)
  }

  private fun loadRadarImages(style: com.mapbox.maps.Style) {
    try {
      val imageNames =
              listOf(
                      "placa0",
                      "placa10",
                      "placa20",
                      "placa30",
                      "placa40",
                      "placa50",
                      "placa60",
                      "placa70",
                      "placa80",
                      "placa90",
                      "placa100",
                      "placa110",
                      "placa120",
                      "placa130",
                      "placa140",
                      "placa150",
                      "placa160",
                      "radarFixo",
                      "radarSemaforico",
                      "radarMovel",
                      "radar_fixo",
                      "radar_semaforico",
                      "radar_movel",
              )

      imageNames.forEach { imageName ->
        try {
          // Se j√° carregou, n√£o precisa tentar de novo (otimiza√ß√£o)
          if (loadedIconNames.contains(imageName) && style.getStyleImage(imageName) != null) {
              return@forEach
          }

          // Lista de poss√≠veis nomes de recursos no Android para esta imagem
          val possibleResourceNames = listOf(
            "assets_images_$imageName", // Padr√£o React Native
            "assets_images_${imageName.lowercase()}", // Padr√£o Android (min√∫sculo)
            imageName, // Nome direto
            imageName.lowercase() // Nome direto min√∫sculo
          ).distinct()

          var resourceId = 0
          var finalResourceName = ""

          for (resName in possibleResourceNames) {
              val id = context.resources.getIdentifier(resName, "drawable", context.packageName)
              if (id != 0) {
                  resourceId = id
                  finalResourceName = resName
                  break
              }
          }

          if (resourceId == 0) {
            // Log apenas para nomes principais importantes se n√£o encontrar nenhum
            if (imageName == "radarSemaforico" || imageName == "radarMovel") {
                Log.w("MapboxNavigationView", "‚ö†Ô∏è Imagem faltando no mapa: $imageName (tentados: $possibleResourceNames)")
            }
            return@forEach
          }

          val bitmap = BitmapFactory.decodeResource(context.resources, resourceId)
          if (bitmap == null) {
            Log.w("MapboxNavigationView", "‚ö†Ô∏è Bitmap null para $finalResourceName")
            return@forEach
          }

          // Adicionar ao estilo (mesmo que j√° exista, para garantir que o estilo atual tenha a imagem)
          style.addImage(imageName, bitmap)
          loadedIconNames.add(imageName)
          // Log.d("MapboxNavigationView", "‚úÖ Imagem $imageName carregada ($finalResourceName)")

        } catch (e: Exception) {
          Log.e("MapboxNavigationView", "‚ùå Erro ao carregar imagem $imageName", e)
        }
      }
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "‚ùå Erro geral ao carregar imagens", e)
    }
  }

  private fun registerImageMissingListener(style: com.mapbox.maps.Style) {
    if (imageMissingListenerRegistered) {
      return
    }

    try {
      binding.mapView.mapboxMap.subscribeStyleImageMissing { eventData ->
        val missingId = eventData.imageId
        val currentStyle = binding.mapView.mapboxMap.style ?: return@subscribeStyleImageMissing

        try {
          val resourceName = "assets_images_$missingId"
          val resourceId =
                  context.resources.getIdentifier(resourceName, "drawable", context.packageName)
          if (resourceId != 0) {
            val bitmap = BitmapFactory.decodeResource(context.resources, resourceId)
            if (bitmap != null) {
              val imageExists =
                      try {
                        currentStyle.getStyleImage(missingId) != null
                      } catch (e: Exception) {
                        false
                      }

              if (!imageExists) {
                currentStyle.addImage(missingId, bitmap)
                Log.d("MapboxNavigationView", "‚úÖ Imagem faltante $missingId carregada via listener")
              }
            }
          }
        } catch (e: Exception) {
          Log.e("MapboxNavigationView", "Erro ao processar imagem faltante $missingId", e)
        }
      }

      imageMissingListenerRegistered = true
      Log.d("MapboxNavigationView", "‚úÖ Listener de imagens faltantes registrado")
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao registrar listener de imagens faltantes", e)
    }
  }

  // Fun√ß√£o removida - n√£o filtramos mais radares, mostramos todos durante navega√ß√£o
  // private fun filterRadarsNearRoute() { ... }

  /** Calcula a dist√¢ncia m√≠nima perpendicular de um ponto at√© a rota Retorna dist√¢ncia em metros */
  private fun calculateMinDistanceToRoute(point: Point, routePoints: List<Point>): Double {
    if (routePoints.size < 2) {
      return Double.MAX_VALUE
    }

    var minDistance = Double.MAX_VALUE

    // Verificar dist√¢ncia perpendicular para cada segmento da rota
    for (i in 0 until routePoints.size - 1) {
      val segmentStart = routePoints[i]
      val segmentEnd = routePoints[i + 1]

      val distance = calculatePerpendicularDistance(point, segmentStart, segmentEnd)
      if (distance < minDistance) {
        minDistance = distance
      }
    }

    return minDistance
  }

  /**
   * Calcula dist√¢ncia perpendicular de um ponto at√© um segmento de linha Usa f√≥rmula de dist√¢ncia
   * ponto-linha Retorna dist√¢ncia em metros usando f√≥rmula de Haversine
   */
  private fun calculatePerpendicularDistance(
          point: Point,
          lineStart: Point,
          lineEnd: Point
  ): Double {
    // Calcular dist√¢ncia usando f√≥rmula de Haversine
    val R = 6371000.0 // Raio da Terra em metros

    // Converter para radianos
    val lat1 = Math.toRadians(point.latitude())
    val lon1 = Math.toRadians(point.longitude())
    val lat2 = Math.toRadians(lineStart.latitude())
    val lon2 = Math.toRadians(lineStart.longitude())
    val lat3 = Math.toRadians(lineEnd.latitude())
    val lon3 = Math.toRadians(lineEnd.longitude())

    // Calcular vetor do segmento
    val dLat = lat3 - lat2
    val dLon = lon3 - lon2

    // Calcular produto escalar para encontrar ponto mais pr√≥ximo no segmento
    val t =
            if (dLat * dLat + dLon * dLon > 0) {
              val dot = (lat1 - lat2) * dLat + (lon1 - lon2) * dLon
              val lenSq = dLat * dLat + dLon * dLon
              (dot / lenSq).coerceIn(0.0, 1.0)
            } else {
              0.0
            }

    // Ponto mais pr√≥ximo no segmento
    val closestLat = lat2 + t * dLat
    val closestLon = lon2 + t * dLon

    // Calcular dist√¢ncia Haversine entre ponto e ponto mais pr√≥ximo
    val dLat2 = lat1 - closestLat
    val dLon2 = lon1 - closestLon

    val a =
            Math.sin(dLat2 / 2) * Math.sin(dLat2 / 2) +
                    Math.cos(lat1) *
                            Math.cos(closestLat) *
                            Math.sin(dLon2 / 2) *
                            Math.sin(dLon2 / 2)
    val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))

    return R * c
  }

  private fun updateRadarsOnMap_OLD() {
    val style = getCurrentStyle() ?: return

    // Mostrar todos os radares, limitando apenas por performance (1000 radares max)
    // ESTABILIDADE: Ordenar por ID para evitar "pisca-pisca" quando a lista muda de ordem
    val radarsToDisplay = radars.sortedBy { it.id }.take(1000)

    if (radarsToDisplay.isEmpty()) {
      return
    }

    try {
      val features =
              radarsToDisplay.mapNotNull { radar: RadarPoint ->
                val speedLimit = radar.speedLimit ?: 0.0

                // Determinar imagem baseado no tipo do radar usando normaliza√ß√£o robusta
                val rawType = radar.type ?: ""
                val typeStr = Normalizer.normalize(rawType, Normalizer.Form.NFD)
                        .replace(Regex("\\p{InCombiningDiacriticalMarks}+"), "")
                        .lowercase()

                val (preferredIcon, iconSize) = when {
                  // Prioridade 1: Semaf√≥rico / C√¢mera
                  typeStr.contains("semaforo") ||
                  typeStr.contains("camera") ||
                  typeStr.contains("fotografica") ->
                      Pair("radar_semaforico", 0.05) // Pequeno

                  // Prioridade 2: M√≥vel / Mobile
                  typeStr.contains("movel") ||
                  typeStr.contains("mobile") ->
                      Pair("radar_movel", 0.05) // Pequeno

                  // Prioridade 3: Placas (Fixo ou Placa)
                  typeStr.contains("fixo") || typeStr.contains("placa") -> {
                    val speeds = listOf(20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160)
                    val closestSpeed =
                            if (speedLimit > 0) {
                              speeds.minByOrNull { kotlin.math.abs(it - speedLimit) } ?: 0
                            } else {
                              0
                            }
                    // Placas j√° est√£o em formato compativel (placa80, etc) ou podem ser placa_80 se renomearmos.
                    // Mantendo placaXX pois n√£o conflitam tanto, mas se quisermos padrao:
                    val icon = if (closestSpeed > 0) "placa$closestSpeed" else "radar_fixo"
                    Pair(icon, 0.18)
                  }

                  // Default
                  else -> Pair("radar_movel", 0.05) // Changed from "radar" to "radar_movel"
                }

                // Fallback se a imagem preferida n√£o estiver carregada
                val iconImage = if (loadedIconNames.contains(preferredIcon)) {
                    preferredIcon
                } else if (loadedIconNames.contains(preferredIcon.lowercase())) {
                    preferredIcon.lowercase()
                } else if (loadedIconNames.contains("radar_movel")) {
                    "radar_movel"
                } else {
                    return@mapNotNull null
                }

                // Match Map.tsx: No rotation logic
                val iconRotate = 0.0

                // Log de debug
                if (radarsToDisplay.indexOf(radar) < 5) {
                    Log.d("MapboxNavigationView", "üì° Radar ID: ${radar.id} | Tipo: '$typeStr' | √çcone: '$iconImage'")
                }

                val isNearby = nearbyRadarIds.contains(radar.id)

                if (radar.latitude.isNaN() || radar.longitude.isNaN() ||
                    radar.latitude.isInfinite() || radar.longitude.isInfinite()) {
                    return@mapNotNull null
                }

                Feature.fromGeometry(
                        Point.fromLngLat(radar.longitude, radar.latitude),
                        JsonObject().apply {
                          addProperty("id", radar.id)
                          addProperty("speedLimit", radar.speedLimit?.toString() ?: "")
                          addProperty("iconImage", iconImage)
                          addProperty("iconSize", iconSize)
                          addProperty("isNearby", java.lang.Boolean.valueOf(isNearby))
                          addProperty("radarType", radar.type ?: "")
                        }
                )
              }

      val featureCollection = FeatureCollection.fromFeatures(features.toList())
      val geoJsonString = featureCollection.toJson()

      loadRadarImages(style)

      if (style.styleSourceExists("radars-source")) {
           val dataValue = com.mapbox.bindgen.Value.fromJson(geoJsonString)
           dataValue.value?.let { value ->
               style.setStyleSourceProperty("radars-source", "data", value)
           }
      } else {
          // Criar fonte pela primeira vez
          val sourceJson =
                  """
            {
              "type": "geojson",
              "data": $geoJsonString
            }
          """.trimIndent()

          val sourceValueResult = com.mapbox.bindgen.Value.fromJson(sourceJson)
          sourceValueResult.value?.let { value ->
              style.addStyleSource("radars-source", value)
          }
      }

      // 1. Create/Update Highlight Layer (Circle background for pulsing effect)
      if (style.styleLayerExists("radars-highlight-layer")) {
          style.removeStyleLayer("radars-highlight-layer")
      }

      val highlightLayerJson =
          """
        {
          "id": "radars-highlight-layer",
          "type": "circle",
          "source": "radars-source",
          "paint": {
            "circle-radius": 25,
            "circle-color": "#ef4444",
            "circle-opacity": ["case", ["==", ["get", "isNearby"], true], 0.6, 0.0],
            "circle-stroke-width": 2,
            "circle-stroke-color": "#ffffff",
            "circle-stroke-opacity": ["case", ["==", ["get", "isNearby"], true], 0.8, 0.0]
          }
        }
      """.trimIndent()
      
      val highlightLayerValue = com.mapbox.bindgen.Value.fromJson(highlightLayerJson)
      highlightLayerValue.value?.let { value ->
          // Put highlight BELOW the symbol layer (or at route level)
          val layerPosition = if (style.styleLayerExists(TOP_LEVEL_ROUTE_LINE_LAYER_ID)) {
                    LayerPosition(TOP_LEVEL_ROUTE_LINE_LAYER_ID, null, null)
                  } else { null }
          style.addStyleLayer(value, layerPosition)
          
          // Start pulsing animation
          startRadarPulseAnimation(style)
      }

      // 2. Create/Update Symbol Layer (Icons)
      if (style.styleLayerExists("radars-layer-symbol")) {
          style.removeStyleLayer("radars-layer-symbol")
      }

      val layerJson =
          """
        {
          "id": "radars-layer-symbol",
          "type": "symbol",
          "source": "radars-source",
          "layout": {
            "icon-image": ["get", "iconImage"],
            "icon-size": ["get", "iconSize"],
            "icon-allow-overlap": true,
            "icon-ignore-placement": true,
            "icon-anchor": "center",
            "icon-pitch-alignment": "viewport",
            "icon-rotation-alignment": "viewport"
          },
          "paint": {}
        }
      """.trimIndent()

      val layerValueResult = com.mapbox.bindgen.Value.fromJson(layerJson)
      layerValueResult.value?.let { value ->
          // Put symobl layer ABOVE highlight layer if possible, or just add it (default is top)
          // To ensure it's above highlight, we can put it ABOVE highlight layer
          val layerPosition = if (style.styleLayerExists("radars-highlight-layer")) {
               LayerPosition("radars-highlight-layer", null, null) // Place ABOVE highlight
          } else {
               null 
          }
          style.addStyleLayer(value, layerPosition)
          Log.d("MapboxNavigationView", "‚úÖ Layer 'radars-layer-symbol' recriado com Highlight")
      } ?: Log.w("MapboxNavigationView", "‚ö†Ô∏è layerValueResult.value √© null, layer n√£o criado")


    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao atualizar radares no mapa", e)
    }
  }
  
  private fun startRadarPulseAnimation_OLD(style: com.mapbox.maps.Style) {
    // Stop any existing animation
    pulseAnimationRunnable?.let { pulseHandler.removeCallbacks(it) }
    
    pulseAnimationRunnable = object : Runnable {
      override fun run() {
        try {
          if (!style.styleLayerExists("radars-highlight-layer")) {
            return
          }
          
          // Increment animation value (0 to 1 and loop)
          pulseAnimationValue += 0.015f // Slower increment for smoother animation
          if (pulseAnimationValue > 1f) {
            pulseAnimationValue = 0f
          }
          
          // Use sine wave for smooth, natural pulsing (0 to 1 to 0)
          val sineWave = Math.sin(pulseAnimationValue * Math.PI).toFloat()
          
          // Calculate pulsing radius (25 to 45 pixels)
          val minRadius = 25.0
          val maxRadius = 45.0
          val currentRadius = minRadius + (maxRadius - minRadius) * sineWave
          
          // Calculate pulsing opacity (0.6 to 0.2 and back, synchronized with radius)
          val minOpacity = 0.2
          val maxOpacity = 0.6
          val currentOpacity = minOpacity + (maxOpacity - minOpacity) * sineWave
          
          // Update layer paint properties
          val radiusValue = com.mapbox.bindgen.Value(currentRadius)
          val opacityValue = com.mapbox.bindgen.Value(currentOpacity)
          
          style.setStyleLayerProperty("radars-highlight-layer", "circle-radius", radiusValue)
          style.setStyleLayerProperty("radars-highlight-layer", "circle-opacity", 
                                        com.mapbox.bindgen.Value.fromJson(
                                          """["case", ["==", ["get", "isNearby"], true], $currentOpacity, 0.0]"""
                                        ).value ?: opacityValue)
          
          // Schedule next frame (60ms for smoother animation, ~16fps)
          pulseHandler.postDelayed(this, 60)
        } catch (e: Exception) {
          Log.e("MapboxNavigationView", "Erro na anima√ß√£o de pulse", e)
        }
      }
    }
    
    // Start animation
    pulseHandler.post(pulseAnimationRunnable!!)
  }


  // ==============================================================================================
  // OPTIMIZED NATIVE RENDERING IMPLEMENTATION (Persistent Layers + 18k item support)
  // ==============================================================================================

  private fun updateRadarsOnMap_NO_CLUSTER() {
    try {
      val style = getCurrentStyle() ?: return
      
      // TODOS os radares agora s√£o processados (filtro removido por pedido do usu√°rio)
      val radarsToDisplay = radars

      val features = radarsToDisplay.mapNotNull { radar ->
        val typeStr = (radar.type ?: "unknown").trim().lowercase()

        val (preferredIcon, iconSize) = when {
            typeStr.contains("semaforo") || typeStr.contains("camera") || typeStr.contains("fotografica") -> Pair("radar_semaforico", 0.05)
            typeStr.contains("movel") || typeStr.contains("mobile") -> Pair("radar_movel", 0.05)
            typeStr.contains("fixo") || typeStr.contains("placa") -> {
                val speeds = listOf(20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160)
                val speed = radar.speedLimit ?: 0.0
                val closestSpeed = if (speed > 0) speeds.minByOrNull { kotlin.math.abs(it - speed) } ?: 0 else 0
                val icon = if (closestSpeed > 0) "placa$closestSpeed" else "radar_fixo"
                Pair(icon, 0.18)
            }
            else -> Pair("radar_movel", 0.05) // Changed from "radar" to "radar_movel"
        }
        
        // Normaliza√ß√£o de nomes de √≠cones
        val iconImage = if (loadedIconNames.contains(preferredIcon)) preferredIcon 
                       else if (loadedIconNames.contains(preferredIcon.lowercase())) preferredIcon.lowercase() 
                       else "radar_movel"

        val isNearby = nearbyRadarIds.contains(radar.id)
        
        if (radar.latitude.isNaN() || radar.longitude.isNaN() || radar.latitude.isInfinite() || radar.longitude.isInfinite()) {
            null
        } else {
            Feature.fromGeometry(
                Point.fromLngLat(radar.longitude, radar.latitude),
                JsonObject().apply {
                    addProperty("id", radar.id)
                    addProperty("speedLimit", radar.speedLimit?.toString() ?: "")
                    addProperty("iconImage", iconImage)
                    addProperty("iconSize", iconSize)
                    addProperty("isNearby", isNearby)
                    addProperty("radarType", radar.type ?: "")
                }
            )
        }
      }

      val featureCollection = FeatureCollection.fromFeatures(features)
      val geoJsonString = featureCollection.toJson()

      // KEY FIX: Only update DATA if source exists. Do NOT destroy layers.
      if (style.styleSourceExists("radars-source")) {
           val dataValue = com.mapbox.bindgen.Value.fromJson(geoJsonString)
           dataValue.value?.let { value ->
               style.setStyleSourceProperty("radars-source", "data", value)
           }
      } else {
          // Initialize source and layers ONCE
          loadRadarImages(style)

          val sourceJson = """
            { "type": "geojson", "data": $geoJsonString }
          """.trimIndent()

          val sourceValueResult = com.mapbox.bindgen.Value.fromJson(sourceJson)
          sourceValueResult.value?.let { value ->
              style.addStyleSource("radars-source", value)
          }

          // Highlight Layer
          val highlightLayerJson = """
            {
              "id": "radars-highlight-layer", "type": "circle", "source": "radars-source",
              "paint": {
                "circle-radius": 25, "circle-color": "#ef4444",
                "circle-opacity": ["case", ["==", ["get", "isNearby"], true], 0.6, 0.0],
                "circle-stroke-width": 2, "circle-stroke-color": "#ffffff",
                "circle-stroke-opacity": ["case", ["==", ["get", "isNearby"], true], 0.8, 0.0]
              }
            }
          """.trimIndent()
          
          val highlightLayerValue = com.mapbox.bindgen.Value.fromJson(highlightLayerJson)
          highlightLayerValue.value?.let { value ->
              val position = if (style.styleLayerExists(TOP_LEVEL_ROUTE_LINE_LAYER_ID)) LayerPosition(TOP_LEVEL_ROUTE_LINE_LAYER_ID, null, null) else null
              style.addStyleLayer(value, position)
          }

          // Symbol Layer
          val layerJson = """
            {
              "id": "radars-layer-symbol", "type": "symbol", "source": "radars-source",
              "layout": {
                "icon-image": ["get", "iconImage"], "icon-size": ["get", "iconSize"],
                "icon-allow-overlap": true, "icon-ignore-placement": true,
                "icon-anchor": "center", "icon-pitch-alignment": "viewport", "icon-rotation-alignment": "viewport"
              }
            }
          """.trimIndent()

          val layerValue = com.mapbox.bindgen.Value.fromJson(layerJson)
          layerValue.value?.let { value -> style.addStyleLayer(value, null) }
          
          startRadarPulseAnimation(style)
      }
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao atualizar radares no mapa", e)
    }
  }

  // ==============================================================================================
  // CLUSTERED NATIVE RENDERING IMPLEMENTATION (Matches Map.tsx)
  // ==============================================================================================

  // ==============================================================================================
  // CLUSTERED NATIVE RENDERING IMPLEMENTATION (Matches Map.tsx) - OPTIMIZED THREADING
  // ==============================================================================================

  private fun updateRadarsOnMap() {
    // THROTTLE: Prevents app freeze by skipping multiple rapid calls
    throttledUpdateRunnable?.let { throttleHandler.removeCallbacks(it) }
    
    throttledUpdateRunnable = Runnable {
        performUpdateRadarsOnMap()
    }
    
    // 150ms: coalesc√™ncia maior para reduzir flood no style update
    throttleHandler.postDelayed(throttledUpdateRunnable!!, RADARS_UPDATE_DEBOUNCE_MS)
  }

  private fun performUpdateRadarsOnMap() {
    if (isUpdatingRadars) {
        hasPendingUpdate = true
        return 
    }
    hasPendingUpdate = false
    
    val style = getCurrentStyle() ?: return
    
    // Copy data for thread safety
    val radarsToDisplay = ArrayList(radars)
    val loadedIcons = HashSet(loadedIconNames) // Copy set
    isUpdatingRadars = true
    
    Thread {
        try {
            // HEAVY PROCESSING OFF MAIN THREAD
            val features = radarsToDisplay.mapNotNull { radar ->
                val typeStr = (radar.type ?: "unknown").trim().lowercase()
                val (preferredIcon, iconSize) = when {
                    typeStr.contains("semaforo") || typeStr.contains("camera") || typeStr.contains("fotografica") -> Pair("radar_semaforico", 0.05)
                    typeStr.contains("movel") || typeStr.contains("mobile") -> Pair("radar_movel", 0.05)
                    typeStr.contains("fixo") || typeStr.contains("placa") -> {
                        val speeds = listOf(20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160)
                        val speed = radar.speedLimit ?: 0.0
                        val closestSpeed = if (speed > 0) speeds.minByOrNull { kotlin.math.abs(it - speed) } ?: 0 else 0
                        val icon = if (closestSpeed > 0) "placa$closestSpeed" else "radar_fixo"
                        Pair(icon, 0.18)
                    }
                    else -> Pair("radar_movel", 0.05)
                }
                
                val iconImage = if (loadedIcons.contains(preferredIcon)) preferredIcon 
                               else if (loadedIcons.contains(preferredIcon.lowercase())) preferredIcon.lowercase() 
                               else "radar_movel"
                               
                if (radar.latitude.isNaN() || radar.longitude.isNaN() || radar.latitude.isInfinite() || radar.longitude.isInfinite()) {
                    null
                } else {
                    Feature.fromGeometry(
                        Point.fromLngLat(radar.longitude, radar.latitude),
                        JsonObject().apply {
                            addProperty("id", radar.id)
                            addProperty("speedLimit", radar.speedLimit?.toString() ?: "")
                            addProperty("iconImage", iconImage)
                            addProperty("iconSize", iconSize)
                            addProperty("radarType", radar.type ?: "")
                        }
                    )
                }
            }

            val featureCollection = FeatureCollection.fromFeatures(features)
            val geoJsonString = featureCollection.toJson()
            
            // CRITICAL PERFORMANCE: Parse JSON on background thread
            val dataValueResult = com.mapbox.bindgen.Value.fromJson(geoJsonString)
            val finalDataValue = dataValueResult.value

            // POST BACK TO MAIN: executa ap√≥s pr√≥ximo frame (n√£o bloqueia frame atual)
            val handler = android.os.Handler(android.os.Looper.getMainLooper())
            val dataToApply = finalDataValue
            val geoToApply = geoJsonString
            handler.post {
                Choreographer.getInstance().postFrameCallback {
                    try {
                        if (isDestroyed) return@postFrameCallback
                        val currentStyle = getCurrentStyle()
                        if (currentStyle == null || dataToApply == null) {
                            isUpdatingRadars = false
                            return@postFrameCallback
                        }

                        if (currentStyle.styleSourceExists("radars-source")) {
                             val newDataHash = geoToApply.hashCode()
                             if (newDataHash != lastAppliedRadarsDataHash) {
                                 val now = SystemClock.uptimeMillis()
                                 val elapsed = now - lastRadarsApplyTimeMs
                                 if (elapsed < RADARS_APPLY_MIN_INTERVAL_MS) {
                                     hasPendingUpdate = true
                                     throttleHandler.postDelayed(
                                         { updateRadarsOnMap() },
                                         RADARS_APPLY_MIN_INTERVAL_MS - elapsed
                                     )
                                     isUpdatingRadars = false
                                     return@postFrameCallback
                                 }
                                 currentStyle.setStyleSourceProperty("radars-source", "data", dataToApply)
                                 lastAppliedRadarsDataHash = newDataHash
                                 lastRadarsApplyTimeMs = now
                             }
                    } else {
                        loadRadarImages(currentStyle)

                        // CONFIGURA√á√ÉO DO CLUSTER NA FONTE
                        val sourceJson = """
                          { 
                            "type": "geojson", 
                            "data": $geoToApply,
                            "cluster": true,
                            "clusterRadius": 50,
                            "clusterMaxZoom": 14
                          }
                        """.trimIndent()

                        val sourceValueResult = com.mapbox.bindgen.Value.fromJson(sourceJson)
                        sourceValueResult.value?.let { value ->
                            currentStyle.addStyleSource("radars-source", value)
                            lastAppliedRadarsDataHash = geoToApply.hashCode()
                            lastRadarsApplyTimeMs = SystemClock.uptimeMillis()
                        }

                        // 1. Layer de Clusters
                        val clusterLayerJson = """
                          {
                            "id": "radars-cluster-layer", "type": "circle", "source": "radars-source",
                            "filter": ["has", "point_count"],
                            "paint": {
                              "circle-color": [
                                "step", ["get", "point_count"],
                                "#fbbf24", 10, "#8b5800", 50, "#000000"
                              ],
                              "circle-radius": [
                                "step", ["get", "point_count"],
                                20, 10, 30, 50, 40
                              ],
                              "circle-stroke-width": 2, "circle-stroke-color": "#fbbf24"
                            }
                          }
                        """.trimIndent()
                        val clusterVal = com.mapbox.bindgen.Value.fromJson(clusterLayerJson)
                        clusterVal.value?.let { value -> 
                             currentStyle.addStyleLayer(value, null) 
                        }

                        // 2. Layer de Contagem
                        val countLayerJson = """
                          {
                            "id": "radars-cluster-count-layer", "type": "symbol", "source": "radars-source",
                            "filter": ["has", "point_count"],
                            "layout": {
                              "text-field": ["to-string", ["get", "point_count"]],
                              "text-font": ["Open Sans Regular", "Arial Unicode MS Regular"],
                              "text-size": 12 
                            },
                            "paint": { "text-color": "#ffffff" }
                          }
                        """.trimIndent()
                        val countVal = com.mapbox.bindgen.Value.fromJson(countLayerJson)
                        countVal.value?.let { value -> currentStyle.addStyleLayer(value, null) }

                        // 3. Highlight Layer
                        val highlightLayerJson = """
                          {
                            "id": "radars-highlight-layer", "type": "circle", "source": "radars-source",
                            "filter": ["!", ["has", "point_count"]],
                            "paint": {
                              "circle-radius": 25, "circle-color": "#ef4444",
                              "circle-opacity": ["literal", 0.0],
                              "circle-stroke-width": 2, "circle-stroke-color": "#ffffff",
                              "circle-stroke-opacity": ["literal", 0.0]
                            }
                          }
                        """.trimIndent()
                        
                        val highlightLayerValue = com.mapbox.bindgen.Value.fromJson(highlightLayerJson)
                        highlightLayerValue.value?.let { value ->
                            val position = if (currentStyle.styleLayerExists("radars-cluster-count-layer")) LayerPosition("radars-cluster-count-layer", null, null) else null
                            currentStyle.addStyleLayer(value, position)
                        }

                        // 4. Symbol Layer
                        val layerJson = """
                          {
                            "id": "radars-layer-symbol", "type": "symbol", "source": "radars-source",
                            "filter": ["!", ["has", "point_count"]],
                            "layout": {
                              "icon-image": ["get", "iconImage"], "icon-size": ["get", "iconSize"],
                              "icon-allow-overlap": true, "icon-ignore-placement": true,
                              "icon-anchor": "center", "icon-pitch-alignment": "viewport", "icon-rotation-alignment": "viewport"
                            }
                          }
                        """.trimIndent()

                        val layerValue = com.mapbox.bindgen.Value.fromJson(layerJson)
                        layerValue.value?.let { value -> currentStyle.addStyleLayer(value, null) }
                        
                        updateNearbyRadarsInSource()
                    }
                } catch (e: Exception) {
                    Log.e("MapboxNavigationView", "Erro ao atualizar UI de radares", e)
                } finally {
                    isUpdatingRadars = false
                    // Check if another update was requested while we were processing
                    if (hasPendingUpdate) {
                        throttleHandler.postDelayed({ updateRadarsOnMap() }, RADARS_UPDATE_DEBOUNCE_MS)
                    }
                }
                }
            }
        } catch (e: Exception) {
            Log.e("MapboxNavigationView", "Erro ao processar radares em background", e)
            isUpdatingRadars = false
            // Check if another update was requested while we were processing
            if (hasPendingUpdate) {
                throttleHandler.postDelayed({ updateRadarsOnMap() }, RADARS_UPDATE_DEBOUNCE_MS)
            }
        }
    }.start()
  }

  private fun startRadarPulseAnimation(style: com.mapbox.maps.Style) {
    if (nearbyRadarIds.isEmpty()) {
      pulseAnimationRunnable?.let { pulseHandler.removeCallbacks(it) }
      pulseAnimationRunnable = null
      return
    }
    pulseAnimationRunnable?.let { pulseHandler.removeCallbacks(it) }
    
    pulseAnimationRunnable = object : Runnable {
      override fun run() {
        try {
          if (!style.styleLayerExists("radars-highlight-layer")) return
          
          pulseAnimationValue += 0.015f 
          if (pulseAnimationValue > 1f) pulseAnimationValue = 0f
          
          val sineWave = Math.sin(pulseAnimationValue * Math.PI).toFloat()
          val currentRadius = 25.0 + (20.0 * sineWave)
          val currentOpacity = 0.2 + (0.4 * sineWave)
          
          val radiusValue = com.mapbox.bindgen.Value(currentRadius)
          style.setStyleLayerProperty("radars-highlight-layer", "circle-radius", radiusValue)
          
          // Apply opacity only to nearby ids (without rebuilding the full source)
          val opacityExp = buildNearbyOpacityExpressionJson(currentOpacity.toDouble())
          val opacityVal = com.mapbox.bindgen.Value.fromJson(opacityExp).value
          
          if (opacityVal != null) {
              style.setStyleLayerProperty("radars-highlight-layer", "circle-opacity", opacityVal)
              style.setStyleLayerProperty("radars-highlight-layer", "circle-stroke-opacity", opacityVal)
          }
          
          pulseHandler.postDelayed(this, 120)
        } catch (e: Exception) {
          Log.e("MapboxNavigationView", "Erro na anima√ß√£o de pulse", e)
        }
      }
    }
    pulseHandler.post(pulseAnimationRunnable!!)
  }

  private fun updateNearbyRadarsInSource() {
    val style = getCurrentStyle() ?: return
    try {
      if (!style.styleLayerExists("radars-highlight-layer")) return
      val opacityExp = buildNearbyOpacityExpressionJson(0.45)
      val opacityVal = com.mapbox.bindgen.Value.fromJson(opacityExp).value ?: return
      style.setStyleLayerProperty("radars-highlight-layer", "circle-opacity", opacityVal)
      style.setStyleLayerProperty("radars-highlight-layer", "circle-stroke-opacity", opacityVal)
      if (nearbyRadarIds.isEmpty()) {
        pulseAnimationRunnable?.let { pulseHandler.removeCallbacks(it) }
        pulseAnimationRunnable = null
        return
      }
      if (pulseAnimationRunnable == null) {
        startRadarPulseAnimation(style)
      }
    } catch (e: Exception) {
      Log.w("MapboxNavigationView", "Erro ao atualizar highlight de radares pr√≥ximos: ${e.message}")
    }
  }

  /** Mostra rotas alternativas no mapa com callouts e informa√ß√µes */
  private fun showAlternativeRoutes(routes: List<NavigationRoute>) {
    val style = getCurrentStyle() ?: return

    try {
      // Criar features para cada rota alternativa com informa√ß√µes
      val alternativeRouteFeatures = mutableListOf<Feature>()

      routes.forEachIndexed { index, route ->
        val directionsRoute = route.directionsRoute
        val routeGeometry = directionsRoute.geometry() ?: return@forEachIndexed

        // Converter geometria para LineString
        val routeGeoJsonString = routeGeometry.toString()
        val lineString = LineString.fromJson(routeGeoJsonString)
        if (lineString == null) return@forEachIndexed

        val routeCoordinates = lineString.coordinates()
        if (routeCoordinates.isEmpty()) return@forEachIndexed

        // Obter informa√ß√µes da rota
        val totalDistance = directionsRoute.distance() ?: 0.0
        val totalDuration = directionsRoute.duration() ?: 0.0

        // Criar callout no ponto m√©dio da rota
        val midPointIndex = routeCoordinates.size / 2
        val midCoord: Point = routeCoordinates[midPointIndex]
        val midPoint = Point.fromLngLat(midCoord.longitude(), midCoord.latitude())

        // Formatar informa√ß√µes
        val distanceKm = totalDistance / 1000.0
        val durationMinutes = (totalDuration / 60).toInt()

        val distanceText =
                if (distanceKm < 1.0) {
                  "${totalDistance.toInt()}m"
                } else {
                  String.format("%.1f", distanceKm) + "km"
                }

        val timeText =
                when {
                  durationMinutes < 60 -> "${durationMinutes}min"
                  else -> "${durationMinutes / 60}h ${durationMinutes % 60}min"
                }

        val routeLabel =
                when (index) {
                  0 -> "Rota 1 (Recomendada)"
                  1 -> "Rota 2"
                  2 -> "Rota 3"
                  else -> "Rota ${index + 1}"
                }

        val feature =
                Feature.fromGeometry(
                        midPoint,
                        JsonObject().apply {
                          addProperty("routeIndex", index.toString())
                          addProperty("distance", distanceText)
                          addProperty("time", timeText)
                          addProperty("label", routeLabel)
                          addProperty("distanceKm", java.lang.Double.valueOf(distanceKm))
                          addProperty("durationMinutes", java.lang.Integer.valueOf(durationMinutes))
                        }
                )
        alternativeRouteFeatures.add(feature)
      }

      if (alternativeRouteFeatures.isEmpty()) {
        return
      }

      val featureCollection = FeatureCollection.fromFeatures(alternativeRouteFeatures.toList())
      val geoJsonString = featureCollection.toJson()
      val sourceJson =
              """
        {
          "type": "geojson",
          "data": $geoJsonString
        }
      """.trimIndent()

      val sourceValueResult = com.mapbox.bindgen.Value.fromJson(sourceJson)
      when (val value = sourceValueResult.value) {
        null -> {
          Log.e(
                  "MapboxNavigationView",
                  "Erro ao criar source de rotas alternativas: ${sourceValueResult.error}"
          )
        }
        else -> {
          // Remover source e layer existentes
          if (style.styleSourceExists("alternative-routes-callouts-source")) {
            style.removeStyleSource("alternative-routes-callouts-source")
          }
          if (style.styleLayerExists("alternative-routes-callouts-layer")) {
            style.removeStyleLayer("alternative-routes-callouts-layer")
          }

          // Adicionar source
          style.addStyleSource("alternative-routes-callouts-source", value)

          // Criar SymbolLayer para callouts das rotas alternativas
          val layerJson =
                  """
            {
              "id": "alternative-routes-callouts-layer",
              "type": "symbol",
              "source": "alternative-routes-callouts-source",
              "layout": {
                "text-field": ["concat", ["get", "label"], "\n", ["get", "distance"], " ‚Ä¢ ", ["get", "time"]],
                "text-size": 12,
                "text-anchor": "center",
                "text-offset": [0, 0],
                "text-allow-overlap": true,
                "text-ignore-placement": true
              },
              "paint": {
                "text-color": "#60A5FA",
                "text-halo-color": "#1F2937",
                "text-halo-width": 2
              }
            }
          """.trimIndent()

          val layerValueResult = com.mapbox.bindgen.Value.fromJson(layerJson)
          when (val layerValue = layerValueResult.value) {
            null -> {
              Log.e(
                      "MapboxNavigationView",
                      "Erro ao criar layer de rotas alternativas: ${layerValueResult.error}"
              )
            }
            else -> {
              style.addStyleLayer(layerValue, null)
              Log.d(
                      "MapboxNavigationView",
                      "‚úÖ Rotas alternativas exibidas: ${alternativeRouteFeatures.size} rotas"
              )
            }
          }
        }
      }
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao mostrar rotas alternativas", e)
    }
  }

  /**
   * Promove uma rota alternativa para ser a rota principal. A sele√ß√£o √© feita tocando no callout da
   * rota alternativa no mapa.
   */
  private fun selectAlternativeRoute(selectedIndex: Int, source: String) {
    if (selectedIndex < 0 || selectedIndex >= alternativeRoutes.size) {
      return
    }

    // J√° √© a rota principal
    if (selectedIndex == 0) {
      return
    }

    try {
      val selected = alternativeRoutes[selectedIndex]
      val reordered = mutableListOf<NavigationRoute>()
      reordered.add(selected)
      alternativeRoutes.forEachIndexed { index, route ->
        if (index != selectedIndex) {
          reordered.add(route)
        }
      }
      alternativeRoutes = reordered.take(3)
      currentRouteIndex = 0

      mapboxNavigation?.setNavigationRoutes(alternativeRoutes)
      Log.d(
              "MapboxNavigationView",
              "‚úÖ Rota alternativa selecionada: index=$selectedIndex (source=$source)"
      )
      
      // Atualiza a interface para mostrar a rota selecionada como principal
      updateRouteVisualizationAfterSelection(selectedIndex)

      // Notificar React (se quiser mostrar UI / estado)
      val ev = Arguments.createMap()
      ev.putInt("routeIndex", selectedIndex)
      ev.putString("source", source)
      safeEmitEvent("onRouteAlternativeSelected", ev)
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao selecionar rota alternativa", e)
    }
  }
  
  /**
   * Atualiza a visualiza√ß√£o das rotas ap√≥s uma rota alternativa ser selecionada como principal
   */
  private fun updateRouteVisualizationAfterSelection(selectedIndex: Int) {
    try {
      // Atualiza a apar√™ncia das rotas para mostrar qual √© a principal
      Log.d("MapboxNavigationView", "üîÑ Atualizando visualiza√ß√£o ap√≥s sele√ß√£o da rota: $selectedIndex")
      
      // Aqui poder√≠amos atualizar a opacidade ou cor das rotas alternativas
      // para destacar a rota principal
      
      // Por exemplo, poder√≠amos alterar a espessura ou cor da rota principal
      // em rela√ß√£o √†s demais rotas alternativas
      
      // Atualizar tamb√©m os callouts para refletir a nova ordem
      val style = binding.mapView.mapboxMap.style
      if (style != null) {
        // Atualizar os callouts das rotas alternativas
        showAlternativeRoutes(alternativeRoutes)
      }
    } catch (e: Exception) {
      Log.e("MapboxNavigationView", "Erro ao atualizar visualiza√ß√£o ap√≥s sele√ß√£o", e)
    }
  }
  
  private fun setupRouteAndCalloutClickListener() {
    // Adiciona listener de clique no mapa para permitir sele√ß√£o de rota alternativa
    binding.mapView.getMapboxMap().addOnMapClickListener { point ->
      try {
        Log.d("MapboxNavigationView", "üñ±Ô∏è Mapa clicado - verificando se √© clique em rota alternativa")
        
        // A funcionalidade de sele√ß√£o de rota por clique est√° implementada
        // Apenas alternamos entre as rotas dispon√≠veis quando o usu√°rio clica no mapa
        if (alternativeRoutes.size > 1) {
          // Seleciona a pr√≥xima rota na lista
          val currentIndex = currentRouteIndex
          val nextIndex = if (currentIndex < alternativeRoutes.size - 1) currentIndex + 1 else 0
          
          Log.d("MapboxNavigationView", "üîÑ Alternando rota: $currentIndex -> $nextIndex")
          selectAlternativeRoute(nextIndex, "map_click")
        }
        
        // Notificar que o clique foi detectado
        val event = Arguments.createMap()
        event.putDouble("longitude", point.longitude())
        event.putDouble("latitude", point.latitude())
        safeEmitEvent("onMapClick", event)
        
      } catch (e: Exception) {
        Log.e("MapboxNavigationView", "Erro ao processar clique no mapa", e)
      }
      false // Permitir que outros listeners processem o clique tamb√©m
    }
  }
  


  
}
