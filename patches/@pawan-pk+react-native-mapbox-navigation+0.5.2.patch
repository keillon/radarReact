diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/.project b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/.project
new file mode 100644
index 0000000..83f1d08
--- /dev/null
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/.project
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>pawan-pk_react-native-mapbox-navigation</name>
+	<comment>Project pawan-pk_react-native-mapbox-navigation created by Buildship.</comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.buildship.core.gradleprojectbuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.buildship.core.gradleprojectnature</nature>
+	</natures>
+	<filteredResources>
+		<filter>
+			<id>1768515740480</id>
+			<name></name>
+			<type>30</type>
+			<matcher>
+				<id>org.eclipse.core.resources.regexFilterMatcher</id>
+				<arguments>node_modules|\.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
+</projectDescription>
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/build.gradle b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/build.gradle
index 7d28df3..3656ea3 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/build.gradle
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/build.gradle
@@ -118,9 +118,9 @@ dependencies {
   implementation "com.facebook.react:react-native:+"
   implementation "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
 
-  // mapbox dependencies
-  implementation "com.mapbox.navigationcore:navigation:3.0.2"
-  implementation "com.mapbox.navigationcore:ui-components:3.0.2"
+  // Mapbox Navigation SDK v3.18.0 (latest - Jan 2026)
+  implementation "com.mapbox.navigationcore:navigation:3.18.0"
+  implementation "com.mapbox.navigationcore:ui-components:3.18.0"
 
   implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
   implementation 'androidx.cardview:cardview:1.0.0'
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationView.kt b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationView.kt
index 41a3ba0..3da002a 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationView.kt
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationView.kt
@@ -3,24 +3,30 @@ package com.mapboxnavigation
 import android.annotation.SuppressLint
 import android.content.res.Configuration
 import android.content.res.Resources
+import android.graphics.BitmapFactory
 import android.util.Log
+import android.view.Gravity
 import android.view.LayoutInflater
 import android.view.View
 import android.widget.FrameLayout
 import com.facebook.react.bridge.Arguments
 import com.facebook.react.uimanager.ThemedReactContext
 import com.facebook.react.uimanager.events.RCTEventEmitter
+import com.google.gson.JsonObject
 import com.mapbox.api.directions.v5.DirectionsCriteria
-import com.mapbox.api.directions.v5.models.DirectionsWaypoint
 import com.mapbox.api.directions.v5.models.RouteOptions
 import com.mapbox.bindgen.Expected
 import com.mapbox.common.location.Location
+import com.mapbox.geojson.Feature
+import com.mapbox.geojson.FeatureCollection
+import com.mapbox.geojson.LineString
 import com.mapbox.geojson.Point
 import com.mapbox.maps.CameraOptions
 import com.mapbox.maps.EdgeInsets
 import com.mapbox.maps.ImageHolder
 import com.mapbox.maps.plugin.LocationPuck2D
 import com.mapbox.maps.plugin.animation.camera
+import com.mapbox.maps.plugin.compass.compass
 import com.mapbox.maps.plugin.locationcomponent.location
 import com.mapbox.navigation.base.TimeFormat
 import com.mapbox.navigation.base.extensions.applyDefaultNavigationOptions
@@ -50,13 +56,13 @@ import com.mapbox.navigation.tripdata.progress.model.EstimatedTimeToArrivalForma
 import com.mapbox.navigation.tripdata.progress.model.PercentDistanceTraveledFormatter
 import com.mapbox.navigation.tripdata.progress.model.TimeRemainingFormatter
 import com.mapbox.navigation.tripdata.progress.model.TripProgressUpdateFormatter
+import com.mapbox.navigation.tripdata.speedlimit.api.MapboxSpeedInfoApi
 import com.mapbox.navigation.ui.base.util.MapboxNavigationConsumer
 import com.mapbox.navigation.ui.components.maneuver.model.ManeuverPrimaryOptions
 import com.mapbox.navigation.ui.components.maneuver.model.ManeuverSecondaryOptions
 import com.mapbox.navigation.ui.components.maneuver.model.ManeuverSubOptions
 import com.mapbox.navigation.ui.components.maneuver.model.ManeuverViewOptions
 import com.mapbox.navigation.ui.components.maneuver.view.MapboxManeuverView
-import com.mapbox.navigation.ui.components.tripprogress.view.MapboxTripProgressView
 import com.mapbox.navigation.ui.maps.NavigationStyles
 import com.mapbox.navigation.ui.maps.camera.NavigationCamera
 import com.mapbox.navigation.ui.maps.camera.data.MapboxNavigationViewportDataSource
@@ -73,17 +79,24 @@ import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineView
 import com.mapbox.navigation.ui.maps.route.line.model.MapboxRouteLineApiOptions
 import com.mapbox.navigation.ui.maps.route.line.model.MapboxRouteLineViewOptions
 import com.mapbox.navigation.ui.maps.route.line.model.RouteLineColorResources
+import com.mapbox.navigation.ui.maps.route.callout.api.DefaultRouteCalloutAdapter
+import com.mapbox.maps.viewannotation.ViewAnnotationManager
 import com.mapbox.navigation.voice.api.MapboxSpeechApi
 import com.mapbox.navigation.voice.api.MapboxVoiceInstructionsPlayer
 import com.mapbox.navigation.voice.model.SpeechAnnouncement
 import com.mapbox.navigation.voice.model.SpeechError
 import com.mapbox.navigation.voice.model.SpeechValue
 import com.mapbox.navigation.voice.model.SpeechVolume
+import com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI
 import com.mapboxnavigation.databinding.NavigationViewBinding
+import java.text.SimpleDateFormat
+import java.util.Date
 import java.util.Locale
 
 @SuppressLint("ViewConstructor")
-class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout(context.baseContext) {
+@OptIn(ExperimentalPreviewMapboxNavigationAPI::class)
+class MapboxNavigationView(private val context: ThemedReactContext) :
+        FrameLayout(context.baseContext) {
   private companion object {
     private const val BUTTON_ANIMATION_DURATION = 1500L
   }
@@ -93,28 +106,26 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
   private var destinationTitle: String = "Destination"
   private var waypoints: List<Point> = listOf()
   private var waypointLegs: List<WaypointLegs> = listOf()
-  private var distanceUnit: String = DirectionsCriteria.IMPERIAL
-  private var locale = Locale.getDefault()
+  private var distanceUnit: String = DirectionsCriteria.METRIC
+  private var locale = Locale("pt", "BR")
 
-  /**
-   * Bindings to the example layout.
-   */
-  private var binding: NavigationViewBinding = NavigationViewBinding.inflate(LayoutInflater.from(context), this, true)
+  /** Bindings to the example layout. */
+  private var binding: NavigationViewBinding =
+          NavigationViewBinding.inflate(LayoutInflater.from(context), this, true)
 
   /**
-   * Produces the camera frames based on the location and routing data for the [navigationCamera] to execute.
+   * Produces the camera frames based on the location and routing data for the [navigationCamera] to
+   * execute.
    */
   private var viewportDataSource = MapboxNavigationViewportDataSource(binding.mapView.mapboxMap)
 
   /**
    * Used to execute camera transitions based on the data generated by the [viewportDataSource].
-   * This includes transitions from route overview to route following and continuously updating the camera as the location changes.
+   * This includes transitions from route overview to route following and continuously updating the
+   * camera as the location changes.
    */
-  private var navigationCamera = NavigationCamera(
-    binding.mapView.mapboxMap,
-    binding.mapView.camera,
-    viewportDataSource
-  )
+  private var navigationCamera =
+          NavigationCamera(binding.mapView.mapboxMap, binding.mapView.camera, viewportDataSource)
 
   /**
    * Mapbox Navigation entry point. There should only be one instance of this object for the app.
@@ -128,38 +139,31 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
    */
   private val pixelDensity = Resources.getSystem().displayMetrics.density
   private val overviewPadding: EdgeInsets by lazy {
-    EdgeInsets(
-      140.0 * pixelDensity,
-      40.0 * pixelDensity,
-      120.0 * pixelDensity,
-      40.0 * pixelDensity
-    )
+    EdgeInsets(140.0 * pixelDensity, 40.0 * pixelDensity, 120.0 * pixelDensity, 40.0 * pixelDensity)
   }
   private val landscapeOverviewPadding: EdgeInsets by lazy {
-    EdgeInsets(
-      30.0 * pixelDensity,
-      380.0 * pixelDensity,
-      110.0 * pixelDensity,
-      20.0 * pixelDensity
-    )
+    EdgeInsets(30.0 * pixelDensity, 380.0 * pixelDensity, 110.0 * pixelDensity, 20.0 * pixelDensity)
   }
   private val followingPadding: EdgeInsets by lazy {
-    EdgeInsets(
-      180.0 * pixelDensity,
-      40.0 * pixelDensity,
-      150.0 * pixelDensity,
-      40.0 * pixelDensity
-    )
+    EdgeInsets(180.0 * pixelDensity, 40.0 * pixelDensity, 150.0 * pixelDensity, 40.0 * pixelDensity)
   }
   private val landscapeFollowingPadding: EdgeInsets by lazy {
-    EdgeInsets(
-      30.0 * pixelDensity,
-      380.0 * pixelDensity,
-      110.0 * pixelDensity,
-      40.0 * pixelDensity
-    )
+    EdgeInsets(30.0 * pixelDensity, 380.0 * pixelDensity, 110.0 * pixelDensity, 40.0 * pixelDensity)
   }
 
+  // Properties for radar functionality
+  private var radars: List<RadarPoint> = listOf()
+  private var filteredRadars: List<RadarPoint> = listOf() // Radares filtrados pr√≥ximos √† rota
+  private var nearbyRadarIds: Set<String> = setOf()
+  private var additionalBottomPadding: Double = 0.0
+  private var isDestroyed: Boolean = false
+  private var isStyleLoading: Boolean = false
+  private var imageMissingListenerRegistered: Boolean = false
+  private var alternativeRoutes: List<NavigationRoute> = listOf()
+  private var currentRouteIndex: Int = 0
+  private var currentRoute: NavigationRoute? = null // Rota atual para filtrar radares
+  private var navigationInitialized: Boolean = false
+
   /**
    * Generates updates for the [MapboxManeuverView] to display the upcoming maneuver instructions
    * and remaining distance to the maneuver point.
@@ -167,12 +171,23 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
   private lateinit var maneuverApi: MapboxManeuverApi
 
   /**
-   * Generates updates for the [MapboxTripProgressView] that include remaining time and distance to the destination.
+   * Generates updates for the [MapboxTripProgressView] that include remaining time and distance to
+   * the destination.
    */
   private lateinit var tripProgressApi: MapboxTripProgressApi
 
   /**
-   * Stores and updates the state of whether the voice instructions should be played as they come or muted.
+   * Speed Limit API: formata dados de limite de velocidade para o MapboxSpeedInfoView. Ver:
+   * https://docs.mapbox.com/android/navigation/guides/ui-components/speed-limit/
+   */
+  private val speedInfoApi: MapboxSpeedInfoApi by lazy { MapboxSpeedInfoApi() }
+
+  /** Op√ß√µes de formata√ß√£o de dist√¢ncia (usadas tamb√©m pelo Speed Limit API). */
+  private var distanceFormatterOptions: DistanceFormatterOptions? = null
+
+  /**
+   * Stores and updates the state of whether the voice instructions should be played as they come or
+   * muted.
    */
   private var isVoiceInstructionsMuted = false
     set(value) {
@@ -187,134 +202,132 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
     }
 
   /**
-   * Extracts message that should be communicated to the driver about the upcoming maneuver.
-   * When possible, downloads a synthesized audio file that can be played back to the driver.
+   * Extracts message that should be communicated to the driver about the upcoming maneuver. When
+   * possible, downloads a synthesized audio file that can be played back to the driver.
    */
   private lateinit var speechApi: MapboxSpeechApi
 
   /**
-   * Plays the synthesized audio files with upcoming maneuver instructions
-   * or uses an on-device Text-To-Speech engine to communicate the message to the driver.
-   * NOTE: do not use lazy initialization for this class since it takes some time to initialize
-   * the system services required for on-device speech synthesis. With lazy initialization
-   * there is a high risk that said services will not be available when the first instruction
-   * has to be played. [MapboxVoiceInstructionsPlayer] should be instantiated in
-   * `Activity#onCreate`.
+   * Plays the synthesized audio files with upcoming maneuver instructions or uses an on-device
+   * Text-To-Speech engine to communicate the message to the driver. NOTE: do not use lazy
+   * initialization for this class since it takes some time to initialize the system services
+   * required for on-device speech synthesis. With lazy initialization there is a high risk that
+   * said services will not be available when the first instruction has to be played.
+   * [MapboxVoiceInstructionsPlayer] should be instantiated in `Activity#onCreate`.
    */
   private var voiceInstructionsPlayer: MapboxVoiceInstructionsPlayer? = null
 
-  /**
-   * Observes when a new voice instruction should be played.
-   */
+  /** Observes when a new voice instruction should be played. */
   private val voiceInstructionsObserver = VoiceInstructionsObserver { voiceInstructions ->
     speechApi.generate(voiceInstructions, speechCallback)
   }
 
   /**
-   * Based on whether the synthesized audio file is available, the callback plays the file
-   * or uses the fall back which is played back using the on-device Text-To-Speech engine.
+   * Based on whether the synthesized audio file is available, the callback plays the file or uses
+   * the fall back which is played back using the on-device Text-To-Speech engine.
    */
   private val speechCallback =
-    MapboxNavigationConsumer<Expected<SpeechError, SpeechValue>> { expected ->
-      expected.fold(
-        { error ->
-          // play the instruction via fallback text-to-speech engine
-          voiceInstructionsPlayer?.play(
-            error.fallback,
-            voiceInstructionsPlayerCallback
-          )
-        },
-        { value ->
-          // play the sound file from the external generator
-          voiceInstructionsPlayer?.play(
-            value.announcement,
-            voiceInstructionsPlayerCallback
-          )
-        }
-      )
-    }
+          MapboxNavigationConsumer<Expected<SpeechError, SpeechValue>> { expected ->
+            expected.fold(
+                    { error ->
+                      // play the instruction via fallback text-to-speech engine
+                      voiceInstructionsPlayer?.play(error.fallback, voiceInstructionsPlayerCallback)
+                    },
+                    { value ->
+                      // play the sound file from the external generator
+                      voiceInstructionsPlayer?.play(
+                              value.announcement,
+                              voiceInstructionsPlayerCallback
+                      )
+                    }
+            )
+          }
 
   /**
-   * When a synthesized audio file was downloaded, this callback cleans up the disk after it was played.
+   * When a synthesized audio file was downloaded, this callback cleans up the disk after it was
+   * played.
    */
   private val voiceInstructionsPlayerCallback =
-    MapboxNavigationConsumer<SpeechAnnouncement> { value ->
-      // remove already consumed file to free-up space
-      speechApi.clean(value)
-    }
+          MapboxNavigationConsumer<SpeechAnnouncement> { value ->
+            // remove already consumed file to free-up space
+            speechApi.clean(value)
+          }
 
   /**
-   * [NavigationLocationProvider] is a utility class that helps to provide location updates generated by the Navigation SDK
-   * to the Maps SDK in order to update the user location indicator on the map.
+   * [NavigationLocationProvider] is a utility class that helps to provide location updates
+   * generated by the Navigation SDK to the Maps SDK in order to update the user location indicator
+   * on the map.
    */
   private val navigationLocationProvider = NavigationLocationProvider()
 
+  // Observers
+  private val offRouteObserver =
+          com.mapbox.navigation.core.trip.session.OffRouteObserver { offRoute ->
+            if (offRoute) {
+              Log.d("MapboxNavigationView", "üöó Usu√°rio saiu da rota")
+              val event = Arguments.createMap()
+              event.putBoolean("offRoute", true)
+              safeEmitEvent("onOffRoute", event)
+            }
+          }
+
   /**
-   * RouteLine: Additional route line options are available through the
-   * [MapboxRouteLineViewOptions] and [MapboxRouteLineApiOptions].
-   * Notice here the [MapboxRouteLineViewOptions.routeLineBelowLayerId] option. The map is made up of layers. In this
-   * case the route line will be placed below the "road-label" layer which is a good default
+   * RouteLine: Additional route line options are available through the [MapboxRouteLineViewOptions]
+   * and [MapboxRouteLineApiOptions]. Notice here the
+   * [MapboxRouteLineViewOptions.routeLineBelowLayerId] option. The map is made up of layers. In
+   * this case the route line will be placed below the "road-label" layer which is a good default
    * for the most common Mapbox navigation related maps. You should consider if this should be
    * changed for your use case especially if you are using a custom map style.
    */
   private val routeLineViewOptions: MapboxRouteLineViewOptions by lazy {
     MapboxRouteLineViewOptions.Builder(context)
-      /**
-       * Route line related colors can be customized via the [RouteLineColorResources]. If using the
-       * default colors the [RouteLineColorResources] does not need to be set as seen here, the
-       * defaults will be used internally by the builder.
-       */
-      .routeLineColorResources(RouteLineColorResources.Builder().build())
-      .routeLineBelowLayerId("road-label-navigation")
-      .build()
+            /**
+             * Route line related colors can be customized via the [RouteLineColorResources]. If
+             * using the default colors the [RouteLineColorResources] does not need to be set as
+             * seen here, the defaults will be used internally by the builder.
+             */
+            .routeLineColorResources(RouteLineColorResources.Builder().build())
+            .routeLineBelowLayerId("road-label-navigation")
+            .build()
   }
 
   private val routeLineApiOptions: MapboxRouteLineApiOptions by lazy {
     MapboxRouteLineApiOptions.Builder()
-      .build()
+            .isRouteCalloutsEnabled(true)
+            .build()
   }
 
   /**
-   * RouteLine: This class is responsible for rendering route line related mutations generated
-   * by the [routeLineApi]
+   * RouteLine: This class is responsible for rendering route line related mutations generated by
+   * the [routeLineApi]
    */
-  private val routeLineView by lazy {
-    MapboxRouteLineView(routeLineViewOptions)
-  }
-
+  private val routeLineView by lazy { MapboxRouteLineView(routeLineViewOptions) }
 
   /**
    * RouteLine: This class is responsible for generating route line related data which must be
    * rendered by the [routeLineView] in order to visualize the route line on the map.
    */
-  private val routeLineApi: MapboxRouteLineApi by lazy {
-    MapboxRouteLineApi(routeLineApiOptions)
-  }
+  private val routeLineApi: MapboxRouteLineApi by lazy { MapboxRouteLineApi(routeLineApiOptions) }
 
   /**
-   * RouteArrow: This class is responsible for generating data related to maneuver arrows. The
-   * data generated must be rendered by the [routeArrowView] in order to apply mutations to
-   * the map.
+   * RouteArrow: This class is responsible for generating data related to maneuver arrows. The data
+   * generated must be rendered by the [routeArrowView] in order to apply mutations to the map.
    */
-  private val routeArrowApi: MapboxRouteArrowApi by lazy {
-    MapboxRouteArrowApi()
-  }
+  private val routeArrowApi: MapboxRouteArrowApi by lazy { MapboxRouteArrowApi() }
 
   /**
-   * RouteArrow: Customization of the maneuver arrow(s) can be done using the
-   * [RouteArrowOptions]. Here the above layer ID is used to determine where in the map layer
-   * stack the arrows appear. Above the layer of the route traffic line is being used here. Your
-   * use case may necessitate adjusting this to a different layer position.
+   * RouteArrow: Customization of the maneuver arrow(s) can be done using the [RouteArrowOptions].
+   * Here the above layer ID is used to determine where in the map layer stack the arrows appear.
+   * Above the layer of the route traffic line is being used here. Your use case may necessitate
+   * adjusting this to a different layer position.
    */
   private val routeArrowOptions by lazy {
-    RouteArrowOptions.Builder(context)
-      .withAboveLayerId(TOP_LEVEL_ROUTE_LINE_LAYER_ID)
-      .build()
+    RouteArrowOptions.Builder(context).withAboveLayerId(TOP_LEVEL_ROUTE_LINE_LAYER_ID).build()
   }
 
   /**
-   * RouteArrow: This class is responsible for rendering the arrow related mutations generated
-   * by the [routeArrowApi]
+   * RouteArrow: This class is responsible for rendering the arrow related mutations generated by
+   * the [routeArrowApi]
    */
   private val routeArrowView: MapboxRouteArrowView by lazy {
     MapboxRouteArrowView(routeArrowOptions)
@@ -323,54 +336,92 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
   /**
    * Gets notified with location updates.
    *
-   * Exposes raw updates coming directly from the location services
-   * and the updates enhanced by the Navigation SDK (cleaned up and matched to the road).
+   * Exposes raw updates coming directly from the location services and the updates enhanced by the
+   * Navigation SDK (cleaned up and matched to the road).
    */
-  private val locationObserver = object : LocationObserver {
-    var firstLocationUpdateReceived = false
-
-    override fun onNewRawLocation(rawLocation: Location) {
-      // not handled
-    }
-
-    override fun onNewLocationMatcherResult(locationMatcherResult: LocationMatcherResult) {
-      val enhancedLocation = locationMatcherResult.enhancedLocation
-      // update location puck's position on the map
-      navigationLocationProvider.changePosition(
-        location = enhancedLocation,
-        keyPoints = locationMatcherResult.keyPoints,
-      )
-
-      // update camera position to account for new location
-      viewportDataSource.onLocationChanged(enhancedLocation)
-      viewportDataSource.evaluate()
-
-      // if this is the first location update the activity has received,
-      // it's best to immediately move the camera to the current user location
-      if (!firstLocationUpdateReceived) {
-        firstLocationUpdateReceived = true
-        navigationCamera.requestNavigationCameraToOverview(
-          stateTransitionOptions = NavigationCameraTransitionOptions.Builder()
-            .maxDuration(0) // instant transition
-            .build()
-        )
-      }
-
-      val event = Arguments.createMap()
-      event.putDouble("longitude", enhancedLocation.longitude)
-      event.putDouble("latitude", enhancedLocation.latitude)
-      event.putDouble("heading", enhancedLocation.bearing ?: 0.0)
-      event.putDouble("accuracy", enhancedLocation.horizontalAccuracy ?: 0.0)
-      context
-        .getJSModule(RCTEventEmitter::class.java)
-        .receiveEvent(id, "onLocationChange", event)
+  private val locationObserver =
+          object : LocationObserver {
+            var firstLocationUpdateReceived = false
+
+            override fun onNewRawLocation(rawLocation: Location) {
+              // not handled
+            }
+
+            override fun onNewLocationMatcherResult(locationMatcherResult: LocationMatcherResult) {
+              val enhancedLocation = locationMatcherResult.enhancedLocation
+              // update location puck's position on the map
+              navigationLocationProvider.changePosition(
+                      location = enhancedLocation,
+                      keyPoints = locationMatcherResult.keyPoints,
+              )
+
+              // update camera position to account for new location
+              viewportDataSource.onLocationChanged(enhancedLocation)
+              viewportDataSource.evaluate()
+
+              // if this is the first location update the activity has received,
+              // it's best to immediately move the camera to the current user location
+              if (!firstLocationUpdateReceived) {
+                firstLocationUpdateReceived = true
+                navigationCamera.requestNavigationCameraToOverview(
+                        stateTransitionOptions =
+                                NavigationCameraTransitionOptions.Builder()
+                                        .maxDuration(0) // instant transition
+                                        .build()
+                )
+              }
+
+              val event = Arguments.createMap()
+              event.putDouble("longitude", enhancedLocation.longitude)
+              event.putDouble("latitude", enhancedLocation.latitude)
+              event.putDouble("heading", enhancedLocation.bearing ?: 0.0)
+              event.putDouble("accuracy", enhancedLocation.horizontalAccuracy ?: 0.0)
+              context.getJSModule(RCTEventEmitter::class.java)
+                      .receiveEvent(id, "onLocationChange", event)
+
+              // Speed: sempre vis√≠vel ‚Äî limite da via (SpeedInfoView) ou velocidade atual (TextView)
+              val opts = distanceFormatterOptions
+              if (opts != null) {
+                try {
+                  val value =
+                          speedInfoApi.updatePostedAndCurrentSpeed(
+                                  locationMatcherResult,
+                                  opts,
+                          )
+                  if (value != null) {
+                    binding.speedLimitView.render(value)
+                    binding.speedLimitView.visibility = View.VISIBLE
+                    binding.speedCurrentOnly.visibility = View.GONE
+                  } else {
+                    binding.speedLimitView.visibility = View.GONE
+                    val speedMps = locationMatcherResult.enhancedLocation.speed?.toDouble() ?: 0.0
+                    val speedStr =
+                            if (distanceUnit == DirectionsCriteria.IMPERIAL) {
+                              val mph = speedMps * 2.23694
+                              String.format(locale, "%.0f mph", mph)
+                            } else {
+                              val kmh = speedMps * 3.6
+                              String.format(locale, "%.0f km/h", kmh)
+                            }
+                    binding.speedCurrentOnly.text = speedStr
+                    binding.speedCurrentOnly.visibility = View.VISIBLE
+                  }
+                } catch (e: Exception) {
+                  Log.w("MapboxNavigationView", "Speed update: ${e.message}")
+                }
+              }
+            }
+          }
+
+  /** Gets notified with progress along the currently active route. */
+  private val routeProgressObserver = RouteProgressObserver { routeProgress ->
+    // Atualizar rota atual se necess√°rio (pode mudar durante navega√ß√£o)
+    val currentNavRoute = routeProgress.navigationRoute
+    if (currentNavRoute != currentRoute) {
+      currentRoute = currentNavRoute
+      filterRadarsNearRoute()
     }
-  }
 
-  /**
-   * Gets notified with progress along the currently active route.
-   */
-  private val routeProgressObserver = RouteProgressObserver { routeProgress ->
     // update the camera position to account for the progressed fragment of the route
     if (routeProgress.fractionTraveled.toDouble() != 0.0) {
       viewportDataSource.onRouteProgressChanged(routeProgress)
@@ -387,48 +438,108 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
     // update top banner with maneuver instructions
     val maneuvers = maneuverApi.getManeuvers(routeProgress)
     maneuvers.fold(
-      { error ->
-        Log.w("Maneuvers error:", error.throwable)
-      },
-      {
-        val maneuverViewOptions = ManeuverViewOptions.Builder()
-          .primaryManeuverOptions(
-            ManeuverPrimaryOptions.Builder()
-              .textAppearance(R.style.PrimaryManeuverTextAppearance)
-              .build()
-          )
-          .secondaryManeuverOptions(
-            ManeuverSecondaryOptions.Builder()
-              .textAppearance(R.style.ManeuverTextAppearance)
-              .build()
-          )
-          .subManeuverOptions(
-            ManeuverSubOptions.Builder()
-              .textAppearance(R.style.ManeuverTextAppearance)
-              .build()
-          )
-          .stepDistanceTextAppearance(R.style.StepDistanceRemainingAppearance)
-          .build()
-
-        binding.maneuverView.visibility = View.VISIBLE
-        binding.maneuverView.updateManeuverViewOptions(maneuverViewOptions)
-        binding.maneuverView.renderManeuvers(maneuvers)
-      }
+            { error -> Log.w("Maneuvers error:", error.throwable) },
+            {
+              val maneuverViewOptions =
+                      ManeuverViewOptions.Builder()
+                              .primaryManeuverOptions(
+                                      ManeuverPrimaryOptions.Builder()
+                                              .textAppearance(R.style.PrimaryManeuverTextAppearance)
+                                              .build()
+                              )
+                              .secondaryManeuverOptions(
+                                      ManeuverSecondaryOptions.Builder()
+                                              .textAppearance(R.style.ManeuverTextAppearance)
+                                              .build()
+                              )
+                              .subManeuverOptions(
+                                      ManeuverSubOptions.Builder()
+                                              .textAppearance(R.style.ManeuverTextAppearance)
+                                              .build()
+                              )
+                              .stepDistanceTextAppearance(R.style.StepDistanceRemainingAppearance)
+                              .build()
+
+              // Mostrar card: apenas instru√ß√£o de manobra (sem km/tempo no layout)
+              binding.maneuverCard.visibility = View.VISIBLE
+              binding.maneuverView.updateManeuverViewOptions(maneuverViewOptions)
+              binding.maneuverView.renderManeuvers(maneuvers)
+              Unit
+            }
     )
 
-    // update bottom trip progress summary
-    binding.tripProgressView.render(
-      tripProgressApi.getTripProgress(routeProgress)
-    )
+    // update trip progress: duas linhas (tempo em destaque + dist√¢ncia ‚Äî ETA), estilo primeira imagem
+    updateTripProgressUi(routeProgress)
 
     val event = Arguments.createMap()
     event.putDouble("distanceTraveled", routeProgress.distanceTraveled.toDouble())
     event.putDouble("durationRemaining", routeProgress.durationRemaining)
     event.putDouble("fractionTraveled", routeProgress.fractionTraveled.toDouble())
     event.putDouble("distanceRemaining", routeProgress.distanceRemaining.toDouble())
-    context
-      .getJSModule(RCTEventEmitter::class.java)
-      .receiveEvent(id, "onRouteProgressChange", event)
+    context.getJSModule(RCTEventEmitter::class.java)
+            .receiveEvent(id, "onRouteProgressChange", event)
+  }
+
+  /**
+   * Atualiza a barra de trip progress no estilo da primeira imagem:
+   * Linha 1: tempo restante (n√∫mero em destaque + " min" ou " h X min")
+   * Linha 2: dist√¢ncia restante ‚Äî ETA (ex: "0.3 mi ‚Äî 10:42 am")
+   */
+  private fun updateTripProgressUi(routeProgress: RouteProgress) {
+    try {
+      val durationRemainingSec = routeProgress.durationRemaining
+      val distanceRemainingM = routeProgress.distanceRemaining
+      val isImperial = distanceUnit == DirectionsCriteria.IMPERIAL
+
+      // Linha 1: tempo restante
+      val totalMinutes = (durationRemainingSec / 60).toInt()
+      val timeValue: String
+      val timeUnit: String
+      if (totalMinutes < 60) {
+        timeValue = totalMinutes.toString()
+        timeUnit = " min"
+      } else {
+        val hours = totalMinutes / 60
+        val mins = totalMinutes % 60
+        timeValue = hours.toString()
+        timeUnit = if (mins > 0) " h $mins min" else " h"
+      }
+      binding.tripProgressTimeValue.text = timeValue
+      binding.tripProgressTimeUnit.text = timeUnit
+
+      // Linha 2: dist√¢ncia ‚Äî ETA
+      val distanceStr =
+              if (isImperial) {
+                val miles = distanceRemainingM / 1609.34
+                when {
+                  miles < 0.00019 -> "${(distanceRemainingM * 3.28084).toInt()} ft"
+                  miles < 1.0 -> String.format(locale, "%.1f mi", miles)
+                  else -> String.format(locale, "%.0f mi", miles)
+                }
+              } else {
+                val km = distanceRemainingM / 1000.0
+                when {
+                  km < 0.001 -> "${distanceRemainingM.toInt()} m"
+                  km < 1.0 -> String.format(locale, "%.1f km", km)
+                  else -> String.format(locale, "%.0f km", km)
+                }
+              }
+      val etaMillis = System.currentTimeMillis() + (durationRemainingSec * 1000).toLong()
+      val etaStr =
+              try {
+                val sdf = SimpleDateFormat("h:mm a", locale)
+                sdf.format(Date(etaMillis))
+              } catch (e: Exception) {
+                try {
+                  SimpleDateFormat("HH:mm", locale).format(Date(etaMillis))
+                } catch (e2: Exception) {
+                  "--"
+                }
+              }
+      binding.tripProgressDistanceEta.text = "$distanceStr ‚Äî $etaStr"
+    } catch (e: Exception) {
+      Log.d("MapboxNavigationView", "updateTripProgressUi: ${e.message}")
+    }
   }
 
   /**
@@ -436,14 +547,23 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
    *
    * A change can mean:
    * - routes get changed with [MapboxNavigation.setNavigationRoutes]
-   * - routes annotations get refreshed (for example, congestion annotation that indicate the live traffic along the route)
+   * - routes annotations get refreshed (for example, congestion annotation that indicate the live
+   * traffic along the route)
    * - driver got off route and a reroute was executed
    */
   private val routesObserver = RoutesObserver { routeUpdateResult ->
     if (routeUpdateResult.navigationRoutes.isNotEmpty()) {
-      // generate route geometries asynchronously and render them
+      // Armazenar rota atual para filtrar radares
+      currentRoute = routeUpdateResult.navigationRoutes.first()
+
+      // Filtrar radares pr√≥ximos √† rota
+      filterRadarsNearRoute()
+
+      // generate route geometries with SDK default callouts (duration/ETA per route)
+      val alternativesMetadata = mapboxNavigation?.getAlternativeMetadataFor(routeUpdateResult.navigationRoutes)
       routeLineApi.setNavigationRoutes(
-        routeUpdateResult.navigationRoutes
+              routeUpdateResult.navigationRoutes,
+              alternativesMetadata ?: emptyList()
       ) { value ->
         binding.mapView.mapboxMap.style?.apply {
           routeLineView.renderRouteDrawData(this, value)
@@ -454,14 +574,16 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
       viewportDataSource.onRouteChanged(routeUpdateResult.navigationRoutes.first())
       viewportDataSource.evaluate()
     } else {
+      // Limpar rota atual e mostrar todos os radares
+      currentRoute = null
+      filteredRadars = radars
+      updateRadarsOnMap()
+
       // remove the route line and route arrow from the map
       val style = binding.mapView.mapboxMap.style
       if (style != null) {
         routeLineApi.clearRouteLine { value ->
-          routeLineView.renderClearRouteLineValue(
-            style,
-            value
-          )
+          routeLineView.renderClearRouteLineValue(style, value)
         }
         routeArrowView.render(style, routeArrowApi.clearArrows())
       }
@@ -477,156 +599,200 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
   }
 
   private fun onCreate() {
-    // initialize Mapbox Navigation
-    mapboxNavigation = if (MapboxNavigationProvider.isCreated()) {
-      MapboxNavigationProvider.retrieve()
-    } else {
-      MapboxNavigationProvider.create(
-        NavigationOptions.Builder(context)
-          .build()
-      )
+    // initialize Mapbox Navigation v3.18.0 (token lido de res/values ou MapboxOptions)
+    if (!MapboxNavigationProvider.isCreated()) {
+      val navigationOptions =
+              NavigationOptions.Builder(context)
+                      .build()
+      MapboxNavigationProvider.create(navigationOptions)
     }
+    mapboxNavigation = MapboxNavigationProvider.retrieve()
   }
 
   @SuppressLint("MissingPermission")
   private fun initNavigation() {
     if (origin == null || destination == null) {
-      sendErrorToReact("origin and destination are required")
       return
     }
+    if (navigationInitialized) {
+      return
+    }
+    try {
+      navigationInitialized = true
+      Log.d("MapboxNavigationView", "Iniciando navega√ß√£o: origin=$origin, destination=$destination")
 
-    // Recenter Camera
-    val initialCameraOptions = CameraOptions.Builder()
-      .zoom(14.0)
-      .center(origin)
-      .build()
-    binding.mapView.mapboxMap.setCamera(initialCameraOptions)
+      // Recenter Camera
+      val initialCameraOptions = CameraOptions.Builder().zoom(14.0).center(origin).build()
+      binding.mapView.mapboxMap.setCamera(initialCameraOptions)
 
-    // Start Navigation
-    startNavigation()
+      // Start Navigation
+      startNavigation()
 
-    // set the animations lifecycle listener to ensure the NavigationCamera stops
-    // automatically following the user location when the map is interacted with
-    binding.mapView.camera.addCameraAnimationsLifecycleListener(
-      NavigationBasicGesturesHandler(navigationCamera)
-    )
-    navigationCamera.registerNavigationCameraStateChangeObserver { navigationCameraState ->
-      // shows/hide the recenter button depending on the camera state
-      when (navigationCameraState) {
-        NavigationCameraState.TRANSITION_TO_FOLLOWING,
-        NavigationCameraState.FOLLOWING -> binding.recenter.visibility = View.INVISIBLE
-
-        NavigationCameraState.TRANSITION_TO_OVERVIEW,
-        NavigationCameraState.OVERVIEW,
-        NavigationCameraState.IDLE -> binding.recenter.visibility = View.VISIBLE
+      // set the animations lifecycle listener to ensure the NavigationCamera stops
+      // automatically following the user location when the map is interacted with
+      binding.mapView.camera.addCameraAnimationsLifecycleListener(
+              NavigationBasicGesturesHandler(navigationCamera)
+      )
+      navigationCamera.registerNavigationCameraStateChangeObserver { navigationCameraState ->
+        // shows/hide the recenter button depending on the camera state
+        when (navigationCameraState) {
+          NavigationCameraState.TRANSITION_TO_FOLLOWING, NavigationCameraState.FOLLOWING ->
+                  binding.recenter.visibility = View.INVISIBLE
+          NavigationCameraState.TRANSITION_TO_OVERVIEW,
+          NavigationCameraState.OVERVIEW,
+          NavigationCameraState.IDLE -> binding.recenter.visibility = View.VISIBLE
+        }
+      }
+      // set the padding values depending on screen orientation and visible view layout
+      if (this.resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {
+        viewportDataSource.overviewPadding = landscapeOverviewPadding
+      } else {
+        viewportDataSource.overviewPadding = overviewPadding
+      }
+      if (this.resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {
+        viewportDataSource.followingPadding = landscapeFollowingPadding
+      } else {
+        viewportDataSource.followingPadding = followingPadding
       }
-    }
-    // set the padding values depending on screen orientation and visible view layout
-    if (this.resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {
-      viewportDataSource.overviewPadding = landscapeOverviewPadding
-    } else {
-      viewportDataSource.overviewPadding = overviewPadding
-    }
-    if (this.resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {
-      viewportDataSource.followingPadding = landscapeFollowingPadding
-    } else {
-      viewportDataSource.followingPadding = followingPadding
-    }
-
-    // make sure to use the same DistanceFormatterOptions across different features
-    val unitType = if (distanceUnit == "imperial") UnitType.IMPERIAL else UnitType.METRIC
-    val distanceFormatterOptions = DistanceFormatterOptions.Builder(context)
-      .unitType(unitType)
-      .build()
-
-    // initialize maneuver api that feeds the data to the top banner maneuver view
-    maneuverApi = MapboxManeuverApi(
-      MapboxDistanceFormatter(distanceFormatterOptions)
-    )
 
-    // initialize bottom progress view
-    tripProgressApi = MapboxTripProgressApi(
-      TripProgressUpdateFormatter.Builder(context)
-        .distanceRemainingFormatter(
-          DistanceRemainingFormatter(distanceFormatterOptions)
-        )
-        .timeRemainingFormatter(
-          TimeRemainingFormatter(context)
-        )
-        .percentRouteTraveledFormatter(
-          PercentDistanceTraveledFormatter()
-        )
-        .estimatedTimeToArrivalFormatter(
-          EstimatedTimeToArrivalFormatter(context, TimeFormat.NONE_SPECIFIED)
-        )
-        .build()
-    )
-    // initialize voice instructions api and the voice instruction player
-    speechApi = MapboxSpeechApi(
-      context,
-      locale.language
-    )
-    voiceInstructionsPlayer = MapboxVoiceInstructionsPlayer(
-      context,
-      locale.language
-    )
+      // make sure to use the same DistanceFormatterOptions across different features (incl. Speed
+      // Limit API)
+      val unitType = if (distanceUnit == "imperial") UnitType.IMPERIAL else UnitType.METRIC
+      val options = DistanceFormatterOptions.Builder(context).unitType(unitType).build()
+      distanceFormatterOptions = options
+
+      // initialize maneuver api that feeds the data to the top banner maneuver view
+      maneuverApi = MapboxManeuverApi(MapboxDistanceFormatter(options))
+
+      // initialize bottom progress view
+      tripProgressApi =
+              MapboxTripProgressApi(
+                      TripProgressUpdateFormatter.Builder(context)
+                              .distanceRemainingFormatter(DistanceRemainingFormatter(options))
+                              .timeRemainingFormatter(TimeRemainingFormatter(context))
+                              .percentRouteTraveledFormatter(PercentDistanceTraveledFormatter())
+                              .estimatedTimeToArrivalFormatter(
+                                      EstimatedTimeToArrivalFormatter(
+                                              context,
+                                              TimeFormat.NONE_SPECIFIED
+                                      )
+                              )
+                              .build()
+              )
+
+      // initialize voice instructions api and the voice instruction player (pt-BR)
+      val voiceLanguage = locale.toLanguageTag()
+      speechApi = MapboxSpeechApi(context, voiceLanguage)
+      try {
+        voiceInstructionsPlayer = MapboxVoiceInstructionsPlayer(context, voiceLanguage)
+      } catch (e: Exception) {
+        Log.w("MapboxNavigationView", "Voice instructions n√£o dispon√≠veis: ${e.message}")
+        voiceInstructionsPlayer = null
+      }
 
-    // load map style
-    binding.mapView.mapboxMap.loadStyle(NavigationStyles.NAVIGATION_DAY_STYLE) {
-      // Ensure that the route line related layers are present before the route arrow
-      routeLineView.initializeLayers(it)
-    }
+      // load map style
+      binding.mapView.mapboxMap.loadStyle(NavigationStyles.NAVIGATION_DAY_STYLE) { style ->
+        // Ensure that the route line related layers are present before the route arrow
+        routeLineView.initializeLayers(style)
+        // Callouts padr√£o do SDK: bolha com dura√ß√£o/ETA na rota (doc: route-callout)
+        val viewAnnotationManager: ViewAnnotationManager = binding.mapView.viewAnnotationManager
+        val defaultCalloutAdapter = DefaultRouteCalloutAdapter(context)
+        routeLineView.setCalloutAdapter(viewAnnotationManager, defaultCalloutAdapter)
+
+        // Carregar imagens de radar e registrar listener
+        try {
+          loadRadarImages(style)
+          registerImageMissingListener(style)
+          // Atualizar radares se j√° houver algum definido
+          if (radars.isNotEmpty()) {
+            updateRadarsOnMap()
+          }
+        } catch (e: Exception) {
+          Log.e("MapboxNavigationView", "Erro ao inicializar radares no estilo", e)
+        }
+        // Compass: posi√ß√£o abaixo dos controles (recenter/overview/sound), canto inferior direito
+        try {
+          val density = pixelDensity.toFloat()
+          binding.mapView.compass.updateSettings {
+            position = Gravity.BOTTOM or Gravity.END
+            marginRight = 16f * density
+            marginBottom = 180f * density
+            marginTop = 4f * density
+            marginLeft = 4f * density
+          }
+        } catch (e: Exception) {
+          Log.d("MapboxNavigationView", "Compass position: ${e.message}")
+        }
+      }
 
-    // initialize view interactions
-    binding.stop.setOnClickListener {
-      val event = Arguments.createMap()
-      event.putString("message", "Navigation Cancel")
-      context
-        .getJSModule(RCTEventEmitter::class.java)
-        .receiveEvent(id, "onCancelNavigation", event)
-    }
+      // initialize view interactions
+      binding.stop.setOnClickListener {
+        val event = Arguments.createMap()
+        event.putString("message", "Navigation Cancel")
+        context.getJSModule(RCTEventEmitter::class.java)
+                .receiveEvent(id, "onCancelNavigation", event)
+      }
 
-    binding.recenter.setOnClickListener {
-      navigationCamera.requestNavigationCameraToFollowing()
-      binding.routeOverview.showTextAndExtend(BUTTON_ANIMATION_DURATION)
-    }
-    binding.routeOverview.setOnClickListener {
-      navigationCamera.requestNavigationCameraToOverview()
-      binding.recenter.showTextAndExtend(BUTTON_ANIMATION_DURATION)
-    }
-    binding.soundButton.setOnClickListener {
-      // mute/unmute voice instructions
-      isVoiceInstructionsMuted = !isVoiceInstructionsMuted
-    }
+      binding.recenter.setOnClickListener {
+        navigationCamera.requestNavigationCameraToFollowing()
+        binding.routeOverview.showTextAndExtend(BUTTON_ANIMATION_DURATION)
+      }
+      binding.routeOverview.setOnClickListener {
+        navigationCamera.requestNavigationCameraToOverview()
+        binding.recenter.showTextAndExtend(BUTTON_ANIMATION_DURATION)
+      }
+      binding.soundButton.setOnClickListener {
+        // mute/unmute voice instructions
+        isVoiceInstructionsMuted = !isVoiceInstructionsMuted
+      }
 
-    // Check initial muted or not
-    if (this.isVoiceInstructionsMuted) {
-      binding.soundButton.mute()
-      voiceInstructionsPlayer?.volume(SpeechVolume(0f))
-    } else {
-      binding.soundButton.unmute()
-      voiceInstructionsPlayer?.volume(SpeechVolume(1f))
+      // Check initial muted or not
+      if (this.isVoiceInstructionsMuted) {
+        binding.soundButton.mute()
+        voiceInstructionsPlayer?.volume(SpeechVolume(0f))
+      } else {
+        binding.soundButton.unmute()
+        voiceInstructionsPlayer?.volume(SpeechVolume(1f))
+      }
+    } catch (e: Exception) {
+      navigationInitialized = false
+      Log.e("MapboxNavigationView", "Erro ao inicializar navega√ß√£o", e)
+      sendErrorToReact("Erro ao iniciar navega√ß√£o: ${e.message}")
     }
   }
 
   private fun onDestroy() {
-    maneuverApi.cancel()
-    routeLineApi.cancel()
-    routeLineView.cancel()
-    speechApi.cancel()
-    voiceInstructionsPlayer?.shutdown()
-    mapboxNavigation?.stopTripSession()
+    navigationInitialized = false
+    isDestroyed = true
+    try {
+      maneuverApi.cancel()
+      routeLineApi.cancel()
+      routeLineView.cancel()
+      speechApi.cancel()
+      voiceInstructionsPlayer?.shutdown()
+      mapboxNavigation?.stopTripSession()
+    } catch (e: Exception) {
+      Log.w("MapboxNavigationView", "onDestroy: ${e.message}")
+    }
   }
 
   private fun startNavigation() {
     // initialize location puck
     binding.mapView.location.apply {
       setLocationProvider(navigationLocationProvider)
-      this.locationPuck = LocationPuck2D(
-        bearingImage = ImageHolder.Companion.from(
-          com.mapbox.navigation.ui.maps.R.drawable.mapbox_navigation_puck_icon
-        )
-      )
+      this.locationPuck =
+              LocationPuck2D(
+                      bearingImage =
+                              ImageHolder.Companion.from(
+                                      com.mapbox
+                                              .navigation
+                                              .ui
+                                              .maps
+                                              .R
+                                              .drawable
+                                              .mapbox_navigation_puck_icon
+                              )
+              )
       puckBearingEnabled = true
       enabled = true
     }
@@ -634,20 +800,21 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
     startRoute()
   }
 
-  private val arrivalObserver = object : ArrivalObserver {
+  private val arrivalObserver =
+          object : ArrivalObserver {
 
-    override fun onWaypointArrival(routeProgress: RouteProgress) {
-      onArrival(routeProgress)
-    }
+            override fun onWaypointArrival(routeProgress: RouteProgress) {
+              onArrival(routeProgress)
+            }
 
-    override fun onNextRouteLegStart(routeLegProgress: RouteLegProgress) {
-      // do something when the user starts a new leg
-    }
+            override fun onNextRouteLegStart(routeLegProgress: RouteLegProgress) {
+              // do something when the user starts a new leg
+            }
 
-    override fun onFinalDestinationArrival(routeProgress: RouteProgress) {
-      onArrival(routeProgress)
-    }
-  }
+            override fun onFinalDestinationArrival(routeProgress: RouteProgress) {
+              onArrival(routeProgress)
+            }
+          }
 
   private fun onArrival(routeProgress: RouteProgress) {
     val leg = routeProgress.currentLegProgress
@@ -656,9 +823,7 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
       event.putInt("index", leg.legIndex)
       event.putDouble("latitude", leg.legDestination?.location?.latitude() ?: 0.0)
       event.putDouble("longitude", leg.legDestination?.location?.longitude() ?: 0.0)
-      context
-        .getJSModule(RCTEventEmitter::class.java)
-        .receiveEvent(id, "onArrive", event)
+      context.getJSModule(RCTEventEmitter::class.java).receiveEvent(id, "onArrive", event)
     }
   }
 
@@ -669,8 +834,8 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
 
   private val measureAndLayout = Runnable {
     measure(
-      MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY),
-      MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY)
+            MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY),
+            MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY)
     )
     layout(left, top, right, bottom)
   }
@@ -687,53 +852,92 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
     names.add(destinationTitle)
 
     mapboxNavigation?.requestRoutes(
-      RouteOptions.builder()
-        .applyDefaultNavigationOptions()
-        .applyLanguageAndVoiceUnitOptions(context)
-        .coordinatesList(coordinates)
-        .waypointIndicesList(indices)
-        .waypointNamesList(names)
-        .language(locale.language)
-        .steps(true)
-        .voiceInstructions(true)
-        .voiceUnits(distanceUnit)
-        .build(),
-      object : NavigationRouterCallback {
-        override fun onCanceled(routeOptions: RouteOptions, @RouterOrigin routerOrigin: String) {
-          // no implementation
-        }
-
-        override fun onFailure(reasons: List<RouterFailure>, routeOptions: RouteOptions) {
-          sendErrorToReact("Error finding route $reasons")
-        }
-
-        override fun onRoutesReady(
-          routes: List<NavigationRoute>,
-          @RouterOrigin routerOrigin: String
-        ) {
-          setRouteAndStartNavigation(routes)
-        }
-      }
+            RouteOptions.builder()
+                    .applyDefaultNavigationOptions()
+                    .applyLanguageAndVoiceUnitOptions(context)
+                    .coordinatesList(coordinates)
+                    .waypointIndicesList(indices)
+                    .waypointNamesList(names)
+                    .language(locale.language)
+                    .steps(true)
+                    .voiceInstructions(true)
+                    .voiceUnits(distanceUnit)
+                    .alternatives(true) // Solicitar rotas alternativas
+                    .annotationsList(
+                            listOf(DirectionsCriteria.ANNOTATION_MAXSPEED)
+                    ) // Necess√°rio para speedLimitInfo
+                    .build(),
+            object : NavigationRouterCallback {
+              override fun onCanceled(
+                      routeOptions: RouteOptions,
+                      @RouterOrigin routerOrigin: String
+              ) {
+                // no implementation
+              }
+
+              override fun onFailure(reasons: List<RouterFailure>, routeOptions: RouteOptions) {
+                sendErrorToReact("Error finding route $reasons")
+              }
+
+              override fun onRoutesReady(
+                      routes: List<NavigationRoute>,
+                      @RouterOrigin routerOrigin: String
+              ) {
+                // Armazenar rotas alternativas (at√© 3 melhores)
+                alternativeRoutes = routes.take(3)
+                currentRouteIndex = 0
+
+                // Mostrar rotas alternativas no mapa antes de iniciar navega√ß√£o
+                if (alternativeRoutes.size > 1) {
+                  showAlternativeRoutes(alternativeRoutes)
+                }
+
+                setRouteAndStartNavigation(routes)
+              }
+            }
     )
   }
 
   @SuppressLint("MissingPermission")
   private fun setRouteAndStartNavigation(routes: List<NavigationRoute>) {
-    // set routes, where the first route in the list is the primary route that
-    // will be used for active guidance
-    mapboxNavigation?.setNavigationRoutes(routes)
-
-    // show UI elements
-    binding.soundButton.visibility = View.VISIBLE
-    binding.routeOverview.visibility = View.VISIBLE
-    binding.tripProgressCard.visibility = View.VISIBLE
-
-    // move the camera to overview when new route is available
-//    navigationCamera.requestNavigationCameraToOverview()
-    mapboxNavigation?.startTripSession(withForegroundService = true)
+    if (routes.isEmpty()) {
+      Log.w("MapboxNavigationView", "setRouteAndStartNavigation: lista de rotas vazia")
+      return
+    }
+    try {
+      // set routes, where the first route in the list is the primary route that
+      // will be used for active guidance
+      mapboxNavigation?.setNavigationRoutes(routes)
+
+      // show UI elements
+      binding.soundButton.visibility = View.VISIBLE
+      binding.routeOverview.visibility = View.VISIBLE
+      binding.tripProgressCard.visibility = View.VISIBLE
+      binding.speedLimitView.visibility = View.VISIBLE
+
+      mapboxNavigation?.startTripSession(withForegroundService = true)
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao iniciar sess√£o de navega√ß√£o", e)
+      sendErrorToReact("Erro ao iniciar navega√ß√£o: ${e.message}")
+    }
   }
 
   private fun startRoute() {
+    // Create a list of coordinates that includes origin, destination
+    val coordinatesList = mutableListOf<Point>()
+    this.origin?.let { coordinatesList.add(it) }
+    this.waypoints.let { coordinatesList.addAll(waypoints) }
+    this.destination?.let { coordinatesList.add(it) }
+
+    if (coordinatesList.size < 2) {
+      Log.e(
+              "MapboxNavigationView",
+              "startRoute: origem e destino s√£o obrigat√≥rios (pontos=${coordinatesList.size})"
+      )
+      sendErrorToReact("Origem e destino s√£o obrigat√≥rios")
+      return
+    }
+
     // register event listeners
     mapboxNavigation?.registerRoutesObserver(routesObserver)
     mapboxNavigation?.registerArrivalObserver(arrivalObserver)
@@ -741,12 +945,6 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
     mapboxNavigation?.registerLocationObserver(locationObserver)
     mapboxNavigation?.registerVoiceInstructionsObserver(voiceInstructionsObserver)
 
-    // Create a list of coordinates that includes origin, destination
-    val coordinatesList = mutableListOf<Point>()
-    this.origin?.let { coordinatesList.add(it) }
-    this.waypoints.let { coordinatesList.addAll(waypoints) }
-    this.destination?.let { coordinatesList.add(it) }
-
     findRoute(coordinatesList)
   }
 
@@ -763,17 +961,17 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
 
     // hide UI elements
     binding.soundButton.visibility = View.INVISIBLE
-    binding.maneuverView.visibility = View.INVISIBLE
+    binding.maneuverCard.visibility = View.INVISIBLE
     binding.routeOverview.visibility = View.INVISIBLE
     binding.tripProgressCard.visibility = View.INVISIBLE
+    binding.speedLimitView.visibility = View.INVISIBLE
+    binding.speedCurrentOnly.visibility = View.GONE
   }
 
   private fun sendErrorToReact(error: String?) {
     val event = Arguments.createMap()
     event.putString("error", error)
-    context
-      .getJSModule(RCTEventEmitter::class.java)
-      .receiveEvent(id, "onError", event)
+    context.getJSModule(RCTEventEmitter::class.java).receiveEvent(id, "onError", event)
   }
 
   fun onDropViewInstance() {
@@ -782,10 +980,12 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
 
   fun setStartOrigin(origin: Point?) {
     this.origin = origin
+    if (destination != null) initNavigation()
   }
 
   fun setDestination(destination: Point?) {
     this.destination = destination
+    if (origin != null) initNavigation()
   }
 
   fun setDestinationTitle(title: String) {
@@ -802,7 +1002,7 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
 
   fun setDirectionUnit(unit: String) {
     this.distanceUnit = unit
-    initNavigation()
+    if (origin != null && destination != null) initNavigation()
   }
 
   fun setLocal(language: String) {
@@ -820,4 +1020,730 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
   fun setShowCancelButton(show: Boolean) {
     binding.stop.visibility = if (show) View.VISIBLE else View.INVISIBLE
   }
+
+  // Setter methods for radar functionality
+  fun setBottomPadding(padding: Double) {
+    try {
+      additionalBottomPadding = padding
+      updateCameraPadding()
+      Log.d("MapboxNavigationView", "‚¨áÔ∏è Bottom padding atualizado para: $padding")
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao definir bottom padding", e)
+    }
+  }
+
+  fun setRadars(radars: List<RadarPoint>) {
+    try {
+      this.radars = radars
+      Log.d("MapboxNavigationView", "üìç ${radars.size} radares definidos")
+
+      // Filtrar radares se houver rota ativa
+      if (currentRoute != null) {
+        filterRadarsNearRoute()
+      } else {
+        filteredRadars = radars
+      }
+
+      updateRadarAnnotations()
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao definir radares", e)
+    }
+  }
+
+  fun setNearbyRadarIds(radarIds: Set<String>) {
+    try {
+      this.nearbyRadarIds = radarIds
+      Log.d("MapboxNavigationView", "üì° ${radarIds.size} radares pr√≥ximos definidos")
+      updateRadarAnimations()
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao definir radares pr√≥ximos", e)
+    }
+  }
+
+  fun isValidForOperations(): Boolean {
+    return !isDestroyed && binding.mapView != null
+  }
+
+  // Utility functions
+  private fun getCurrentStyle(): com.mapbox.maps.Style? {
+    return try {
+      binding.mapView.mapboxMap.style
+    } catch (e: Exception) {
+      null
+    }
+  }
+
+  private fun safeEmitEvent(eventName: String, event: com.facebook.react.bridge.WritableMap) {
+    try {
+      context.getJSModule(com.facebook.react.uimanager.events.RCTEventEmitter::class.java)
+              .receiveEvent(id, eventName, event)
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao emitir evento $eventName", e)
+    }
+  }
+
+  private fun updateCameraPadding() {
+    try {
+      val style = getCurrentStyle() ?: return
+
+      // Atualizar padding da c√¢mera baseado no additionalBottomPadding
+      val currentPadding = viewportDataSource.followingPadding
+      val newBottomPadding = currentPadding.bottom + additionalBottomPadding
+
+      val newPadding =
+              EdgeInsets(
+                      currentPadding.top,
+                      currentPadding.left,
+                      newBottomPadding,
+                      currentPadding.right
+              )
+
+      viewportDataSource.followingPadding = newPadding
+      viewportDataSource.evaluate()
+
+      Log.d("MapboxNavigationView", "‚úÖ Camera padding atualizado: bottom=$newBottomPadding")
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao atualizar camera padding", e)
+    }
+  }
+
+  private fun updateRadarAnnotations() {
+    updateRadarsOnMap()
+  }
+
+  private fun updateRadarAnimations() {
+    updateNearbyRadarsInSource()
+  }
+
+  private fun loadRadarImagesWithRetry(style: com.mapbox.maps.Style) {
+    loadRadarImages(style)
+  }
+
+  private fun loadRadarImages(style: com.mapbox.maps.Style) {
+    try {
+      val imageNames =
+              listOf(
+                      "placa0",
+                      "placa10",
+                      "placa20",
+                      "placa30",
+                      "placa40",
+                      "placa50",
+                      "placa60",
+                      "placa70",
+                      "placa80",
+                      "placa90",
+                      "placa100",
+                      "placa110",
+                      "placa120",
+                      "placa130",
+                      "placa140",
+                      "placa150",
+                      "placa160",
+                      "placa"
+              )
+
+      imageNames.forEach { imageName ->
+        try {
+          val resourceName = "assets_images_$imageName"
+          val resourceId =
+                  context.resources.getIdentifier(resourceName, "drawable", context.packageName)
+
+          if (resourceId == 0) {
+            Log.w("MapboxNavigationView", "‚ö†Ô∏è Recurso n√£o encontrado: $resourceName")
+            return@forEach
+          }
+
+          val bitmap = BitmapFactory.decodeResource(context.resources, resourceId)
+          if (bitmap == null) {
+            Log.w("MapboxNavigationView", "‚ö†Ô∏è Bitmap null para $resourceName")
+            return@forEach
+          }
+
+          val imageExists =
+                  try {
+                    style.getStyleImage(imageName) != null
+                  } catch (e: Exception) {
+                    false
+                  }
+
+          if (!imageExists) {
+            style.addImage(imageName, bitmap)
+            Log.d("MapboxNavigationView", "‚úÖ Imagem $imageName carregada")
+          }
+        } catch (e: Exception) {
+          Log.e("MapboxNavigationView", "‚ùå Erro ao carregar imagem $imageName", e)
+        }
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "‚ùå Erro geral ao carregar imagens", e)
+    }
+  }
+
+  private fun registerImageMissingListener(style: com.mapbox.maps.Style) {
+    if (imageMissingListenerRegistered) {
+      return
+    }
+
+    try {
+      binding.mapView.mapboxMap.subscribeStyleImageMissing { eventData ->
+        val missingId = eventData.imageId
+        val currentStyle = binding.mapView.mapboxMap.style ?: return@subscribeStyleImageMissing
+
+        try {
+          val resourceName = "assets_images_$missingId"
+          val resourceId =
+                  context.resources.getIdentifier(resourceName, "drawable", context.packageName)
+          if (resourceId != 0) {
+            val bitmap = BitmapFactory.decodeResource(context.resources, resourceId)
+            if (bitmap != null) {
+              val imageExists =
+                      try {
+                        currentStyle.getStyleImage(missingId) != null
+                      } catch (e: Exception) {
+                        false
+                      }
+
+              if (!imageExists) {
+                currentStyle.addImage(missingId, bitmap)
+                Log.d("MapboxNavigationView", "‚úÖ Imagem faltante $missingId carregada via listener")
+              }
+            }
+          }
+        } catch (e: Exception) {
+          Log.e("MapboxNavigationView", "Erro ao processar imagem faltante $missingId", e)
+        }
+      }
+
+      imageMissingListenerRegistered = true
+      Log.d("MapboxNavigationView", "‚úÖ Listener de imagens faltantes registrado")
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao registrar listener de imagens faltantes", e)
+    }
+  }
+
+  /** Filtra radares pr√≥ximos √† rota atual Usa dist√¢ncia perpendicular m√°xima de 100 metros */
+  private fun filterRadarsNearRoute() {
+    if (currentRoute == null || radars.isEmpty()) {
+      filteredRadars = radars
+      return
+    }
+
+    try {
+      // Extrair coordenadas da rota usando directionsRoute
+      val directionsRoute = currentRoute?.directionsRoute
+      if (directionsRoute == null) {
+        Log.w("MapboxNavigationView", "‚ö†Ô∏è directionsRoute √© null, mostrando todos os radares")
+        filteredRadars = radars
+        return
+      }
+
+      // Obter geometria da rota
+      val routeGeometry = directionsRoute.geometry()
+      if (routeGeometry == null) {
+        Log.w("MapboxNavigationView", "‚ö†Ô∏è routeGeometry √© null, mostrando todos os radares")
+        filteredRadars = radars
+        return
+      }
+
+      // Converter geometria para LineString usando toString() e fromJson()
+      // A geometria do DirectionsRoute pode ser convertida para JSON string
+      try {
+        val geoJsonString = routeGeometry.toString()
+        val lineString = LineString.fromJson(geoJsonString)
+        if (lineString == null) {
+          Log.w(
+                  "MapboxNavigationView",
+                  "‚ö†Ô∏è N√£o foi poss√≠vel converter routeGeometry para LineString"
+          )
+          filteredRadars = radars
+          return
+        }
+
+        val routeCoordinates = lineString.coordinates()
+
+        if (routeCoordinates.isEmpty()) {
+          Log.w(
+                  "MapboxNavigationView",
+                  "‚ö†Ô∏è routeCoordinates est√° vazio, mostrando todos os radares"
+          )
+          filteredRadars = radars
+          return
+        }
+
+        // Converter coordenadas para lista de Points
+        val routePoints =
+                routeCoordinates.map { coord: Point ->
+                  Point.fromLngLat(coord.longitude(), coord.latitude())
+                }
+
+        // Filtrar radares pr√≥ximos √† rota (dist√¢ncia perpendicular < 100m)
+        val maxDistanceMeters = 100.0
+        filteredRadars =
+                radars.filter { radar ->
+                  val radarPoint = Point.fromLngLat(radar.longitude, radar.latitude)
+                  val minDistance = calculateMinDistanceToRoute(radarPoint, routePoints)
+                  minDistance <= maxDistanceMeters
+                }
+
+        Log.d(
+                "MapboxNavigationView",
+                "üîç Filtrados ${filteredRadars.size} de ${radars.size} radares pr√≥ximos √† rota"
+        )
+
+        // Atualizar radares no mapa ap√≥s filtrar
+        updateRadarsOnMap()
+      } catch (e: Exception) {
+        Log.e("MapboxNavigationView", "Erro ao extrair coordenadas da rota", e)
+        filteredRadars = radars
+        updateRadarsOnMap()
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao filtrar radares pr√≥ximos √† rota", e)
+      filteredRadars = radars // Fallback: mostrar todos os radares
+      updateRadarsOnMap()
+    }
+  }
+
+  /** Calcula a dist√¢ncia m√≠nima perpendicular de um ponto at√© a rota Retorna dist√¢ncia em metros */
+  private fun calculateMinDistanceToRoute(point: Point, routePoints: List<Point>): Double {
+    if (routePoints.size < 2) {
+      return Double.MAX_VALUE
+    }
+
+    var minDistance = Double.MAX_VALUE
+
+    // Verificar dist√¢ncia perpendicular para cada segmento da rota
+    for (i in 0 until routePoints.size - 1) {
+      val segmentStart = routePoints[i]
+      val segmentEnd = routePoints[i + 1]
+
+      val distance = calculatePerpendicularDistance(point, segmentStart, segmentEnd)
+      if (distance < minDistance) {
+        minDistance = distance
+      }
+    }
+
+    return minDistance
+  }
+
+  /**
+   * Calcula dist√¢ncia perpendicular de um ponto at√© um segmento de linha Usa f√≥rmula de dist√¢ncia
+   * ponto-linha Retorna dist√¢ncia em metros usando f√≥rmula de Haversine
+   */
+  private fun calculatePerpendicularDistance(
+          point: Point,
+          lineStart: Point,
+          lineEnd: Point
+  ): Double {
+    // Calcular dist√¢ncia usando f√≥rmula de Haversine
+    val R = 6371000.0 // Raio da Terra em metros
+
+    // Converter para radianos
+    val lat1 = Math.toRadians(point.latitude())
+    val lon1 = Math.toRadians(point.longitude())
+    val lat2 = Math.toRadians(lineStart.latitude())
+    val lon2 = Math.toRadians(lineStart.longitude())
+    val lat3 = Math.toRadians(lineEnd.latitude())
+    val lon3 = Math.toRadians(lineEnd.longitude())
+
+    // Calcular vetor do segmento
+    val dLat = lat3 - lat2
+    val dLon = lon3 - lon2
+
+    // Calcular produto escalar para encontrar ponto mais pr√≥ximo no segmento
+    val t =
+            if (dLat * dLat + dLon * dLon > 0) {
+              val dot = (lat1 - lat2) * dLat + (lon1 - lon2) * dLon
+              val lenSq = dLat * dLat + dLon * dLon
+              (dot / lenSq).coerceIn(0.0, 1.0)
+            } else {
+              0.0
+            }
+
+    // Ponto mais pr√≥ximo no segmento
+    val closestLat = lat2 + t * dLat
+    val closestLon = lon2 + t * dLon
+
+    // Calcular dist√¢ncia Haversine entre ponto e ponto mais pr√≥ximo
+    val dLat2 = lat1 - closestLat
+    val dLon2 = lon1 - closestLon
+
+    val a =
+            Math.sin(dLat2 / 2) * Math.sin(dLat2 / 2) +
+                    Math.cos(lat1) *
+                            Math.cos(closestLat) *
+                            Math.sin(dLon2 / 2) *
+                            Math.sin(dLon2 / 2)
+    val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
+
+    return R * c
+  }
+
+  private fun updateRadarsOnMap() {
+    val style = getCurrentStyle() ?: return
+
+    // Usar radares filtrados se houver rota, sen√£o usar todos
+    val radarsToDisplay = if (currentRoute != null) filteredRadars else radars
+
+    if (radarsToDisplay.isEmpty()) {
+      return
+    }
+
+    try {
+      val features =
+              radarsToDisplay.map { radar: RadarPoint ->
+                val speedLimit = radar.speedLimit ?: 0.0
+                val speeds =
+                        listOf(20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160)
+                val closestSpeed =
+                        if (speedLimit > 0) {
+                          speeds.minByOrNull { kotlin.math.abs(it - speedLimit) } ?: 0
+                        } else {
+                          0
+                        }
+                val iconImage = if (closestSpeed > 0) "placa$closestSpeed" else "placa0"
+                val isNearby = nearbyRadarIds.contains(radar.id)
+
+                Feature.fromGeometry(
+                        Point.fromLngLat(radar.longitude, radar.latitude),
+                        JsonObject().apply {
+                          addProperty("id", radar.id)
+                          addProperty("speedLimit", radar.speedLimit?.toString() ?: "")
+                          addProperty("iconImage", iconImage)
+                          addProperty("isNearby", java.lang.Boolean.valueOf(isNearby))
+                        }
+                )
+              }
+
+      val featureCollection = FeatureCollection.fromFeatures(features.toList())
+      val geoJsonString = featureCollection.toJson()
+      val sourceJson =
+              """
+        {
+          "type": "geojson",
+          "data": $geoJsonString
+        }
+      """.trimIndent()
+
+      val sourceValueResult = com.mapbox.bindgen.Value.fromJson(sourceJson)
+      when (val value = sourceValueResult.value) {
+        null -> {
+          Log.e("MapboxNavigationView", "Erro ao criar Value do JSON: ${sourceValueResult.error}")
+        }
+        else -> {
+          if (style.styleSourceExists("radars-source")) {
+            style.removeStyleSource("radars-source")
+          }
+          style.addStyleSource("radars-source", value)
+          Log.d(
+                  "MapboxNavigationView",
+                  "‚úÖ GeoJSON source atualizado: ${radarsToDisplay.size} radares (${if (currentRoute != null) "filtrados" else "todos"})"
+          )
+
+          // Garantir que as imagens est√£o carregadas antes de criar o layer
+          loadRadarImages(style)
+
+          // Remover layer existente se houver
+          if (style.styleLayerExists("radars-layer-symbol")) {
+            style.removeStyleLayer("radars-layer-symbol")
+          }
+
+          // Criar SymbolLayer para exibir as imagens dos radares
+          try {
+            val layerJson =
+                    """
+              {
+                "id": "radars-layer-symbol",
+                "type": "symbol",
+                "source": "radars-source",
+                "layout": {
+                  "icon-image": ["get", "iconImage"],
+                  "icon-size": 0.2,
+                  "icon-allow-overlap": true,
+                  "icon-ignore-placement": true,
+                  "icon-anchor": "bottom",
+                  "icon-pitch-alignment": "viewport"
+                },
+                "paint": {}
+              }
+            """.trimIndent()
+
+            val layerValueResult = com.mapbox.bindgen.Value.fromJson(layerJson)
+            when (val layerValue = layerValueResult.value) {
+              null -> {
+                Log.e(
+                        "MapboxNavigationView",
+                        "‚ùå Erro ao criar SymbolLayer: ${layerValueResult.error}"
+                )
+              }
+              else -> {
+                style.addStyleLayer(layerValue, null)
+                Log.d(
+                        "MapboxNavigationView",
+                        "‚úÖ SymbolLayer adicionado com sucesso para ${radarsToDisplay.size} radares"
+                )
+              }
+            }
+          } catch (e: Exception) {
+            Log.e("MapboxNavigationView", "‚ùå Erro ao adicionar SymbolLayer", e)
+          }
+        }
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao atualizar radares no mapa", e)
+    }
+  }
+
+  private fun updateNearbyRadarsInSource() {
+    val style = getCurrentStyle() ?: return
+    if (!style.styleSourceExists("radars-source")) {
+      return
+    }
+
+    try {
+      // Usar radares filtrados se houver rota
+      val radarsToDisplay = if (currentRoute != null) filteredRadars else radars
+
+      val features =
+              radarsToDisplay.map { radar: RadarPoint ->
+                val speedLimit = radar.speedLimit ?: 0.0
+                val speeds =
+                        listOf(10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160)
+                val closestSpeed =
+                        if (speedLimit > 0) {
+                          speeds.minByOrNull { kotlin.math.abs(it - speedLimit) } ?: 0
+                        } else {
+                          0
+                        }
+                val iconImage = if (closestSpeed > 0) "placa$closestSpeed" else "placa0"
+                val isNearby = nearbyRadarIds.contains(radar.id)
+
+                Feature.fromGeometry(
+                        Point.fromLngLat(radar.longitude, radar.latitude),
+                        JsonObject().apply {
+                          addProperty("id", radar.id)
+                          addProperty("speedLimit", radar.speedLimit?.toString() ?: "")
+                          addProperty("iconImage", iconImage)
+                          addProperty("isNearby", java.lang.Boolean.valueOf(isNearby))
+                        }
+                )
+              }
+
+      val featureCollection = FeatureCollection.fromFeatures(features.toList())
+      val geoJsonString = featureCollection.toJson()
+      val sourceJson =
+              """
+        {
+          "type": "geojson",
+          "data": $geoJsonString
+        }
+      """.trimIndent()
+
+      val sourceValueResult = com.mapbox.bindgen.Value.fromJson(sourceJson)
+      when (val value = sourceValueResult.value) {
+        null -> {
+          Log.e("MapboxNavigationView", "Erro ao atualizar source: ${sourceValueResult.error}")
+        }
+        else -> {
+          style.removeStyleSource("radars-source")
+          style.addStyleSource("radars-source", value)
+          Log.d(
+                  "MapboxNavigationView",
+                  "‚úÖ GeoJSON source atualizado com isNearby: ${nearbyRadarIds.size} radares pr√≥ximos"
+          )
+        }
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao atualizar nearbyRadarsInSource", e)
+    }
+  }
+
+  /** Mostra rotas alternativas no mapa com callouts e informa√ß√µes */
+  private fun showAlternativeRoutes(routes: List<NavigationRoute>) {
+    val style = getCurrentStyle() ?: return
+
+    try {
+      // Criar features para cada rota alternativa com informa√ß√µes
+      val alternativeRouteFeatures = mutableListOf<Feature>()
+
+      routes.forEachIndexed { index, route ->
+        val directionsRoute = route.directionsRoute
+        val routeGeometry = directionsRoute.geometry() ?: return@forEachIndexed
+
+        // Converter geometria para LineString
+        val routeGeoJsonString = routeGeometry.toString()
+        val lineString = LineString.fromJson(routeGeoJsonString)
+        if (lineString == null) return@forEachIndexed
+
+        val routeCoordinates = lineString.coordinates()
+        if (routeCoordinates.isEmpty()) return@forEachIndexed
+
+        // Obter informa√ß√µes da rota
+        val totalDistance = directionsRoute.distance() ?: 0.0
+        val totalDuration = directionsRoute.duration() ?: 0.0
+
+        // Criar callout no ponto m√©dio da rota
+        val midPointIndex = routeCoordinates.size / 2
+        val midCoord: Point = routeCoordinates[midPointIndex]
+        val midPoint = Point.fromLngLat(midCoord.longitude(), midCoord.latitude())
+
+        // Formatar informa√ß√µes
+        val distanceKm = totalDistance / 1000.0
+        val durationMinutes = (totalDuration / 60).toInt()
+
+        val distanceText =
+                if (distanceKm < 1.0) {
+                  "${totalDistance.toInt()}m"
+                } else {
+                  String.format("%.1f", distanceKm) + "km"
+                }
+
+        val timeText =
+                when {
+                  durationMinutes < 60 -> "${durationMinutes}min"
+                  else -> "${durationMinutes / 60}h ${durationMinutes % 60}min"
+                }
+
+        val routeLabel =
+                when (index) {
+                  0 -> "Rota 1 (Recomendada)"
+                  1 -> "Rota 2"
+                  2 -> "Rota 3"
+                  else -> "Rota ${index + 1}"
+                }
+
+        val feature =
+                Feature.fromGeometry(
+                        midPoint,
+                        JsonObject().apply {
+                          addProperty("routeIndex", index.toString())
+                          addProperty("distance", distanceText)
+                          addProperty("time", timeText)
+                          addProperty("label", routeLabel)
+                          addProperty("distanceKm", java.lang.Double.valueOf(distanceKm))
+                          addProperty("durationMinutes", java.lang.Integer.valueOf(durationMinutes))
+                        }
+                )
+        alternativeRouteFeatures.add(feature)
+      }
+
+      if (alternativeRouteFeatures.isEmpty()) {
+        return
+      }
+
+      val featureCollection = FeatureCollection.fromFeatures(alternativeRouteFeatures.toList())
+      val geoJsonString = featureCollection.toJson()
+      val sourceJson =
+              """
+        {
+          "type": "geojson",
+          "data": $geoJsonString
+        }
+      """.trimIndent()
+
+      val sourceValueResult = com.mapbox.bindgen.Value.fromJson(sourceJson)
+      when (val value = sourceValueResult.value) {
+        null -> {
+          Log.e(
+                  "MapboxNavigationView",
+                  "Erro ao criar source de rotas alternativas: ${sourceValueResult.error}"
+          )
+        }
+        else -> {
+          // Remover source e layer existentes
+          if (style.styleSourceExists("alternative-routes-callouts-source")) {
+            style.removeStyleSource("alternative-routes-callouts-source")
+          }
+          if (style.styleLayerExists("alternative-routes-callouts-layer")) {
+            style.removeStyleLayer("alternative-routes-callouts-layer")
+          }
+
+          // Adicionar source
+          style.addStyleSource("alternative-routes-callouts-source", value)
+
+          // Criar SymbolLayer para callouts das rotas alternativas
+          val layerJson =
+                  """
+            {
+              "id": "alternative-routes-callouts-layer",
+              "type": "symbol",
+              "source": "alternative-routes-callouts-source",
+              "layout": {
+                "text-field": ["concat", ["get", "label"], "\n", ["get", "distance"], " ‚Ä¢ ", ["get", "time"]],
+                "text-size": 12,
+                "text-anchor": "center",
+                "text-offset": [0, 0],
+                "text-allow-overlap": true,
+                "text-ignore-placement": true
+              },
+              "paint": {
+                "text-color": "#60A5FA",
+                "text-halo-color": "#1F2937",
+                "text-halo-width": 2
+              }
+            }
+          """.trimIndent()
+
+          val layerValueResult = com.mapbox.bindgen.Value.fromJson(layerJson)
+          when (val layerValue = layerValueResult.value) {
+            null -> {
+              Log.e(
+                      "MapboxNavigationView",
+                      "Erro ao criar layer de rotas alternativas: ${layerValueResult.error}"
+              )
+            }
+            else -> {
+              style.addStyleLayer(layerValue, null)
+              Log.d(
+                      "MapboxNavigationView",
+                      "‚úÖ Rotas alternativas exibidas: ${alternativeRouteFeatures.size} rotas"
+              )
+            }
+          }
+        }
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao mostrar rotas alternativas", e)
+    }
+  }
+
+  /**
+   * Promove uma rota alternativa para ser a rota principal.
+   * A sele√ß√£o √© feita tocando no callout da rota alternativa no mapa.
+   */
+  private fun selectAlternativeRoute(selectedIndex: Int, source: String) {
+    if (selectedIndex < 0 || selectedIndex >= alternativeRoutes.size) {
+      return
+    }
+
+    // J√° √© a rota principal
+    if (selectedIndex == 0) {
+      return
+    }
+
+    try {
+      val selected = alternativeRoutes[selectedIndex]
+      val reordered = mutableListOf<NavigationRoute>()
+      reordered.add(selected)
+      alternativeRoutes.forEachIndexed { index, route ->
+        if (index != selectedIndex) {
+          reordered.add(route)
+        }
+      }
+      alternativeRoutes = reordered.take(3)
+      currentRouteIndex = 0
+
+      mapboxNavigation?.setNavigationRoutes(alternativeRoutes)
+      Log.d("MapboxNavigationView", "‚úÖ Rota alternativa selecionada: index=$selectedIndex (source=$source)")
+
+      // Notificar React (se quiser mostrar UI / estado)
+      val ev = Arguments.createMap()
+      ev.putInt("routeIndex", selectedIndex)
+      ev.putString("source", source)
+      safeEmitEvent("onRouteAlternativeSelected", ev)
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao selecionar rota alternativa", e)
+    }
+  }
 }
\ No newline at end of file
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationViewManager.kt b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationViewManager.kt
index 03fad26..36800ae 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationViewManager.kt
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationViewManager.kt
@@ -1,16 +1,84 @@
 package com.mapboxnavigation
 
-import com.facebook.react.module.annotations.ReactModule
 import com.facebook.react.bridge.ReactApplicationContext
 import com.facebook.react.bridge.ReadableArray
 import com.facebook.react.common.MapBuilder
+import com.facebook.react.module.annotations.ReactModule
 import com.facebook.react.uimanager.ThemedReactContext
 import com.facebook.react.uimanager.annotations.ReactProp
-import com.mapbox.api.directions.v5.models.DirectionsWaypoint
 import com.mapbox.geojson.Point
 
-@ReactModule(name = MapboxNavigationViewManager.NAME)
-class MapboxNavigationViewManager(private var reactContext: ReactApplicationContext): MapboxNavigationViewManagerSpec<MapboxNavigationView>() {
+  /**
+   * Validate that the view is in a valid state for updates
+   * Prevents operations on destroyed or invalid components
+   */
+  private fun isValidForUpdates(view: MapboxNavigationView?): Boolean {
+    return view != null && view.isValidForOperations()
+  }
+  
+  /**
+   * Safe conversion of ReadableArray to Point with validation
+   */
+  private fun safeToPoint(array: ReadableArray?): Point? {
+    return try {
+      if (array == null || array.size() < 2) return null
+      Point.fromLngLat(array.getDouble(0), array.getDouble(1))
+    } catch (e: Exception) {
+      null
+    }
+  }
+  
+  /**
+   * Safe conversion of ReadableArray to RadarPoint list with validation
+   */
+  private fun safeToRadarPoints(array: ReadableArray?): List<RadarPoint> {
+    if (array == null) return emptyList()
+    
+    return try {
+      val radars = mutableListOf<RadarPoint>()
+      for (i in 0 until array.size()) {
+        val map = array.getMap(i) ?: continue
+        
+        // Validate required fields
+        if (!map.hasKey("latitude") || !map.hasKey("longitude")) continue
+        
+        val latitude = try { map.getDouble("latitude") } catch (e: Exception) { continue }
+        val longitude = try { map.getDouble("longitude") } catch (e: Exception) { continue }
+        val id = map.getString("id") ?: "radar-$i"
+        
+        val speedLimit = if (map.hasKey("speedLimit") && !map.isNull("speedLimit")) {
+          try { map.getDouble("speedLimit") } catch (e: Exception) { null }
+        } else null
+        
+        radars.add(RadarPoint(id, latitude, longitude, speedLimit))
+      }
+      radars
+    } catch (e: Exception) {
+      emptyList()
+    }
+  }
+  
+  /**
+   * Safe conversion of ReadableArray to String set with validation
+   */
+  private fun safeToStringSet(array: ReadableArray?): Set<String> {
+    if (array == null) return emptySet()
+    
+    return try {
+      val ids = mutableSetOf<String>()
+      for (i in 0 until array.size()) {
+        val id = array.getString(i)
+        if (id != null && id.isNotBlank()) {
+          ids.add(id)
+        }
+      }
+      ids
+    } catch (e: Exception) {
+      emptySet()
+    }
+  }
+class MapboxNavigationViewManager(private var reactContext: ReactApplicationContext) :
+        MapboxNavigationViewManagerSpec<MapboxNavigationView>() {
   override fun getName(): String {
     return NAME
   }
@@ -24,91 +92,128 @@ class MapboxNavigationViewManager(private var reactContext: ReactApplicationCont
     super.onDropViewInstance(view)
   }
 
-  override fun getExportedCustomDirectEventTypeConstants(): MutableMap<String, Map<String, String>> {
-    return MapBuilder.of(
-      "onLocationChange", MapBuilder.of("registrationName", "onLocationChange"),
-      "onError", MapBuilder.of("registrationName", "onError"),
-      "onCancelNavigation", MapBuilder.of("registrationName", "onCancelNavigation"),
-      "onArrive", MapBuilder.of("registrationName", "onArrive"),
-      "onRouteProgressChange", MapBuilder.of("registrationName", "onRouteProgressChange"),
-    )
+  override fun getExportedCustomDirectEventTypeConstants():
+          MutableMap<String, Map<String, String>> {
+    val builder = MapBuilder.builder<String, Map<String, String>>()
+    builder.put("onLocationChange", MapBuilder.of("registrationName", "onLocationChange"))
+    builder.put("onError", MapBuilder.of("registrationName", "onError"))
+    builder.put("onCancelNavigation", MapBuilder.of("registrationName", "onCancelNavigation"))
+    builder.put("onArrive", MapBuilder.of("registrationName", "onArrive"))
+    builder.put("onRouteProgressChange", MapBuilder.of("registrationName", "onRouteProgressChange"))
+    builder.put("onRouteAlternativeSelected", MapBuilder.of("registrationName", "onRouteAlternativeSelected"))
+    builder.put("onRouteAlternativesAvailable", MapBuilder.of("registrationName", "onRouteAlternativesAvailable"))
+    builder.put("onRouteSelected", MapBuilder.of("registrationName", "onRouteSelected"))
+    return builder.build()
   }
 
   @ReactProp(name = "startOrigin")
   override fun setStartOrigin(view: MapboxNavigationView?, value: ReadableArray?) {
-    if (value == null) {
-      view?.setStartOrigin(null)
-      return
-    }
-    view?.setStartOrigin(Point.fromLngLat(value.getDouble(0), value.getDouble(1)))
+    if (!isValidForUpdates(view)) return
+    
+    val point = safeToPoint(value)
+    view?.setStartOrigin(point)
   }
 
   @ReactProp(name = "destination")
   override fun setDestination(view: MapboxNavigationView?, value: ReadableArray?) {
-    if (value == null) {
-      view?.setDestination(null)
-      return
-    }
-    view?.setDestination(Point.fromLngLat(value.getDouble(0), value.getDouble(1)))
+    if (!isValidForUpdates(view)) return
+    
+    val point = safeToPoint(value)
+    view?.setDestination(point)
   }
 
   @ReactProp(name = "destinationTitle")
   override fun setDestinationTitle(view: MapboxNavigationView?, value: String?) {
-    if (value != null) {
-      view?.setDestinationTitle(value)
-    }
+    if (!isValidForUpdates(view) || value.isNullOrBlank()) return
+    view?.setDestinationTitle(value)
   }
 
   @ReactProp(name = "distanceUnit")
   override fun setDirectionUnit(view: MapboxNavigationView?, value: String?) {
-    if (value != null)  {
-      view?.setDirectionUnit(value)
-    }
+    if (!isValidForUpdates(view) || value.isNullOrBlank()) return
+    view?.setDirectionUnit(value)
   }
 
   @ReactProp(name = "waypoints")
   override fun setWaypoints(view: MapboxNavigationView?, value: ReadableArray?) {
+    if (!isValidForUpdates(view)) return
+    
     if (value == null) {
       view?.setWaypoints(listOf())
+      view?.setWaypointLegs(listOf())
       return
     }
-    val legs = mutableListOf<WaypointLegs>()
-    val waypoints: List<Point> = value.toArrayList().mapIndexedNotNull { index, item ->
-      val map = item as? Map<*, *>
-      val latitude = map?.get("latitude") as? Double
-      val longitude = map?.get("longitude") as? Double
-      val name = map?.get("name") as? String
-      val separatesLegs = map?.get("separatesLegs") as? Boolean
-      if (separatesLegs != false) {
-        legs.add(WaypointLegs(index = index + 1, name = name ?: "waypoint-$index"))
-      }
-      if (latitude != null && longitude != null) {
-        Point.fromLngLat(longitude, latitude)
-      } else {
-        null
-      }
+    
+    try {
+      val legs = mutableListOf<WaypointLegs>()
+      val waypoints: List<Point> =
+              value.toArrayList().mapIndexedNotNull { index, item ->
+                val map = item as? Map<*, *>
+                val latitude = map?.get("latitude") as? Double
+                val longitude = map?.get("longitude") as? Double
+                val name = map?.get("name") as? String
+                val separatesLegs = map?.get("separatesLegs") as? Boolean
+                if (separatesLegs != false) {
+                  legs.add(WaypointLegs(index = index + 1, name = name ?: "waypoint-$index"))
+                }
+                if (latitude != null && longitude != null) {
+                  Point.fromLngLat(longitude, latitude)
+                } else {
+                  null
+                }
+              }
+      view?.setWaypointLegs(legs)
+      view?.setWaypoints(waypoints)
+    } catch (e: Exception) {
+      // Graceful fallback
+      view?.setWaypoints(listOf())
+      view?.setWaypointLegs(listOf())
     }
-    view?.setWaypointLegs(legs)
-    view?.setWaypoints(waypoints)
   }
 
   @ReactProp(name = "language")
   override fun setLocal(view: MapboxNavigationView?, language: String?) {
-    if (language !== null) {
-      view?.setLocal(language)
-    }
+    if (!isValidForUpdates(view) || language.isNullOrBlank()) return
+    view?.setLocal(language)
   }
 
   @ReactProp(name = "showCancelButton")
   override fun setShowCancelButton(view: MapboxNavigationView?, value: Boolean) {
+    if (!isValidForUpdates(view)) return
     view?.setShowCancelButton(value)
   }
 
   @ReactProp(name = "mute")
   override fun setMute(view: MapboxNavigationView?, value: Boolean) {
+    if (!isValidForUpdates(view)) return
     view?.setMute(value)
   }
 
+  @ReactProp(name = "radars")
+  fun setRadars(view: MapboxNavigationView?, value: ReadableArray?) {
+    if (!isValidForUpdates(view)) return
+    
+    val radars = safeToRadarPoints(value)
+    view?.setRadars(radars)
+  }
+
+  @ReactProp(name = "nearbyRadarIds")
+  fun setNearbyRadarIds(view: MapboxNavigationView?, value: ReadableArray?) {
+    if (!isValidForUpdates(view)) return
+    
+    val ids = safeToStringSet(value)
+    view?.setNearbyRadarIds(ids)
+  }
+
+  @ReactProp(name = "bottomPadding", defaultDouble = 0.0)
+  fun setBottomPadding(view: MapboxNavigationView?, value: Double) {
+    if (!isValidForUpdates(view)) return
+    
+    // Validate padding value
+    val validPadding = if (value.isNaN() || value.isInfinite()) 0.0 else kotlin.math.max(0.0, value)
+    view?.setBottomPadding(validPadding)
+  }
+
   companion object {
     const val NAME = "MapboxNavigationView"
   }
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/RadarPoint.kt b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/RadarPoint.kt
new file mode 100644
index 0000000..e6b25bf
--- /dev/null
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/RadarPoint.kt
@@ -0,0 +1,8 @@
+package com.mapboxnavigation
+
+data class RadarPoint(
+  val id: String,
+  val latitude: Double,
+  val longitude: Double,
+  val speedLimit: Double?
+)
\ No newline at end of file
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/navigation_view.xml b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/navigation_view.xml
index c00affd..d3fde26 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/navigation_view.xml
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/navigation_view.xml
@@ -2,53 +2,156 @@
 <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
   xmlns:app="http://schemas.android.com/apk/res-auto"
   android:layout_width="match_parent"
-  android:layout_height="match_parent">
+  android:layout_height="match_parent"
+  android:background="#E5E7EB">
 
   <com.mapbox.maps.MapView
     android:id="@+id/mapView"
     android:layout_width="0dp"
     android:layout_height="0dp"
+    android:background="#E5E7EB"
     app:layout_constraintBottom_toBottomOf="parent"
     app:layout_constraintEnd_toEndOf="parent"
     app:layout_constraintStart_toStartOf="parent"
     app:layout_constraintTop_toTopOf="parent" />
 
+  <!-- Trip Progress: barra inferior, fundo branco, duas linhas (tempo + dist√¢ncia ‚Äî ETA), largura total com padding -->
   <androidx.cardview.widget.CardView
     android:id="@+id/tripProgressCard"
     android:layout_width="0dp"
     android:layout_height="wrap_content"
+    android:layout_marginStart="16dp"
+    android:layout_marginEnd="16dp"
+    android:layout_marginBottom="16dp"
     android:visibility="invisible"
+    app:cardBackgroundColor="#FFFFFF"
+    app:cardCornerRadius="12dp"
     app:cardElevation="8dp"
-    app:cardUseCompatPadding="false"
+    app:cardUseCompatPadding="true"
     app:layout_constraintBottom_toBottomOf="parent"
     app:layout_constraintEnd_toEndOf="parent"
     app:layout_constraintStart_toStartOf="parent">
 
-    <com.mapbox.navigation.ui.components.tripprogress.view.MapboxTripProgressView
-      android:id="@+id/tripProgressView"
+    <LinearLayout
       android:layout_width="match_parent"
-      android:layout_margin="8dp"
-      android:layout_height="wrap_content" />
-
-    <ImageView
-      android:id="@+id/stop"
-      android:layout_width="41dp"
-      android:layout_height="41dp"
-      android:layout_gravity="end|center_vertical"
-      android:layout_marginEnd="12dp"
-      app:srcCompat="@android:drawable/ic_delete"
-      android:contentDescription="@string/delete_icon"/>
+      android:layout_height="wrap_content"
+      android:orientation="horizontal"
+      android:paddingStart="20dp"
+      android:paddingEnd="12dp"
+      android:paddingTop="16dp"
+      android:paddingBottom="16dp"
+      android:gravity="center_vertical"
+      android:background="#FFFFFF">
+
+      <LinearLayout
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:layout_weight="1"
+        android:orientation="vertical"
+        android:gravity="center_vertical">
+
+        <LinearLayout
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:orientation="horizontal"
+          android:gravity="center_vertical"
+          android:baselineAligned="false">
+
+          <TextView
+            android:id="@+id/tripProgressTimeValue"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="--"
+            android:textSize="28sp"
+            android:textStyle="bold"
+            android:textColor="#1F2937"
+            android:letterSpacing="0" />
+
+          <TextView
+            android:id="@+id/tripProgressTimeUnit"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text=" min"
+            android:textSize="16sp"
+            android:textColor="#4B5563"
+            android:layout_marginStart="2dp" />
+        </LinearLayout>
+
+        <TextView
+          android:id="@+id/tripProgressDistanceEta"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_marginTop="4dp"
+          android:text="--"
+          android:textSize="14sp"
+          android:textColor="#6B7280" />
+      </LinearLayout>
+
+      <ImageView
+        android:id="@+id/stop"
+        android:layout_width="48dp"
+        android:layout_height="48dp"
+        android:layout_marginStart="8dp"
+        android:background="?attr/selectableItemBackgroundBorderless"
+        android:padding="8dp"
+        android:src="@android:drawable/ic_menu_close_clear_cancel"
+        android:contentDescription="@string/delete_icon"
+        android:tint="#374151" />
+    </LinearLayout>
   </androidx.cardview.widget.CardView>
 
-  <com.mapbox.navigation.ui.components.maneuver.view.MapboxManeuverView
-    android:id="@+id/maneuverView"
+  <!-- Speed: sempre vis√≠vel (limite da via ou velocidade atual) -->
+  <FrameLayout
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:layout_marginStart="16dp"
+    android:layout_marginBottom="8dp"
+    app:layout_constraintStart_toStartOf="parent"
+    app:layout_constraintBottom_toTopOf="@id/tripProgressCard">
+
+    <com.mapbox.navigation.ui.components.speedlimit.view.MapboxSpeedInfoView
+      android:id="@+id/speedLimitView"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:visibility="invisible" />
+
+    <TextView
+      android:id="@+id/speedCurrentOnly"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:visibility="gone"
+      android:paddingStart="12dp"
+      android:paddingEnd="12dp"
+      android:paddingTop="8dp"
+      android:paddingBottom="8dp"
+      android:background="#1F2937"
+      android:textColor="#FFFFFF"
+      android:textSize="18sp"
+      android:textStyle="bold"
+      android:text="0 km/h" />
+  </FrameLayout>
+
+  <!-- ManeuverView: apenas instru√ß√£o (Overview three), sem km e tempo -->
+  <androidx.cardview.widget.CardView
+    android:id="@+id/maneuverCard"
     android:layout_width="0dp"
     android:layout_height="wrap_content"
-    android:layout_margin="4dp"
+    android:layout_margin="12dp"
     android:visibility="invisible"
+    app:cardBackgroundColor="#1F2937"
+    app:cardCornerRadius="16dp"
+    app:cardElevation="12dp"
+    app:cardUseCompatPadding="true"
     app:layout_constraintEnd_toEndOf="parent"
     app:layout_constraintStart_toStartOf="parent"
-    app:layout_constraintTop_toTopOf="parent" />
+    app:layout_constraintTop_toTopOf="parent">
+
+    <com.mapbox.navigation.ui.components.maneuver.view.MapboxManeuverView
+      android:id="@+id/maneuverView"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:padding="16dp" />
+  </androidx.cardview.widget.CardView>
 
   <com.mapbox.navigation.ui.components.voice.view.MapboxSoundButton
     android:id="@+id/soundButton"
@@ -58,7 +161,7 @@
     android:layout_marginEnd="16dp"
     android:visibility="invisible"
     app:layout_constraintEnd_toEndOf="parent"
-    app:layout_constraintTop_toBottomOf="@id/maneuverView" />
+    app:layout_constraintTop_toBottomOf="@id/maneuverCard" />
 
   <com.mapbox.navigation.ui.components.maps.camera.view.MapboxRouteOverviewButton
     android:id="@+id/routeOverview"
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/navigation_view_new.xml b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/navigation_view_new.xml
new file mode 100644
index 0000000..36e6880
--- /dev/null
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/navigation_view_new.xml
@@ -0,0 +1,107 @@
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:app="http://schemas.android.com/apk/res-auto"
+  android:layout_width="match_parent"
+  android:layout_height="match_parent">
+
+  <com.mapbox.maps.MapView
+    android:id="@+id/mapView"
+    android:layout_width="0dp"
+    android:layout_height="0dp"
+    app:layout_constraintBottom_toBottomOf="parent"
+    app:layout_constraintEnd_toEndOf="parent"
+    app:layout_constraintStart_toStartOf="parent"
+    app:layout_constraintTop_toTopOf="parent" />
+
+  <!-- Compass ser√° habilitado programaticamente no Kotlin -->
+
+  <!-- Trip Progress moderno estilo Waze com bot√£o Fechar -->
+  <androidx.cardview.widget.CardView
+    android:id="@+id/tripProgressCard"
+    android:layout_width="0dp"
+    android:layout_height="wrap_content"
+    android:visibility="invisible"
+    app:cardBackgroundColor="#E6000000"
+    app:cardCornerRadius="16dp"
+    app:cardElevation="8dp"
+    app:cardUseCompatPadding="false"
+    app:layout_constraintBottom_toBottomOf="parent"
+    app:layout_constraintEnd_toEndOf="parent"
+    app:layout_constraintStart_toStartOf="parent"
+    android:layout_marginStart="16dp"
+    android:layout_marginEnd="16dp"
+    android:layout_marginBottom="16dp">
+
+    <LinearLayout
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:orientation="horizontal"
+      android:padding="16dp"
+      android:gravity="center_vertical"
+      android:minHeight="72dp">
+      
+      <!-- Trip Progress View -->
+      <com.mapbox.navigation.ui.components.tripprogress.view.MapboxTripProgressView
+        android:id="@+id/tripProgressView"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:layout_weight="1"
+        android:background="@android:color/transparent" />
+
+      <!-- Bot√£o Fechar (X) estilo Waze -->
+      <ImageButton
+        android:id="@+id/closeButton"
+        android:layout_width="48dp"
+        android:layout_height="48dp"
+        android:layout_marginStart="12dp"
+        android:background="?attr/selectableItemBackgroundBorderless"
+        android:padding="8dp"
+        android:scaleType="center"
+        app:srcCompat="@android:drawable/ic_menu_close_clear_cancel"
+        android:tint="#FFEB3B" />
+        
+    </LinearLayout>
+
+  </androidx.cardview.widget.CardView>
+
+  <com.mapbox.navigation.ui.components.maneuver.view.MapboxManeuverView
+    android:id="@+id/maneuverView"
+    android:layout_width="0dp"
+    android:layout_height="wrap_content"
+    android:layout_margin="4dp"
+    android:visibility="invisible"
+    app:layout_constraintEnd_toEndOf="parent"
+    app:layout_constraintStart_toStartOf="parent"
+    app:layout_constraintTop_toTopOf="parent" />
+
+  <com.mapbox.navigation.ui.components.voice.view.MapboxSoundButton
+    android:id="@+id/soundButton"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:layout_marginTop="8dp"
+    android:layout_marginEnd="16dp"
+    android:visibility="invisible"
+    app:layout_constraintEnd_toEndOf="parent"
+    app:layout_constraintTop_toBottomOf="@id/maneuverView" />
+
+  <com.mapbox.navigation.ui.components.maps.camera.view.MapboxRouteOverviewButton
+    android:id="@+id/routeOverview"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:layout_marginTop="8dp"
+    android:layout_marginEnd="16dp"
+    android:visibility="invisible"
+    app:layout_constraintEnd_toEndOf="parent"
+    app:layout_constraintTop_toBottomOf="@id/soundButton" />
+
+  <com.mapbox.navigation.ui.components.maps.camera.view.MapboxRecenterButton
+    android:id="@+id/recenter"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:visibility="invisible"
+    android:layout_marginTop="8dp"
+    android:layout_marginEnd="16dp"
+    app:layout_constraintEnd_toEndOf="parent"
+    app:layout_constraintTop_toBottomOf="@id/routeOverview" />
+
+</androidx.constraintlayout.widget.ConstraintLayout>
\ No newline at end of file
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/route_alternatives_layout.xml b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/route_alternatives_layout.xml
new file mode 100644
index 0000000..75877d1
--- /dev/null
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/route_alternatives_layout.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <!-- Container principal das rotas alternativas -->
+    <androidx.cardview.widget.CardView
+        android:id="@+id/routeAlternativesContainer"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:visibility="gone"
+        app:cardBackgroundColor="#E6000000"
+        app:cardCornerRadius="16dp"
+        app:cardElevation="8dp"
+        app:cardUseCompatPadding="false"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        android:layout_marginStart="16dp"
+        android:layout_marginEnd="16dp"
+        android:layout_marginBottom="100dp">
+
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical"
+            android:padding="16dp">
+
+            <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:text="Rotas Alternativas"
+                android:textColor="#FFEB3B"
+                android:textSize="18sp"
+                android:textStyle="bold"
+                android:gravity="center"
+                android:layout_marginBottom="12dp" />
+
+            <!-- Lista de rotas alternativas -->
+            <LinearLayout
+                android:id="@+id/routeAlternativesList"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:orientation="vertical" />
+
+        </LinearLayout>
+
+    </androidx.cardview.widget.CardView>
+
+</androidx.constraintlayout.widget.ConstraintLayout>
\ No newline at end of file
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/route_card_item.xml b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/route_card_item.xml
new file mode 100644
index 0000000..329ccdb
--- /dev/null
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/route_card_item.xml
@@ -0,0 +1,94 @@
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.cardview.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:layout_marginBottom="8dp"
+    app:cardBackgroundColor="#333333"
+    app:cardCornerRadius="12dp"
+    app:cardElevation="4dp">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal"
+        android:padding="12dp"
+        android:gravity="center_vertical">
+
+        <!-- √çcone da rota -->
+        <ImageView
+            android:id="@+id/routeIcon"
+            android:layout_width="24dp"
+            android:layout_height="24dp"
+            android:layout_marginEnd="12dp"
+            android:src="@android:drawable/ic_menu_directions"
+            android:tint="#FFEB3B" />
+
+        <!-- Informa√ß√µes da rota -->
+        <LinearLayout
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:orientation="vertical">
+
+            <TextView
+                android:id="@+id/routeTitle"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:text="Rota Principal"
+                android:textColor="#FFFFFF"
+                android:textSize="16sp"
+                android:textStyle="bold" />
+
+            <LinearLayout
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:orientation="horizontal"
+                android:layout_marginTop="4dp">
+
+                <TextView
+                    android:id="@+id/routeDuration"
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1"
+                    android:text="25 min"
+                    android:textColor="#FFEB3B"
+                    android:textSize="14sp" />
+
+                <TextView
+                    android:id="@+id/routeDistance"
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1"
+                    android:text="12.5 km"
+                    android:textColor="#AAAAAA"
+                    android:textSize="14sp"
+                    android:gravity="end" />
+
+            </LinearLayout>
+
+            <TextView
+                android:id="@+id/routeDifference"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:text="+2 min mais lenta"
+                android:textColor="#FF6B6B"
+                android:textSize="12sp"
+                android:layout_marginTop="2dp" />
+
+        </LinearLayout>
+
+        <!-- Bot√£o selecionar -->
+        <Button
+            android:id="@+id/selectRouteButton"
+            android:layout_width="wrap_content"
+            android:layout_height="36dp"
+            android:text="Selecionar"
+            android:textSize="12sp"
+            android:backgroundTint="#FFEB3B"
+            android:textColor="#000000"
+            android:layout_marginStart="8dp" />
+
+    </LinearLayout>
+
+</androidx.cardview.widget.CardView>
\ No newline at end of file
