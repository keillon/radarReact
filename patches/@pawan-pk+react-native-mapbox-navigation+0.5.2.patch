diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/.project b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/.project
new file mode 100644
index 0000000..83f1d08
--- /dev/null
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/.project
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>pawan-pk_react-native-mapbox-navigation</name>
+	<comment>Project pawan-pk_react-native-mapbox-navigation created by Buildship.</comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.buildship.core.gradleprojectbuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.buildship.core.gradleprojectnature</nature>
+	</natures>
+	<filteredResources>
+		<filter>
+			<id>1768515740480</id>
+			<name></name>
+			<type>30</type>
+			<matcher>
+				<id>org.eclipse.core.resources.regexFilterMatcher</id>
+				<arguments>node_modules|\.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
+</projectDescription>
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationView.kt b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationView.kt
index 41a3ba0..2fbc32d 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationView.kt
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationView.kt
@@ -3,22 +3,32 @@ package com.mapboxnavigation
 import android.annotation.SuppressLint
 import android.content.res.Configuration
 import android.content.res.Resources
+import android.graphics.BitmapFactory
+import android.graphics.Color
 import android.util.Log
 import android.view.LayoutInflater
 import android.view.View
+import android.view.ViewGroup
 import android.widget.FrameLayout
+import android.widget.ImageView
+import android.widget.TextView
 import com.facebook.react.bridge.Arguments
 import com.facebook.react.uimanager.ThemedReactContext
 import com.facebook.react.uimanager.events.RCTEventEmitter
+import com.google.gson.JsonObject
 import com.mapbox.api.directions.v5.DirectionsCriteria
-import com.mapbox.api.directions.v5.models.DirectionsWaypoint
 import com.mapbox.api.directions.v5.models.RouteOptions
 import com.mapbox.bindgen.Expected
 import com.mapbox.common.location.Location
+import com.mapbox.geojson.Feature
+import com.mapbox.geojson.FeatureCollection
 import com.mapbox.geojson.Point
 import com.mapbox.maps.CameraOptions
 import com.mapbox.maps.EdgeInsets
+import com.mapbox.maps.Image
 import com.mapbox.maps.ImageHolder
+import com.mapbox.maps.LayerPosition
+import com.mapbox.maps.extension.style.expressions.dsl.generated.*
 import com.mapbox.maps.plugin.LocationPuck2D
 import com.mapbox.maps.plugin.animation.camera
 import com.mapbox.maps.plugin.locationcomponent.location
@@ -83,7 +93,8 @@ import com.mapboxnavigation.databinding.NavigationViewBinding
 import java.util.Locale
 
 @SuppressLint("ViewConstructor")
-class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout(context.baseContext) {
+class MapboxNavigationView(private val context: ThemedReactContext) :
+        FrameLayout(context.baseContext) {
   private companion object {
     private const val BUTTON_ANIMATION_DURATION = 1500L
   }
@@ -95,26 +106,28 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
   private var waypointLegs: List<WaypointLegs> = listOf()
   private var distanceUnit: String = DirectionsCriteria.IMPERIAL
   private var locale = Locale.getDefault()
+  private var radars: List<RadarPoint> = listOf()
+  private var imageMissingListenerRegistered = false
+  private var isStyleLoading = false
+  private var nearbyRadarIds: Set<String> = setOf() // IDs dos radares pr√≥ximos para anima√ß√£o pulsante
 
-  /**
-   * Bindings to the example layout.
-   */
-  private var binding: NavigationViewBinding = NavigationViewBinding.inflate(LayoutInflater.from(context), this, true)
+  /** Bindings to the example layout. */
+  private var binding: NavigationViewBinding =
+          NavigationViewBinding.inflate(LayoutInflater.from(context), this, true)
 
   /**
-   * Produces the camera frames based on the location and routing data for the [navigationCamera] to execute.
+   * Produces the camera frames based on the location and routing data for the [navigationCamera] to
+   * execute.
    */
   private var viewportDataSource = MapboxNavigationViewportDataSource(binding.mapView.mapboxMap)
 
   /**
    * Used to execute camera transitions based on the data generated by the [viewportDataSource].
-   * This includes transitions from route overview to route following and continuously updating the camera as the location changes.
+   * This includes transitions from route overview to route following and continuously updating the
+   * camera as the location changes.
    */
-  private var navigationCamera = NavigationCamera(
-    binding.mapView.mapboxMap,
-    binding.mapView.camera,
-    viewportDataSource
-  )
+  private var navigationCamera =
+          NavigationCamera(binding.mapView.mapboxMap, binding.mapView.camera, viewportDataSource)
 
   /**
    * Mapbox Navigation entry point. There should only be one instance of this object for the app.
@@ -128,36 +141,16 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
    */
   private val pixelDensity = Resources.getSystem().displayMetrics.density
   private val overviewPadding: EdgeInsets by lazy {
-    EdgeInsets(
-      140.0 * pixelDensity,
-      40.0 * pixelDensity,
-      120.0 * pixelDensity,
-      40.0 * pixelDensity
-    )
+    EdgeInsets(140.0 * pixelDensity, 40.0 * pixelDensity, 120.0 * pixelDensity, 40.0 * pixelDensity)
   }
   private val landscapeOverviewPadding: EdgeInsets by lazy {
-    EdgeInsets(
-      30.0 * pixelDensity,
-      380.0 * pixelDensity,
-      110.0 * pixelDensity,
-      20.0 * pixelDensity
-    )
+    EdgeInsets(30.0 * pixelDensity, 380.0 * pixelDensity, 110.0 * pixelDensity, 20.0 * pixelDensity)
   }
   private val followingPadding: EdgeInsets by lazy {
-    EdgeInsets(
-      180.0 * pixelDensity,
-      40.0 * pixelDensity,
-      150.0 * pixelDensity,
-      40.0 * pixelDensity
-    )
+    EdgeInsets(180.0 * pixelDensity, 40.0 * pixelDensity, 150.0 * pixelDensity, 40.0 * pixelDensity)
   }
   private val landscapeFollowingPadding: EdgeInsets by lazy {
-    EdgeInsets(
-      30.0 * pixelDensity,
-      380.0 * pixelDensity,
-      110.0 * pixelDensity,
-      40.0 * pixelDensity
-    )
+    EdgeInsets(30.0 * pixelDensity, 380.0 * pixelDensity, 110.0 * pixelDensity, 40.0 * pixelDensity)
   }
 
   /**
@@ -167,12 +160,14 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
   private lateinit var maneuverApi: MapboxManeuverApi
 
   /**
-   * Generates updates for the [MapboxTripProgressView] that include remaining time and distance to the destination.
+   * Generates updates for the [MapboxTripProgressView] that include remaining time and distance to
+   * the destination.
    */
   private lateinit var tripProgressApi: MapboxTripProgressApi
 
   /**
-   * Stores and updates the state of whether the voice instructions should be played as they come or muted.
+   * Stores and updates the state of whether the voice instructions should be played as they come or
+   * muted.
    */
   private var isVoiceInstructionsMuted = false
     set(value) {
@@ -187,134 +182,127 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
     }
 
   /**
-   * Extracts message that should be communicated to the driver about the upcoming maneuver.
-   * When possible, downloads a synthesized audio file that can be played back to the driver.
+   * Extracts message that should be communicated to the driver about the upcoming maneuver. When
+   * possible, downloads a synthesized audio file that can be played back to the driver.
    */
   private lateinit var speechApi: MapboxSpeechApi
 
   /**
-   * Plays the synthesized audio files with upcoming maneuver instructions
-   * or uses an on-device Text-To-Speech engine to communicate the message to the driver.
-   * NOTE: do not use lazy initialization for this class since it takes some time to initialize
-   * the system services required for on-device speech synthesis. With lazy initialization
-   * there is a high risk that said services will not be available when the first instruction
-   * has to be played. [MapboxVoiceInstructionsPlayer] should be instantiated in
-   * `Activity#onCreate`.
+   * Plays the synthesized audio files with upcoming maneuver instructions or uses an on-device
+   * Text-To-Speech engine to communicate the message to the driver. NOTE: do not use lazy
+   * initialization for this class since it takes some time to initialize the system services
+   * required for on-device speech synthesis. With lazy initialization there is a high risk that
+   * said services will not be available when the first instruction has to be played.
+   * [MapboxVoiceInstructionsPlayer] should be instantiated in `Activity#onCreate`.
    */
   private var voiceInstructionsPlayer: MapboxVoiceInstructionsPlayer? = null
 
-  /**
-   * Observes when a new voice instruction should be played.
-   */
+  /** Observes when a new voice instruction should be played. */
   private val voiceInstructionsObserver = VoiceInstructionsObserver { voiceInstructions ->
     speechApi.generate(voiceInstructions, speechCallback)
   }
 
   /**
-   * Based on whether the synthesized audio file is available, the callback plays the file
-   * or uses the fall back which is played back using the on-device Text-To-Speech engine.
+   * Based on whether the synthesized audio file is available, the callback plays the file or uses
+   * the fall back which is played back using the on-device Text-To-Speech engine.
    */
   private val speechCallback =
-    MapboxNavigationConsumer<Expected<SpeechError, SpeechValue>> { expected ->
-      expected.fold(
-        { error ->
-          // play the instruction via fallback text-to-speech engine
-          voiceInstructionsPlayer?.play(
-            error.fallback,
-            voiceInstructionsPlayerCallback
-          )
-        },
-        { value ->
-          // play the sound file from the external generator
-          voiceInstructionsPlayer?.play(
-            value.announcement,
-            voiceInstructionsPlayerCallback
-          )
-        }
-      )
-    }
+          MapboxNavigationConsumer<Expected<SpeechError, SpeechValue>> { expected ->
+            expected.fold(
+                    { error ->
+                      // play the instruction via fallback text-to-speech engine
+                      voiceInstructionsPlayer?.play(error.fallback, voiceInstructionsPlayerCallback)
+                    },
+                    { value ->
+                      // play the sound file from the external generator
+                      voiceInstructionsPlayer?.play(
+                              value.announcement,
+                              voiceInstructionsPlayerCallback
+                      )
+                    }
+            )
+          }
 
   /**
-   * When a synthesized audio file was downloaded, this callback cleans up the disk after it was played.
+   * When a synthesized audio file was downloaded, this callback cleans up the disk after it was
+   * played.
    */
   private val voiceInstructionsPlayerCallback =
-    MapboxNavigationConsumer<SpeechAnnouncement> { value ->
-      // remove already consumed file to free-up space
-      speechApi.clean(value)
-    }
+          MapboxNavigationConsumer<SpeechAnnouncement> { value ->
+            // remove already consumed file to free-up space
+            speechApi.clean(value)
+          }
 
   /**
-   * [NavigationLocationProvider] is a utility class that helps to provide location updates generated by the Navigation SDK
-   * to the Maps SDK in order to update the user location indicator on the map.
+   * [NavigationLocationProvider] is a utility class that helps to provide location updates
+   * generated by the Navigation SDK to the Maps SDK in order to update the user location indicator
+   * on the map.
    */
   private val navigationLocationProvider = NavigationLocationProvider()
 
   /**
-   * RouteLine: Additional route line options are available through the
-   * [MapboxRouteLineViewOptions] and [MapboxRouteLineApiOptions].
-   * Notice here the [MapboxRouteLineViewOptions.routeLineBelowLayerId] option. The map is made up of layers. In this
-   * case the route line will be placed below the "road-label" layer which is a good default
+   * RouteLine: Additional route line options are available through the [MapboxRouteLineViewOptions]
+   * and [MapboxRouteLineApiOptions]. Notice here the
+   * [MapboxRouteLineViewOptions.routeLineBelowLayerId] option. The map is made up of layers. In
+   * this case the route line will be placed below the "road-label" layer which is a good default
    * for the most common Mapbox navigation related maps. You should consider if this should be
    * changed for your use case especially if you are using a custom map style.
    */
   private val routeLineViewOptions: MapboxRouteLineViewOptions by lazy {
     MapboxRouteLineViewOptions.Builder(context)
-      /**
-       * Route line related colors can be customized via the [RouteLineColorResources]. If using the
-       * default colors the [RouteLineColorResources] does not need to be set as seen here, the
-       * defaults will be used internally by the builder.
-       */
-      .routeLineColorResources(RouteLineColorResources.Builder().build())
-      .routeLineBelowLayerId("road-label-navigation")
-      .build()
+            /**
+             * Route line related colors can be customized via the [RouteLineColorResources].
+             * Configurando cores amarelas para a rota com borda preta.
+             */
+            .routeLineColorResources(
+                    RouteLineColorResources.Builder()
+                            .routeLowCongestionColor(Color.parseColor("#FFEB3B")) // Amarelo #FFEB3B
+                            .routeModerateCongestionColor(Color.parseColor("#FFEB3B")) // Amarelo #FFEB3B
+                            .routeSevereCongestionColor(Color.parseColor("#FFEB3B")) // Amarelo #FFEB3B
+                            .routeDefaultColor(Color.parseColor("#FFEB3B")) // Amarelo #FFEB3B
+                            .routeUnknownCongestionColor(Color.parseColor("#FFEB3B")) // Amarelo #FFEB3B
+                            .routeCasingColor(Color.parseColor("#000000")) // Preto #000000 para borda
+                            .build()
+            )
+            .routeLineBelowLayerId("road-label-navigation")
+            .build()
   }
 
   private val routeLineApiOptions: MapboxRouteLineApiOptions by lazy {
-    MapboxRouteLineApiOptions.Builder()
-      .build()
+    MapboxRouteLineApiOptions.Builder().build()
   }
 
   /**
-   * RouteLine: This class is responsible for rendering route line related mutations generated
-   * by the [routeLineApi]
+   * RouteLine: This class is responsible for rendering route line related mutations generated by
+   * the [routeLineApi]
    */
-  private val routeLineView by lazy {
-    MapboxRouteLineView(routeLineViewOptions)
-  }
-
+  private val routeLineView by lazy { MapboxRouteLineView(routeLineViewOptions) }
 
   /**
    * RouteLine: This class is responsible for generating route line related data which must be
    * rendered by the [routeLineView] in order to visualize the route line on the map.
    */
-  private val routeLineApi: MapboxRouteLineApi by lazy {
-    MapboxRouteLineApi(routeLineApiOptions)
-  }
+  private val routeLineApi: MapboxRouteLineApi by lazy { MapboxRouteLineApi(routeLineApiOptions) }
 
   /**
-   * RouteArrow: This class is responsible for generating data related to maneuver arrows. The
-   * data generated must be rendered by the [routeArrowView] in order to apply mutations to
-   * the map.
+   * RouteArrow: This class is responsible for generating data related to maneuver arrows. The data
+   * generated must be rendered by the [routeArrowView] in order to apply mutations to the map.
    */
-  private val routeArrowApi: MapboxRouteArrowApi by lazy {
-    MapboxRouteArrowApi()
-  }
+  private val routeArrowApi: MapboxRouteArrowApi by lazy { MapboxRouteArrowApi() }
 
   /**
-   * RouteArrow: Customization of the maneuver arrow(s) can be done using the
-   * [RouteArrowOptions]. Here the above layer ID is used to determine where in the map layer
-   * stack the arrows appear. Above the layer of the route traffic line is being used here. Your
-   * use case may necessitate adjusting this to a different layer position.
+   * RouteArrow: Customization of the maneuver arrow(s) can be done using the [RouteArrowOptions].
+   * Here the above layer ID is used to determine where in the map layer stack the arrows appear.
+   * Above the layer of the route traffic line is being used here. Your use case may necessitate
+   * adjusting this to a different layer position.
    */
   private val routeArrowOptions by lazy {
-    RouteArrowOptions.Builder(context)
-      .withAboveLayerId(TOP_LEVEL_ROUTE_LINE_LAYER_ID)
-      .build()
+    RouteArrowOptions.Builder(context).withAboveLayerId(TOP_LEVEL_ROUTE_LINE_LAYER_ID).build()
   }
 
   /**
-   * RouteArrow: This class is responsible for rendering the arrow related mutations generated
-   * by the [routeArrowApi]
+   * RouteArrow: This class is responsible for rendering the arrow related mutations generated by
+   * the [routeArrowApi]
    */
   private val routeArrowView: MapboxRouteArrowView by lazy {
     MapboxRouteArrowView(routeArrowOptions)
@@ -323,53 +311,62 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
   /**
    * Gets notified with location updates.
    *
-   * Exposes raw updates coming directly from the location services
-   * and the updates enhanced by the Navigation SDK (cleaned up and matched to the road).
-   */
-  private val locationObserver = object : LocationObserver {
-    var firstLocationUpdateReceived = false
-
-    override fun onNewRawLocation(rawLocation: Location) {
-      // not handled
-    }
-
-    override fun onNewLocationMatcherResult(locationMatcherResult: LocationMatcherResult) {
-      val enhancedLocation = locationMatcherResult.enhancedLocation
-      // update location puck's position on the map
-      navigationLocationProvider.changePosition(
-        location = enhancedLocation,
-        keyPoints = locationMatcherResult.keyPoints,
-      )
-
-      // update camera position to account for new location
-      viewportDataSource.onLocationChanged(enhancedLocation)
-      viewportDataSource.evaluate()
-
-      // if this is the first location update the activity has received,
-      // it's best to immediately move the camera to the current user location
-      if (!firstLocationUpdateReceived) {
-        firstLocationUpdateReceived = true
-        navigationCamera.requestNavigationCameraToOverview(
-          stateTransitionOptions = NavigationCameraTransitionOptions.Builder()
-            .maxDuration(0) // instant transition
-            .build()
-        )
-      }
-
-      val event = Arguments.createMap()
-      event.putDouble("longitude", enhancedLocation.longitude)
-      event.putDouble("latitude", enhancedLocation.latitude)
-      event.putDouble("heading", enhancedLocation.bearing ?: 0.0)
-      event.putDouble("accuracy", enhancedLocation.horizontalAccuracy ?: 0.0)
-      context
-        .getJSModule(RCTEventEmitter::class.java)
-        .receiveEvent(id, "onLocationChange", event)
-    }
-  }
-
-  /**
-   * Gets notified with progress along the currently active route.
+   * Exposes raw updates coming directly from the location services and the updates enhanced by the
+   * Navigation SDK (cleaned up and matched to the road).
    */
+  private val locationObserver =
+          object : LocationObserver {
+            var firstLocationUpdateReceived = false
+
+            override fun onNewRawLocation(rawLocation: Location) {
+              // not handled
+            }
+
+            override fun onNewLocationMatcherResult(locationMatcherResult: LocationMatcherResult) {
+              val enhancedLocation = locationMatcherResult.enhancedLocation
+              // update location puck's position on the map
+              navigationLocationProvider.changePosition(
+                      location = enhancedLocation,
+                      keyPoints = locationMatcherResult.keyPoints,
+              )
+
+              // update camera position to account for new location
+              viewportDataSource.onLocationChanged(enhancedLocation)
+              viewportDataSource.evaluate()
+
+              // if this is the first location update the activity has received,
+              // it's best to immediately move the camera to follow the user location
+              if (!firstLocationUpdateReceived) {
+                firstLocationUpdateReceived = true
+                navigationCamera.requestNavigationCameraToFollowing(
+                        stateTransitionOptions =
+                                NavigationCameraTransitionOptions.Builder()
+                                        .maxDuration(0) // instant transition
+                                        .build()
+                )
+              }
+
+              try {
+                val event = Arguments.createMap()
+                event.putDouble("longitude", enhancedLocation.longitude)
+                event.putDouble("latitude", enhancedLocation.latitude)
+                event.putDouble("heading", enhancedLocation.bearing ?: 0.0)
+                event.putDouble("accuracy", enhancedLocation.horizontalAccuracy ?: 0.0)
+                // Add speed in m/s, convert to km/h
+                val speedMs = enhancedLocation.speed ?: 0.0
+                event.putDouble("speed", speedMs * 3.6) // Convert m/s to km/h
+
+                val eventEmitter = context.getJSModule(RCTEventEmitter::class.java)
+                if (eventEmitter != null) {
+                  eventEmitter.receiveEvent(id, "onLocationChange", event)
+                }
+              } catch (e: Exception) {
+                Log.e("MapboxNavigationView", "Erro ao enviar evento onLocationChange", e)
+              }
+            }
+          }
+
+  /** Gets notified with progress along the currently active route. */
   private val routeProgressObserver = RouteProgressObserver { routeProgress ->
     // update the camera position to account for the progressed fragment of the route
     if (routeProgress.fractionTraveled.toDouble() != 0.0) {
@@ -387,48 +384,68 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
     // update top banner with maneuver instructions
     val maneuvers = maneuverApi.getManeuvers(routeProgress)
     maneuvers.fold(
-      { error ->
-        Log.w("Maneuvers error:", error.throwable)
-      },
-      {
-        val maneuverViewOptions = ManeuverViewOptions.Builder()
-          .primaryManeuverOptions(
-            ManeuverPrimaryOptions.Builder()
-              .textAppearance(R.style.PrimaryManeuverTextAppearance)
-              .build()
-          )
-          .secondaryManeuverOptions(
-            ManeuverSecondaryOptions.Builder()
-              .textAppearance(R.style.ManeuverTextAppearance)
-              .build()
-          )
-          .subManeuverOptions(
-            ManeuverSubOptions.Builder()
-              .textAppearance(R.style.ManeuverTextAppearance)
-              .build()
-          )
-          .stepDistanceTextAppearance(R.style.StepDistanceRemainingAppearance)
-          .build()
-
-        binding.maneuverView.visibility = View.VISIBLE
-        binding.maneuverView.updateManeuverViewOptions(maneuverViewOptions)
-        binding.maneuverView.renderManeuvers(maneuvers)
-      }
+            { error -> Log.w("Maneuvers error:", error.throwable) },
+            {
+              val maneuverViewOptions =
+                      ManeuverViewOptions.Builder()
+                              .primaryManeuverOptions(
+                                      ManeuverPrimaryOptions.Builder()
+                                              .textAppearance(R.style.PrimaryManeuverTextAppearance)
+                                              .build()
+                              )
+                              .secondaryManeuverOptions(
+                                      ManeuverSecondaryOptions.Builder()
+                                              .textAppearance(R.style.ManeuverTextAppearance)
+                                              .build()
+                              )
+                              .subManeuverOptions(
+                                      ManeuverSubOptions.Builder()
+                                              .textAppearance(R.style.ManeuverTextAppearance)
+                                              .build()
+                              )
+                              .stepDistanceTextAppearance(R.style.StepDistanceRemainingAppearance)
+                              .build()
+
+              binding.maneuverView.visibility = View.VISIBLE
+              binding.maneuverView.updateManeuverViewOptions(maneuverViewOptions)
+              binding.maneuverView.renderManeuvers(maneuvers)
+              
+              // Estilizar ManeuverView com cores preto/amarelo (fundo e textos)
+              try {
+                styleManeuverView()
+              } catch (e: Exception) {
+                Log.d("MapboxNavigationView", "Erro ao estilizar ManeuverView: ${e.message}")
+              }
+            }
     )
 
     // update bottom trip progress summary
-    binding.tripProgressView.render(
-      tripProgressApi.getTripProgress(routeProgress)
-    )
+    binding.tripProgressView.render(tripProgressApi.getTripProgress(routeProgress))
     
-    val event = Arguments.createMap()
-    event.putDouble("distanceTraveled", routeProgress.distanceTraveled.toDouble())
-    event.putDouble("durationRemaining", routeProgress.durationRemaining)
-    event.putDouble("fractionTraveled", routeProgress.fractionTraveled.toDouble())
-    event.putDouble("distanceRemaining", routeProgress.distanceRemaining.toDouble())
-    context
-      .getJSModule(RCTEventEmitter::class.java)
-      .receiveEvent(id, "onRouteProgressChange", event)
+    // Estilizar os TextViews e ImageViews dentro do TripProgressView
+    try {
+      styleTripProgressView()
+    } catch (e: Exception) {
+      // Silenciar erro - pode n√£o ser poss√≠vel estilizar completamente
+    }
+
+    try {
+      val event = Arguments.createMap()
+      event.putDouble("distanceTraveled", routeProgress.distanceTraveled.toDouble())
+      event.putDouble("durationRemaining", routeProgress.durationRemaining)
+      event.putDouble("fractionTraveled", routeProgress.fractionTraveled.toDouble())
+      event.putDouble("distanceRemaining", routeProgress.distanceRemaining.toDouble())
+      // IMPORTANTE: O m√©todo speedLimit() N√ÉO EXISTE no Mapbox Navigation SDK v3.2.0
+      // Os componentes MapboxSpeedInfoView e MapboxSpeedLimitView no layout XML devem
+      // exibir velocidade e limite automaticamente se o SDK suportar.
+      // N√£o tente chamar speedLimit() - isso causar√° erro de compila√ß√£o!
+      val eventEmitter = context.getJSModule(RCTEventEmitter::class.java)
+      if (eventEmitter != null) {
+        eventEmitter.receiveEvent(id, "onRouteProgressChange", event)
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao enviar evento onRouteProgressChange", e)
+    }
   }
 
   /**
@@ -436,18 +453,15 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
    *
    * A change can mean:
    * - routes get changed with [MapboxNavigation.setNavigationRoutes]
-   * - routes annotations get refreshed (for example, congestion annotation that indicate the live traffic along the route)
+   * - routes annotations get refreshed (for example, congestion annotation that indicate the live
+   * traffic along the route)
    * - driver got off route and a reroute was executed
    */
   private val routesObserver = RoutesObserver { routeUpdateResult ->
     if (routeUpdateResult.navigationRoutes.isNotEmpty()) {
       // generate route geometries asynchronously and render them
-      routeLineApi.setNavigationRoutes(
-        routeUpdateResult.navigationRoutes
-      ) { value ->
-        binding.mapView.mapboxMap.style?.apply {
-          routeLineView.renderRouteDrawData(this, value)
-        }
+      routeLineApi.setNavigationRoutes(routeUpdateResult.navigationRoutes) { value ->
+        binding.mapView.mapboxMap.style?.apply { routeLineView.renderRouteDrawData(this, value) }
       }
 
       // update the camera position to account for the new route
@@ -458,10 +472,7 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
       val style = binding.mapView.mapboxMap.style
       if (style != null) {
         routeLineApi.clearRouteLine { value ->
-          routeLineView.renderClearRouteLineValue(
-            style,
-            value
-          )
+          routeLineView.renderClearRouteLineValue(style, value)
         }
         routeArrowView.render(style, routeArrowApi.clearArrows())
       }
@@ -478,14 +489,12 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
 
   private fun onCreate() {
     // initialize Mapbox Navigation
-    mapboxNavigation = if (MapboxNavigationProvider.isCreated()) {
-      MapboxNavigationProvider.retrieve()
-    } else {
-      MapboxNavigationProvider.create(
-        NavigationOptions.Builder(context)
-          .build()
-      )
-    }
+    mapboxNavigation =
+            if (MapboxNavigationProvider.isCreated()) {
+              MapboxNavigationProvider.retrieve()
+            } else {
+              MapboxNavigationProvider.create(NavigationOptions.Builder(context).build())
+            }
   }
 
   @SuppressLint("MissingPermission")
@@ -495,27 +504,19 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
       return
     }
 
-    // Recenter Camera
-    val initialCameraOptions = CameraOptions.Builder()
-      .zoom(14.0)
-      .center(origin)
-      .build()
-    binding.mapView.mapboxMap.setCamera(initialCameraOptions)
-
-    // Start Navigation
+    // Start Navigation (a c√¢mera ser√° focada no usu√°rio automaticamente ap√≥s a primeira atualiza√ß√£o de localiza√ß√£o)
     startNavigation()
 
     // set the animations lifecycle listener to ensure the NavigationCamera stops
     // automatically following the user location when the map is interacted with
     binding.mapView.camera.addCameraAnimationsLifecycleListener(
-      NavigationBasicGesturesHandler(navigationCamera)
+            NavigationBasicGesturesHandler(navigationCamera)
     )
     navigationCamera.registerNavigationCameraStateChangeObserver { navigationCameraState ->
       // shows/hide the recenter button depending on the camera state
       when (navigationCameraState) {
-        NavigationCameraState.TRANSITION_TO_FOLLOWING,
-        NavigationCameraState.FOLLOWING -> binding.recenter.visibility = View.INVISIBLE
-
+        NavigationCameraState.TRANSITION_TO_FOLLOWING, NavigationCameraState.FOLLOWING ->
+                binding.recenter.visibility = View.INVISIBLE
         NavigationCameraState.TRANSITION_TO_OVERVIEW,
         NavigationCameraState.OVERVIEW,
         NavigationCameraState.IDLE -> binding.recenter.visibility = View.VISIBLE
@@ -535,55 +536,82 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
 
     // make sure to use the same DistanceFormatterOptions across different features
     val unitType = if (distanceUnit == "imperial") UnitType.IMPERIAL else UnitType.METRIC
-    val distanceFormatterOptions = DistanceFormatterOptions.Builder(context)
-      .unitType(unitType)
-      .build()
+    val distanceFormatterOptions =
+            DistanceFormatterOptions.Builder(context).unitType(unitType).build()
 
     // initialize maneuver api that feeds the data to the top banner maneuver view
-    maneuverApi = MapboxManeuverApi(
-      MapboxDistanceFormatter(distanceFormatterOptions)
-    )
+    maneuverApi = MapboxManeuverApi(MapboxDistanceFormatter(distanceFormatterOptions))
 
     // initialize bottom progress view
-    tripProgressApi = MapboxTripProgressApi(
-      TripProgressUpdateFormatter.Builder(context)
-        .distanceRemainingFormatter(
-          DistanceRemainingFormatter(distanceFormatterOptions)
-        )
-        .timeRemainingFormatter(
-          TimeRemainingFormatter(context)
-        )
-        .percentRouteTraveledFormatter(
-          PercentDistanceTraveledFormatter()
-        )
-        .estimatedTimeToArrivalFormatter(
-          EstimatedTimeToArrivalFormatter(context, TimeFormat.NONE_SPECIFIED)
-        )
-        .build()
-    )
+    tripProgressApi =
+            MapboxTripProgressApi(
+                    TripProgressUpdateFormatter.Builder(context)
+                            .distanceRemainingFormatter(
+                                    DistanceRemainingFormatter(distanceFormatterOptions)
+                            )
+                            .timeRemainingFormatter(TimeRemainingFormatter(context))
+                            .percentRouteTraveledFormatter(PercentDistanceTraveledFormatter())
+                            .estimatedTimeToArrivalFormatter(
+                                    EstimatedTimeToArrivalFormatter(
+                                            context,
+                                            TimeFormat.NONE_SPECIFIED
+                                    )
+                            )
+                            .build()
+            )
     // initialize voice instructions api and the voice instruction player
-    speechApi = MapboxSpeechApi(
-      context,
-      locale.language
-    )
-    voiceInstructionsPlayer = MapboxVoiceInstructionsPlayer(
-      context,
-      locale.language
-    )
+    speechApi = MapboxSpeechApi(context, locale.toLanguageTag())
+    voiceInstructionsPlayer = MapboxVoiceInstructionsPlayer(context, locale.toLanguageTag())
 
     // load map style
+    Log.d("MapboxNavigationView", "üé® INICIANDO loadStyle(NAVIGATION_DAY_STYLE)")
     binding.mapView.mapboxMap.loadStyle(NavigationStyles.NAVIGATION_DAY_STYLE) {
-      // Ensure that the route line related layers are present before the route arrow
-      routeLineView.initializeLayers(it)
+      Log.d("MapboxNavigationView", "üé® Estilo NAVIGATION_DAY_STYLE carregado, iniciando setup")
+      try {
+        // Ensure that the route line related layers are present before the route arrow
+        routeLineView.initializeLayers(it)
+        // Carregar imagens das placas previamente (com tratamento de erro)
+        Log.d("MapboxNavigationView", "üñºÔ∏è Carregando imagens das placas...")
+        try {
+          loadRadarImages(it)
+          Log.d("MapboxNavigationView", "‚úÖ loadRadarImages conclu√≠do")
+        } catch (e: Exception) {
+          Log.e("MapboxNavigationView", "‚ùå Erro ao carregar imagens pr√©vias", e)
+          // Continuar mesmo se falhar - listener vai carregar sob demanda
+        }
+        // Registrar listener de imagens faltantes apenas uma vez
+        try {
+          registerImageMissingListener(it)
+          Log.d("MapboxNavigationView", "‚úÖ Listener de imagens faltantes registrado")
+        } catch (e: Exception) {
+          Log.e("MapboxNavigationView", "‚ùå Erro ao registrar listener de imagens", e)
+        }
+        // Atualizar radares ap√≥s o estilo carregar
+        Log.d("MapboxNavigationView", "üîÑ Chamando updateRadarsOnMap() ap√≥s estilo carregar")
+        updateRadarsOnMap()
+      } catch (e: Exception) {
+        Log.e("MapboxNavigationView", "‚ùå Erro ao inicializar estilo", e)
+        // Tentar atualizar radares mesmo se houver erro
+        try {
+          updateRadarsOnMap()
+        } catch (e2: Exception) {
+          Log.e("MapboxNavigationView", "‚ùå Erro ao atualizar radares ap√≥s erro de estilo", e2)
+        }
+      }
     }
 
     // initialize view interactions
     binding.stop.setOnClickListener {
       val event = Arguments.createMap()
       event.putString("message", "Navigation Cancel")
-      context
-        .getJSModule(RCTEventEmitter::class.java)
-        .receiveEvent(id, "onCancelNavigation", event)
+      try {
+        val eventEmitter = context.getJSModule(RCTEventEmitter::class.java)
+        if (eventEmitter != null) {
+          eventEmitter.receiveEvent(id, "onCancelNavigation", event)
+        }
+      } catch (e: Exception) {
+        Log.e("MapboxNavigationView", "Erro ao enviar evento onCancelNavigation", e)
+      }
     }
 
     binding.recenter.setOnClickListener {
@@ -622,11 +650,19 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
     // initialize location puck
     binding.mapView.location.apply {
       setLocationProvider(navigationLocationProvider)
-      this.locationPuck = LocationPuck2D(
-        bearingImage = ImageHolder.Companion.from(
-          com.mapbox.navigation.ui.maps.R.drawable.mapbox_navigation_puck_icon
-        )
-      )
+      this.locationPuck =
+              LocationPuck2D(
+                      bearingImage =
+                              ImageHolder.Companion.from(
+                                      com.mapbox
+                                              .navigation
+                                              .ui
+                                              .maps
+                                              .R
+                                              .drawable
+                                              .mapbox_navigation_puck_icon
+                              )
+              )
       puckBearingEnabled = true
       enabled = true
     }
@@ -634,20 +670,21 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
     startRoute()
   }
 
-  private val arrivalObserver = object : ArrivalObserver {
+  private val arrivalObserver =
+          object : ArrivalObserver {
 
-    override fun onWaypointArrival(routeProgress: RouteProgress) {
-      onArrival(routeProgress)
-    }
+            override fun onWaypointArrival(routeProgress: RouteProgress) {
+              onArrival(routeProgress)
+            }
 
-    override fun onNextRouteLegStart(routeLegProgress: RouteLegProgress) {
-      // do something when the user starts a new leg
-    }
+            override fun onNextRouteLegStart(routeLegProgress: RouteLegProgress) {
+              // do something when the user starts a new leg
+            }
 
-    override fun onFinalDestinationArrival(routeProgress: RouteProgress) {
-      onArrival(routeProgress)
-    }
-  }
+            override fun onFinalDestinationArrival(routeProgress: RouteProgress) {
+              onArrival(routeProgress)
+            }
+          }
 
   private fun onArrival(routeProgress: RouteProgress) {
     val leg = routeProgress.currentLegProgress
@@ -656,9 +693,14 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
       event.putInt("index", leg.legIndex)
       event.putDouble("latitude", leg.legDestination?.location?.latitude() ?: 0.0)
       event.putDouble("longitude", leg.legDestination?.location?.longitude() ?: 0.0)
-      context
-        .getJSModule(RCTEventEmitter::class.java)
-        .receiveEvent(id, "onArrive", event)
+      try {
+        val eventEmitter = context.getJSModule(RCTEventEmitter::class.java)
+        if (eventEmitter != null) {
+          eventEmitter.receiveEvent(id, "onArrive", event)
+        }
+      } catch (e: Exception) {
+        Log.e("MapboxNavigationView", "Erro ao enviar evento onArrive", e)
+      }
     }
   }
 
@@ -669,8 +711,8 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
 
   private val measureAndLayout = Runnable {
     measure(
-      MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY),
-      MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY)
+            MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY),
+            MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY)
     )
     layout(left, top, right, bottom)
   }
@@ -687,33 +729,36 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
     names.add(destinationTitle)
 
     mapboxNavigation?.requestRoutes(
-      RouteOptions.builder()
-        .applyDefaultNavigationOptions()
-        .applyLanguageAndVoiceUnitOptions(context)
-        .coordinatesList(coordinates)
-        .waypointIndicesList(indices)
-        .waypointNamesList(names)
-        .language(locale.language)
-        .steps(true)
-        .voiceInstructions(true)
-        .voiceUnits(distanceUnit)
-        .build(),
-      object : NavigationRouterCallback {
-        override fun onCanceled(routeOptions: RouteOptions, @RouterOrigin routerOrigin: String) {
-          // no implementation
-        }
-
-        override fun onFailure(reasons: List<RouterFailure>, routeOptions: RouteOptions) {
-          sendErrorToReact("Error finding route $reasons")
-        }
-
-        override fun onRoutesReady(
-          routes: List<NavigationRoute>,
-          @RouterOrigin routerOrigin: String
-        ) {
-          setRouteAndStartNavigation(routes)
-        }
-      }
+            RouteOptions.builder()
+                    .applyDefaultNavigationOptions()
+                    .applyLanguageAndVoiceUnitOptions(context)
+                    .coordinatesList(coordinates)
+                    .waypointIndicesList(indices)
+                    .waypointNamesList(names)
+                    .language(locale.toLanguageTag())
+                    .steps(true)
+                    .voiceInstructions(true)
+                    .voiceUnits(distanceUnit)
+                    .build(),
+            object : NavigationRouterCallback {
+              override fun onCanceled(
+                      routeOptions: RouteOptions,
+                      @RouterOrigin routerOrigin: String
+              ) {
+                // no implementation
+              }
+
+              override fun onFailure(reasons: List<RouterFailure>, routeOptions: RouteOptions) {
+                sendErrorToReact("Error finding route $reasons")
+              }
+
+              override fun onRoutesReady(
+                      routes: List<NavigationRoute>,
+                      @RouterOrigin routerOrigin: String
+              ) {
+                setRouteAndStartNavigation(routes)
+              }
+            }
     )
   }
 
@@ -728,8 +773,15 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
     binding.routeOverview.visibility = View.VISIBLE
     binding.tripProgressCard.visibility = View.VISIBLE
 
+    // Estilizar bot√µes de navega√ß√£o com cores amarelas
+    try {
+      styleNavigationButtons()
+    } catch (e: Exception) {
+      Log.d("MapboxNavigationView", "Erro ao estilizar bot√µes de navega√ß√£o: ${e.message}")
+    }
+
     // move the camera to overview when new route is available
-//    navigationCamera.requestNavigationCameraToOverview()
+    //    navigationCamera.requestNavigationCameraToOverview()
     mapboxNavigation?.startTripSession(withForegroundService = true)
   }
 
@@ -771,9 +823,14 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
   private fun sendErrorToReact(error: String?) {
     val event = Arguments.createMap()
     event.putString("error", error)
-    context
-      .getJSModule(RCTEventEmitter::class.java)
-      .receiveEvent(id, "onError", event)
+    try {
+      val eventEmitter = context.getJSModule(RCTEventEmitter::class.java)
+      if (eventEmitter != null) {
+        eventEmitter.receiveEvent(id, "onError", event)
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao enviar evento onError", e)
+    }
   }
 
   fun onDropViewInstance() {
@@ -811,6 +868,11 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
       1 -> locale = Locale(locals.first())
       2 -> locale = Locale(locals.first(), locals.last())
     }
+    // Reinitialize voice instructions with new locale if already initialized
+    if (::speechApi.isInitialized) {
+      speechApi = MapboxSpeechApi(context, locale.toLanguageTag())
+      voiceInstructionsPlayer = MapboxVoiceInstructionsPlayer(context, locale.toLanguageTag())
+    }
   }
 
   fun setMute(mute: Boolean) {
@@ -820,4 +882,796 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
   fun setShowCancelButton(show: Boolean) {
     binding.stop.visibility = if (show) View.VISIBLE else View.INVISIBLE
   }
+
+  fun setRadars(radars: List<RadarPoint>) {
+    this.radars = radars
+    Log.d("MapboxNavigationView", "üì° setRadars chamado com ${radars.size} radares")
+    if (radars.isNotEmpty()) {
+      Log.d(
+              "MapboxNavigationView",
+              "üìç Primeiro radar: lat=${radars[0].latitude}, lng=${radars[0].longitude}, speedLimit=${radars[0].speedLimit}"
+      )
+    }
+    updateRadarsOnMap()
+  }
+
+  fun setNearbyRadarIds(ids: Set<String>) {
+    // Atualizar IDs de radares pr√≥ximos para anima√ß√£o pulsante
+    if (this.nearbyRadarIds != ids) {
+      this.nearbyRadarIds = ids
+      Log.d("MapboxNavigationView", "üìç IDs de radares pr√≥ximos atualizados: ${ids.size} radares")
+      // Atualizar propriedade isNearby no GeoJSON source
+      updateNearbyRadarsInSource()
+    }
+  }
+  
+  private fun updateNearbyRadarsInSource() {
+    // Atualizar propriedade isNearby no GeoJSON source existente
+    val style = binding.mapView.mapboxMap.style
+    if (style == null || !style.styleSourceExists("radars-source")) {
+      return
+    }
+    
+    try {
+      // Atualizar GeoJSON source com propriedade isNearby atualizada
+      // Criar novo GeoJSON com isNearby atualizado
+      val features = radars.map { radar ->
+        val speedLimit = radar.speedLimit ?: 0.0
+        val speeds = listOf(20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160)
+        val closestSpeed = if (speedLimit > 0) {
+          speeds.minByOrNull { kotlin.math.abs(it - speedLimit) } ?: 0
+        } else {
+          0
+        }
+        val iconImage = if (closestSpeed > 0) "placa$closestSpeed" else "placa0"
+        val isNearby = nearbyRadarIds.contains(radar.id)
+        
+        Feature.fromGeometry(
+                Point.fromLngLat(radar.longitude, radar.latitude),
+                JsonObject().apply {
+                  addProperty("id", radar.id)
+                  addProperty("speedLimit", radar.speedLimit?.toString() ?: "")
+                  addProperty("iconImage", iconImage)
+                  addProperty("isNearby", isNearby)
+                }
+        )
+      }
+      
+      val featureCollection = FeatureCollection.fromFeatures(features.toList())
+      val geoJsonString = featureCollection.toJson()
+      val sourceJson = """
+        {
+          "type": "geojson",
+          "data": $geoJsonString
+        }
+      """.trimIndent()
+      
+      val sourceValueResult = com.mapbox.bindgen.Value.fromJson(sourceJson)
+      when (val value = sourceValueResult.value) {
+        null -> {
+          Log.e("MapboxNavigationView", "Erro ao atualizar source: ${sourceValueResult.error}")
+        }
+        else -> {
+          style.removeStyleSource("radars-source")
+          style.addStyleSource("radars-source", value)
+          Log.d("MapboxNavigationView", "‚úÖ GeoJSON source atualizado com isNearby: ${nearbyRadarIds.size} radares pr√≥ximos")
+        }
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao atualizar nearbyRadarsInSource", e)
+    }
+  }
+
+private fun loadRadarImages(style: com.mapbox.maps.Style) {
+    // Carregar todas as imagens das placas usando ImageHolder.fromBitmap() (API correta do SDK v11)
+    // Baseado no exemplo oficial do Mapbox Maps SDK v11:
+    // https://docs.mapbox.com/android/maps/examples/android-view/display-multiple-icon-images-in-a-symbol-layer/
+    Log.d("MapboxNavigationView", "üîÑ INICIANDO loadRadarImages() - usando style.addImage() com Bitmap")
+    
+    var imagesLoaded = 0
+    var imagesFailed = 0
+    
+    try {
+      val imageNames =
+              listOf(
+                      "placa0",
+                      "placa20",
+                      "placa30",
+                      "placa40",
+                      "placa50",
+                      "placa60",
+                      "placa70",
+                      "placa80",
+                      "placa90",
+                      "placa100",
+                      "placa110",
+                      "placa120",
+                      "placa130",
+                      "placa140",
+                      "placa150",
+                      "placa160",
+                      "placa"
+              )
+
+      imageNames.forEach { imageName ->
+        try {
+          val resourceName = "assets_images_$imageName"
+          val resourceId =
+                  context.resources.getIdentifier(resourceName, "drawable", context.packageName)
+          
+          if (resourceId == 0) {
+            Log.w("MapboxNavigationView", "‚ö†Ô∏è Recurso n√£o encontrado: $resourceName")
+            imagesFailed++
+            return@forEach
+          }
+          
+          val bitmap = BitmapFactory.decodeResource(context.resources, resourceId)
+          if (bitmap == null) {
+            Log.w("MapboxNavigationView", "‚ö†Ô∏è Bitmap null para $resourceName")
+            imagesFailed++
+            return@forEach
+          }
+          
+          // USAR style.addImage() - API CORRETA DO MAPBOX SDK v11
+          // N√£o usar reflection, DataRef ou Image diretamente
+          try {
+            // Verificar se a imagem j√° existe no estilo antes de adicionar
+            val imageExists = try {
+              style.getStyleImage(imageName) != null
+            } catch (e: Exception) {
+              false
+            }
+            
+            if (!imageExists) {
+              // Usar addImage() que aceita Bitmap diretamente (API v11)
+              style.addImage(imageName, bitmap)
+              imagesLoaded++
+              Log.d(
+                      "MapboxNavigationView",
+                      "‚úÖ Imagem $imageName carregada (${bitmap.width}x${bitmap.height}) - Total: $imagesLoaded"
+              )
+            } else {
+              Log.d("MapboxNavigationView", "‚ÑπÔ∏è Imagem $imageName j√° existe no estilo")
+            }
+          } catch (e: Exception) {
+            Log.e(
+                    "MapboxNavigationView",
+                    "‚ùå Erro ao adicionar imagem $imageName ao estilo usando ImageHolder",
+                    e
+            )
+            imagesFailed++
+          }
+        } catch (e: Exception) {
+          Log.e("MapboxNavigationView", "‚ùå Erro ao carregar imagem $imageName", e)
+          imagesFailed++
+        }
+      }
+      
+      Log.d(
+              "MapboxNavigationView",
+              "‚úÖ Carregamento conclu√≠do: $imagesLoaded carregadas, $imagesFailed falharam"
+      )
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "‚ùå Erro geral ao carregar imagens", e)
+    }
+  }
+
+
+  private fun registerImageMissingListener(style: com.mapbox.maps.Style) {
+    // Registrar listener apenas uma vez
+    if (imageMissingListenerRegistered) {
+      Log.d("MapboxNavigationView", "Listener de imagens faltantes j√° registrado")
+      return
+    }
+
+    binding.mapView.mapboxMap.subscribeStyleImageMissing { eventData ->
+      val missingId = eventData.imageId
+      Log.d("MapboxNavigationView", "üîç Imagem faltante detectada pelo listener: $missingId")
+
+      // Verificar se o estilo ainda est√° dispon√≠vel
+      val currentStyle = binding.mapView.mapboxMap.style
+      if (currentStyle == null) {
+        Log.w(
+                "MapboxNavigationView",
+                "Estilo n√£o dispon√≠vel ao processar imagem faltante: $missingId"
+        )
+        return@subscribeStyleImageMissing
+      }
+
+      // Tentar carregar a imagem faltante
+      try {
+        val resourceName = "assets_images_$missingId"
+        val resourceId =
+                context.resources.getIdentifier(resourceName, "drawable", context.packageName)
+        if (resourceId != 0) {
+          val bitmap = BitmapFactory.decodeResource(context.resources, resourceId)
+          if (bitmap != null) {
+            // USAR style.addImage() - API CORRETA DO MAPBOX SDK v11 (mesmo m√©todo do function.kt que funcionava)
+            try {
+              // Verificar se a imagem j√° existe antes de adicionar
+              val imageExists = try {
+                currentStyle.getStyleImage(missingId) != null
+              } catch (e: Exception) {
+                false
+              }
+              
+              if (!imageExists) {
+                // Usar addImage() que aceita Bitmap diretamente (API v11) - mesmo m√©todo do function.kt
+                currentStyle.addImage(missingId, bitmap)
+                Log.d(
+                        "MapboxNavigationView",
+                        "‚úÖ Imagem faltante $missingId carregada via listener (${bitmap.width}x${bitmap.height})"
+                )
+                Log.d("MapboxNavigationView", "üîÑ Imagem $missingId deve aparecer no mapa agora")
+              } else {
+                Log.d("MapboxNavigationView", "‚ÑπÔ∏è Imagem $missingId j√° existe no estilo")
+              }
+            } catch (e: Exception) {
+              Log.e("MapboxNavigationView", "‚ùå Erro ao carregar imagem $missingId usando addImage", e)
+            }
+          }
+        } else {
+          Log.w(
+                  "MapboxNavigationView",
+                  "Recurso n√£o encontrado para imagem faltante: $resourceName"
+          )
+        }
+      } catch (e: Exception) {
+        Log.e("MapboxNavigationView", "Erro ao processar imagem faltante $missingId", e)
+        // N√£o fazer printStackTrace para evitar poluir logs
+      }
+    }
+
+    imageMissingListenerRegistered = true
+    Log.d("MapboxNavigationView", "Listener de imagens faltantes registrado com sucesso")
+  }
+
+  private fun updateRadarsOnMap() {
+    Log.d("MapboxNavigationView", "üîÑ INICIANDO updateRadarsOnMap() com ${radars.size} radares")
+    Log.d("MapboxNavigationView", "üìã Binding dispon√≠vel: ${binding != null}")
+    // Verificar se binding est√° dispon√≠vel
+    if (binding == null) {
+      Log.w("MapboxNavigationView", "‚ö†Ô∏è Binding n√£o dispon√≠vel - ABORTANDO updateRadarsOnMap")
+      return
+    }
+
+    val style = binding.mapView.mapboxMap.style
+    if (style == null) {
+      Log.w("MapboxNavigationView", "Estilo do mapa ainda n√£o est√° pronto, aguardando...")
+      // Evitar chamar loadStyle m√∫ltiplas vezes
+      if (!isStyleLoading) {
+        isStyleLoading = true
+        binding.mapView.mapboxMap.loadStyle(NavigationStyles.NAVIGATION_DAY_STYLE) {
+          isStyleLoading = false
+          routeLineView.initializeLayers(it)
+          Log.d("MapboxNavigationView", "üîÑ Carregando imagens no loadStyle (updateRadarsOnMap)")
+          try {
+            loadRadarImages(it)
+          } catch (e: Exception) {
+            Log.e("MapboxNavigationView", "‚ùå Erro ao carregar imagens no loadStyle", e)
+          }
+          registerImageMissingListener(it)
+          updateRadarsOnMap()
+        }
+      }
+      return
+    }
+
+    Log.d("MapboxNavigationView", "Atualizando ${radars.size} radares no mapa")
+
+    // Criar GeoJSON FeatureCollection com os radares
+    val features =
+            radars.map { radar ->
+              // Mapear velocidade para nome da imagem (mesma l√≥gica do React Native)
+              val speedLimit = radar.speedLimit ?: 0.0
+              val speeds = listOf(20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160)
+              val closestSpeed =
+                      if (speedLimit > 0) {
+                        speeds.minByOrNull { kotlin.math.abs(it - speedLimit) } ?: 0
+                      } else {
+                        0
+                      }
+              val iconImage = if (closestSpeed > 0) "placa$closestSpeed" else "placa0"
+
+              // Log para debug (apenas primeiro radar para n√£o poluir logs)
+              if (radars.indexOf(radar) == 0) {
+                Log.d(
+                        "MapboxNavigationView",
+                        "Primeiro radar: speedLimit=${radar.speedLimit}, iconImage=$iconImage"
+                )
+              }
+
+              Feature.fromGeometry(
+                      Point.fromLngLat(radar.longitude, radar.latitude),
+                      JsonObject().apply {
+                        addProperty("id", radar.id)
+                        addProperty("speedLimit", radar.speedLimit?.toString() ?: "")
+                        addProperty("iconImage", iconImage)
+                      }
+              )
+            }
+
+    if (features.isEmpty()) {
+      Log.d("MapboxNavigationView", "Nenhum radar para adicionar")
+      return
+    }
+
+    val featureCollection = FeatureCollection.fromFeatures(features.toList())
+    Log.d("MapboxNavigationView", "FeatureCollection criado com ${features.size} features")
+
+    // Verificar novamente se o estilo ainda est√° dispon√≠vel antes de usar
+    val currentStyle = binding.mapView.mapboxMap.style
+    if (currentStyle == null) {
+      Log.w("MapboxNavigationView", "Estilo ficou null durante atualiza√ß√£o, abortando")
+      return
+    }
+
+    // Remover source e layer existentes se houver
+    try {
+      if (currentStyle.styleSourceExists("radars-source")) {
+        currentStyle.removeStyleSource("radars-source")
+        Log.d("MapboxNavigationView", "üóëÔ∏è Source radars-source removido")
+      }
+      if (currentStyle.styleLayerExists("radars-layer")) {
+        currentStyle.removeStyleLayer("radars-layer")
+        Log.d("MapboxNavigationView", "üóëÔ∏è Layer radars-layer removido")
+      }
+      if (currentStyle.styleLayerExists("radars-layer-symbol")) {
+        currentStyle.removeStyleLayer("radars-layer-symbol")
+        Log.d("MapboxNavigationView", "üóëÔ∏è Layer radars-layer-symbol removido")
+      }
+    } catch (e: Exception) {
+      Log.w("MapboxNavigationView", "‚ö†Ô∏è Erro ao remover source/layer existente: ${e.message}")
+      // Continuar mesmo se houver erro ao remover
+    }
+
+    // Adicionar GeoJSON source usando a API do Mapbox Maps SDK v11
+    try {
+      // Verificar estilo novamente antes de adicionar source
+      val styleForSource = binding.mapView.mapboxMap.style
+      if (styleForSource == null) {
+        Log.w("MapboxNavigationView", "Estilo ficou null antes de adicionar source")
+        return
+      }
+
+      val geoJsonString = featureCollection.toJson()
+      val sourceJson =
+              """
+        {
+          "type": "geojson",
+          "data": $geoJsonString
+        }
+      """.trimIndent()
+
+      val sourceValueResult = com.mapbox.bindgen.Value.fromJson(sourceJson)
+      when (val value = sourceValueResult.value) {
+        null -> {
+          Log.e("MapboxNavigationView", "Erro ao criar Value do JSON: ${sourceValueResult.error}")
+          return
+        }
+        else -> {
+          styleForSource.addStyleSource("radars-source", value)
+          Log.d(
+                  "MapboxNavigationView",
+                  "GeoJSON source adicionado com sucesso: ${radars.size} radares"
+          )
+        }
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao adicionar GeoJSON source", e)
+      // N√£o fazer return aqui para tentar adicionar o layer mesmo se o source falhar
+    }
+
+    // O listener de imagens faltantes √© registrado apenas uma vez em registerImageMissingListener()
+
+    // Adicionar SymbolLayer para renderizar os radares com √≠cones usando API v11
+    try {
+      // Verificar estilo novamente antes de adicionar layer
+      val styleForLayer = binding.mapView.mapboxMap.style
+      if (styleForLayer == null) {
+        Log.w("MapboxNavigationView", "Estilo ficou null antes de adicionar layer")
+        return
+      }
+
+      // PASSO 1: Carregar TODAS as imagens ANTES de criar qualquer layer
+      // CR√çTICO: As imagens DEVEM estar no estilo ANTES do SymbolLayer ser criado
+      // Mesmo m√©todo do function.kt que estava funcionando
+      Log.d("MapboxNavigationView", "üñºÔ∏è PASSO 1: Carregando imagens ANTES de criar layers...")
+      try {
+        loadRadarImages(styleForLayer)
+        
+        // Verificar se as imagens foram realmente adicionadas ao estilo
+        val requiredImages = listOf("placa0", "placa20", "placa60", "placa")
+        var allImagesLoaded = true
+        requiredImages.forEach { imgName ->
+          val exists = try {
+            styleForLayer.getStyleImage(imgName) != null
+          } catch (e: Exception) {
+            false
+          }
+          if (exists) {
+            Log.d("MapboxNavigationView", "‚úÖ Verifica√ß√£o: Imagem $imgName existe no estilo")
+          } else {
+            Log.w("MapboxNavigationView", "‚ö†Ô∏è Verifica√ß√£o: Imagem $imgName N√ÉO encontrada no estilo")
+            allImagesLoaded = false
+          }
+        }
+        
+        if (!allImagesLoaded) {
+          Log.w("MapboxNavigationView", "‚ö†Ô∏è Algumas imagens n√£o foram carregadas - SymbolLayer pode n√£o funcionar")
+        } else {
+          Log.d("MapboxNavigationView", "‚úÖ Todas as imagens necess√°rias foram carregadas")
+        }
+      } catch (e: Exception) {
+        Log.e("MapboxNavigationView", "‚ùå Erro cr√≠tico ao carregar imagens", e)
+        // N√ÉO continuar se as imagens n√£o foram carregadas
+        return
+      }
+
+      // PASSO 2: Adicionar SymbolLayer com as placas (sem CircleLayer/fallback)
+      // Mesmo m√©todo do function.kt que estava funcionando
+      Log.d("MapboxNavigationView", "üñºÔ∏è PASSO 2: Adicionando SymbolLayer (apenas placas, sem fallback)")
+      
+      try {
+        // Criar SymbolLayer com icon-image din√¢mico usando propriedade do GeoJSON
+        val layerJson = """
+          {
+            "id": "radars-layer-symbol",
+            "type": "symbol",
+            "source": "radars-source",
+            "layout": {
+              "icon-image": ["get", "iconImage"],
+              "icon-size": 0.1,
+              "icon-allow-overlap": true,
+              "icon-ignore-placement": true,
+              "icon-anchor": "bottom",
+              "icon-pitch-alignment": "viewport"
+            },
+            "paint": {}
+          }
+        """.trimIndent()
+
+        val layerValueResult = com.mapbox.bindgen.Value.fromJson(layerJson)
+        when (val value = layerValueResult.value) {
+          null -> {
+            Log.e(
+                    "MapboxNavigationView",
+                    "‚ùå Erro ao criar SymbolLayer: ${layerValueResult.error}"
+            )
+          }
+          else -> {
+            try {
+              // Adicionar SymbolLayer diretamente (sem CircleLayer) - igual ao function.kt
+              styleForLayer.addStyleLayer(value, null)
+              Log.d(
+                      "MapboxNavigationView",
+                      "‚úÖ SymbolLayer adicionado com sucesso (icon-size=0.1) - apenas placas"
+              )
+              Log.d(
+                      "MapboxNavigationView",
+                      "üìã SymbolLayer configurado para usar iconImage do GeoJSON"
+              )
+              
+              // PASSO 3: Adicionar CircleLayer pulsante para radares pr√≥ximos (apenas durante navega√ß√£o)
+              // Este layer cria o efeito de c√≠rculo pulsante ao redor dos radares pr√≥ximos
+              Log.d("MapboxNavigationView", "üîÑ PASSO 3: Adicionando CircleLayer pulsante para radares pr√≥ximos")
+              
+              try {
+                // Criar CircleLayer pulsante que ser√° animado via React Native
+                // O layer ser√° filtrado por uma propriedade isNearby que ser√° adicionada ao GeoJSON
+                val pulseLayerJson = """
+                  {
+                    "id": "radars-pulse-layer",
+                    "type": "circle",
+                    "source": "radars-source",
+                    "filter": ["==", ["get", "isNearby"], true],
+                    "paint": {
+                      "circle-color": "rgba(220, 38, 38, 0.3)",
+                      "circle-radius": 20,
+                      "circle-stroke-width": 2,
+                      "circle-stroke-color": "rgba(220, 38, 38, 0.8)",
+                      "circle-opacity": 0.6,
+                      "circle-pitch-scale": "map"
+                    }
+                  }
+                """.trimIndent()
+                
+                val pulseLayerValueResult = com.mapbox.bindgen.Value.fromJson(pulseLayerJson)
+                when (val pulseValue = pulseLayerValueResult.value) {
+                  null -> {
+                    Log.e(
+                            "MapboxNavigationView",
+                            "‚ùå Erro ao criar CircleLayer pulsante: ${pulseLayerValueResult.error}"
+                    )
+                  }
+                  else -> {
+                    try {
+                      // Adicionar CircleLayer pulsante ABAIXO do SymbolLayer
+                      // Usar LayerPosition para colocar abaixo do SymbolLayer
+                      val pulseLayerPosition = com.mapbox.maps.LayerPosition("radars-layer-symbol", null, null)
+                      styleForLayer.addStyleLayer(pulseValue, pulseLayerPosition)
+                      Log.d(
+                              "MapboxNavigationView",
+                              "‚úÖ CircleLayer pulsante adicionado com sucesso (abaixo do SymbolLayer)"
+                      )
+                    } catch (e: Exception) {
+                      // Tentar adicionar sem LayerPosition se falhar
+                      try {
+                        styleForLayer.addStyleLayer(pulseValue, null)
+                        Log.d(
+                                "MapboxNavigationView",
+                                "‚úÖ CircleLayer pulsante adicionado sem LayerPosition"
+                        )
+                      } catch (e2: Exception) {
+                        Log.e("MapboxNavigationView", "‚ùå Erro ao adicionar CircleLayer pulsante", e2)
+                      }
+                    }
+                  }
+                }
+              } catch (e: Exception) {
+                Log.e("MapboxNavigationView", "‚ùå Erro ao processar CircleLayer pulsante", e)
+              }
+            } catch (e: Exception) {
+              Log.e("MapboxNavigationView", "‚ùå Erro ao adicionar SymbolLayer", e)
+            }
+          }
+        }
+      } catch (e: Exception) {
+        Log.e("MapboxNavigationView", "‚ùå Erro ao processar SymbolLayer", e)
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao processar layer", e)
+      // N√£o fazer printStackTrace para evitar poluir logs
+    }
+  }
+  
+  /**
+   * Fun√ß√£o para estilizar o TripProgressView com cores preto/amarelo
+   * Tenta encontrar e estilizar todos os TextViews e ImageViews dentro do TripProgressView
+   */
+  private fun styleTripProgressView() {
+    try {
+      val tripProgressView = binding.tripProgressView
+      
+      // Definir fundo transparente
+      tripProgressView.setBackgroundColor(0x00000000)
+      
+      // Fun√ß√£o recursiva para encontrar e estilizar todos os TextViews e ImageViews
+      fun styleViews(view: View) {
+        when (view) {
+          is TextView -> {
+            // Aplicar cor amarela aos textos
+            view.setTextColor(0xFFFFEB3B.toInt()) // Amarelo #FFEB3B
+          }
+          is android.widget.ImageView -> {
+            // Aplicar cor branca aos √≠cones
+            view.colorFilter = android.graphics.PorterDuffColorFilter(
+              0xFFFFFFFF.toInt(), // Branco #FFFFFF
+              android.graphics.PorterDuff.Mode.SRC_ATOP
+            )
+          }
+        }
+        
+        if (view is ViewGroup) {
+          for (i in 0 until view.childCount) {
+            styleViews(view.getChildAt(i))
+          }
+        }
+      }
+      
+      // Estilizar ap√≥s um pequeno delay para garantir que a view foi renderizada
+      tripProgressView.post {
+        styleViews(tripProgressView)
+      }
+    } catch (e: Exception) {
+      // Silenciar erro - pode n√£o ser poss√≠vel estilizar completamente
+      Log.d("MapboxNavigationView", "Erro ao estilizar TripProgressView: ${e.message}")
+    }
+  }
+  
+  /**
+   * Fun√ß√£o para estilizar os bot√µes de navega√ß√£o (soundButton, routeOverview, recenter)
+   * Aplica cores amarelas aos √≠cones dos bot√µes
+   */
+  private fun styleNavigationButtons() {
+    try {
+      // Estilizar SoundButton
+      try {
+        val soundButton = binding.soundButton
+        // Tentar encontrar ImageViews dentro do bot√£o e aplicar cor amarela
+        styleButtonViews(soundButton)
+      } catch (e: Exception) {
+        Log.d("MapboxNavigationView", "Erro ao estilizar soundButton: ${e.message}")
+      }
+      
+      // Estilizar RouteOverviewButton
+      try {
+        val routeOverview = binding.routeOverview
+        styleButtonViews(routeOverview)
+      } catch (e: Exception) {
+        Log.d("MapboxNavigationView", "Erro ao estilizar routeOverview: ${e.message}")
+      }
+      
+      // Estilizar RecenterButton
+      try {
+        val recenter = binding.recenter
+        styleButtonViews(recenter)
+      } catch (e: Exception) {
+        Log.d("MapboxNavigationView", "Erro ao estilizar recenter: ${e.message}")
+      }
+    } catch (e: Exception) {
+      Log.d("MapboxNavigationView", "Erro ao estilizar bot√µes de navega√ß√£o: ${e.message}")
+    }
+  }
+  
+  /**
+   * Fun√ß√£o auxiliar para estilizar views dentro de um bot√£o
+   * Melhorada para encontrar ImageViews em diferentes estruturas de layout e aplicar cor amarela
+   */
+  private fun styleButtonViews(view: View) {
+    // Fun√ß√£o recursiva para encontrar e estilizar ImageViews e aplicar tint
+    fun styleViewsRecursive(v: View) {
+      when (v) {
+        is ImageView -> {
+          // Aplicar cor amarela aos √≠cones dos bot√µes usando colorFilter
+          v.colorFilter = android.graphics.PorterDuffColorFilter(
+            0xFFFFEB3B.toInt(), // Amarelo #FFEB3B
+            android.graphics.PorterDuff.Mode.SRC_ATOP
+          )
+          // Tamb√©m tentar aplicar tint diretamente se dispon√≠vel (API 21+)
+          try {
+            v.imageTintList = android.content.res.ColorStateList.valueOf(0xFFFFEB3B.toInt())
+            v.imageTintMode = android.graphics.PorterDuff.Mode.SRC_ATOP
+          } catch (e: Exception) {
+            // Se n√£o suportar tint, usar apenas colorFilter
+          }
+          // For√ßar redraw
+          v.invalidate()
+        }
+        is android.widget.ImageButton -> {
+          // Para ImageButton, aplicar cor amarela
+          v.colorFilter = android.graphics.PorterDuffColorFilter(
+            0xFFFFEB3B.toInt(), // Amarelo #FFEB3B
+            android.graphics.PorterDuff.Mode.SRC_ATOP
+          )
+          try {
+            v.imageTintList = android.content.res.ColorStateList.valueOf(0xFFFFEB3B.toInt())
+            v.imageTintMode = android.graphics.PorterDuff.Mode.SRC_ATOP
+          } catch (e: Exception) {
+            // Ignorar se n√£o suportar
+          }
+          v.invalidate()
+        }
+      }
+      
+      if (v is ViewGroup) {
+        for (i in 0 until v.childCount) {
+          styleViewsRecursive(v.getChildAt(i))
+        }
+      }
+      
+      // Tentar aplicar tint no pr√≥prio view se for compat√≠vel com tint usando reflection
+      try {
+        val viewClass = v.javaClass
+        // Tentar m√©todos comuns de tint
+        try {
+          val setTintMethod = viewClass.getMethod("setImageTintList", android.content.res.ColorStateList::class.java)
+          setTintMethod.invoke(v, android.content.res.ColorStateList.valueOf(0xFFFFEB3B.toInt()))
+          
+          val setTintModeMethod = viewClass.getMethod("setImageTintMode", android.graphics.PorterDuff.Mode::class.java)
+          setTintModeMethod.invoke(v, android.graphics.PorterDuff.Mode.SRC_ATOP)
+          
+          v.invalidate()
+        } catch (e: NoSuchMethodException) {
+          // M√©todo n√£o existe, tentar pr√≥ximo
+        }
+      } catch (e: Exception) {
+        // Ignorar se n√£o suportar - n√£o logar para evitar polui√ß√£o
+      }
+    }
+    
+    // Estilizar imediatamente
+    styleViewsRecursive(view)
+    
+    // Estilizar ap√≥s view ser totalmente renderizada
+    view.post {
+      styleViewsRecursive(view)
+      // Tentar mais uma vez ap√≥s delay maior para garantir que drawable foi carregado
+      view.postDelayed({
+        styleViewsRecursive(view)
+        view.invalidate()
+        Log.d("MapboxNavigationView", "‚úÖ Estiliza√ß√£o de bot√£o aplicada: ${view.javaClass.simpleName}")
+      }, 200)
+    }
+  }
+  
+  /**
+   * Fun√ß√£o para estilizar o ManeuverView (Turn by Turn) com cores preto/amarelo
+   * Aplica fundo preto com borda amarela diretamente no ManeuverView
+   */
+  /**
+   * Fun√ß√£o para estilizar o ManeuverView (Turn by Turn) com cores preto/amarelo
+   * Aplica fundo preto com borda amarela diretamente no ManeuverView e estiliza textos/√≠cones
+   */
+  private fun styleManeuverView() {
+    try {
+      val maneuverView = binding.maneuverView
+      
+      // Aplicar fundo preto semi-transparente com borda amarela DIRETAMENTE no ManeuverView
+      // IMPORTANTE: Sobrescrever qualquer fundo padr√£o do SDK
+      try {
+        val backgroundDrawable = android.graphics.drawable.GradientDrawable()
+        backgroundDrawable.setColor(0xE6000000.toInt()) // Preto semi-transparente #E6000000
+        backgroundDrawable.setStroke(
+          (2 * context.resources.displayMetrics.density).toInt(), 
+          0xFFFFEB3B.toInt()
+        ) // Borda amarela de 2dp #FFEB3B
+        backgroundDrawable.cornerRadius = 16f * context.resources.displayMetrics.density // 16dp em pixels
+        
+        // Aplicar fundo diretamente - isso deve sobrescrever o fundo azul padr√£o
+        maneuverView.background = backgroundDrawable
+        
+        // Aplicar padding para espa√ßamento interno
+        val paddingDp = 16
+        val paddingPx = (paddingDp * context.resources.displayMetrics.density).toInt()
+        maneuverView.setPadding(paddingPx, paddingPx, paddingPx, paddingPx)
+        
+        // For√ßar invalidate para garantir que o fundo seja aplicado
+        maneuverView.invalidate()
+        maneuverView.requestLayout()
+        
+        Log.d("MapboxNavigationView", "‚úÖ Fundo preto/amarelo aplicado no ManeuverView")
+      } catch (e: Exception) {
+        Log.e("MapboxNavigationView", "Erro ao aplicar fundo no ManeuverView: ${e.message}", e)
+      }
+      
+      // Fun√ß√£o recursiva para encontrar e estilizar todos os TextViews e ImageViews
+      fun styleViews(view: View) {
+        when (view) {
+          is TextView -> {
+            // Aplicar cor amarela aos textos
+            view.setTextColor(0xFFFFEB3B.toInt()) // Amarelo #FFEB3B
+          }
+          is ImageView -> {
+            // Aplicar cor amarela aos √≠cones de seta/manobra
+            view.colorFilter = android.graphics.PorterDuffColorFilter(
+              0xFFFFEB3B.toInt(), // Amarelo #FFEB3B
+              android.graphics.PorterDuff.Mode.SRC_ATOP
+            )
+          }
+        }
+        
+        if (view is ViewGroup) {
+          for (i in 0 until view.childCount) {
+            styleViews(view.getChildAt(i))
+          }
+        }
+      }
+      
+      // Estilizar ap√≥s delays m√∫ltiplos para garantir que a view foi totalmente renderizada
+      maneuverView.post {
+        styleViews(maneuverView)
+        // Tentar novamente ap√≥s mais um delay
+        maneuverView.postDelayed({
+          styleViews(maneuverView)
+          // Reaplicar fundo tamb√©m no segundo delay para garantir
+          try {
+            val backgroundDrawable = android.graphics.drawable.GradientDrawable()
+            backgroundDrawable.setColor(0xE6000000.toInt())
+            backgroundDrawable.setStroke(
+              (2 * context.resources.displayMetrics.density).toInt(),
+              0xFFFFEB3B.toInt()
+            )
+            backgroundDrawable.cornerRadius = 16f * context.resources.displayMetrics.density
+            maneuverView.background = backgroundDrawable
+            maneuverView.invalidate()
+          } catch (e: Exception) {
+            // Ignorar erro
+          }
+        }, 300)
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao estilizar ManeuverView: ${e.message}", e)
+    }
+  }
 }
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationViewManager.kt b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationViewManager.kt
index 03fad26..56d670f 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationViewManager.kt
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationViewManager.kt
@@ -1,16 +1,16 @@
 package com.mapboxnavigation
 
-import com.facebook.react.module.annotations.ReactModule
 import com.facebook.react.bridge.ReactApplicationContext
 import com.facebook.react.bridge.ReadableArray
 import com.facebook.react.common.MapBuilder
+import com.facebook.react.module.annotations.ReactModule
 import com.facebook.react.uimanager.ThemedReactContext
 import com.facebook.react.uimanager.annotations.ReactProp
-import com.mapbox.api.directions.v5.models.DirectionsWaypoint
 import com.mapbox.geojson.Point
 
 @ReactModule(name = MapboxNavigationViewManager.NAME)
-class MapboxNavigationViewManager(private var reactContext: ReactApplicationContext): MapboxNavigationViewManagerSpec<MapboxNavigationView>() {
+class MapboxNavigationViewManager(private var reactContext: ReactApplicationContext) :
+        MapboxNavigationViewManagerSpec<MapboxNavigationView>() {
   override fun getName(): String {
     return NAME
   }
@@ -24,13 +24,19 @@ class MapboxNavigationViewManager(private var reactContext: ReactApplicationCont
     super.onDropViewInstance(view)
   }
 
-  override fun getExportedCustomDirectEventTypeConstants(): MutableMap<String, Map<String, String>> {
+  override fun getExportedCustomDirectEventTypeConstants():
+          MutableMap<String, Map<String, String>> {
     return MapBuilder.of(
-      "onLocationChange", MapBuilder.of("registrationName", "onLocationChange"),
-      "onError", MapBuilder.of("registrationName", "onError"),
-      "onCancelNavigation", MapBuilder.of("registrationName", "onCancelNavigation"),
-      "onArrive", MapBuilder.of("registrationName", "onArrive"),
-      "onRouteProgressChange", MapBuilder.of("registrationName", "onRouteProgressChange"),
+            "onLocationChange",
+            MapBuilder.of("registrationName", "onLocationChange"),
+            "onError",
+            MapBuilder.of("registrationName", "onError"),
+            "onCancelNavigation",
+            MapBuilder.of("registrationName", "onCancelNavigation"),
+            "onArrive",
+            MapBuilder.of("registrationName", "onArrive"),
+            "onRouteProgressChange",
+            MapBuilder.of("registrationName", "onRouteProgressChange"),
     )
   }
 
@@ -61,7 +67,7 @@ class MapboxNavigationViewManager(private var reactContext: ReactApplicationCont
 
   @ReactProp(name = "distanceUnit")
   override fun setDirectionUnit(view: MapboxNavigationView?, value: String?) {
-    if (value != null)  {
+    if (value != null) {
       view?.setDirectionUnit(value)
     }
   }
@@ -73,21 +79,22 @@ class MapboxNavigationViewManager(private var reactContext: ReactApplicationCont
       return
     }
     val legs = mutableListOf<WaypointLegs>()
-    val waypoints: List<Point> = value.toArrayList().mapIndexedNotNull { index, item ->
-      val map = item as? Map<*, *>
-      val latitude = map?.get("latitude") as? Double
-      val longitude = map?.get("longitude") as? Double
-      val name = map?.get("name") as? String
-      val separatesLegs = map?.get("separatesLegs") as? Boolean
-      if (separatesLegs != false) {
-        legs.add(WaypointLegs(index = index + 1, name = name ?: "waypoint-$index"))
-      }
-      if (latitude != null && longitude != null) {
-        Point.fromLngLat(longitude, latitude)
-      } else {
-        null
-      }
-    }
+    val waypoints: List<Point> =
+            value.toArrayList().mapIndexedNotNull { index, item ->
+              val map = item as? Map<*, *>
+              val latitude = map?.get("latitude") as? Double
+              val longitude = map?.get("longitude") as? Double
+              val name = map?.get("name") as? String
+              val separatesLegs = map?.get("separatesLegs") as? Boolean
+              if (separatesLegs != false) {
+                legs.add(WaypointLegs(index = index + 1, name = name ?: "waypoint-$index"))
+              }
+              if (latitude != null && longitude != null) {
+                Point.fromLngLat(longitude, latitude)
+              } else {
+                null
+              }
+            }
     view?.setWaypointLegs(legs)
     view?.setWaypoints(waypoints)
   }
@@ -109,6 +116,45 @@ class MapboxNavigationViewManager(private var reactContext: ReactApplicationCont
     view?.setMute(value)
   }
 
+  @ReactProp(name = "radars")
+  fun setRadars(view: MapboxNavigationView?, value: ReadableArray?) {
+    if (value == null) {
+      view?.setRadars(emptyList())
+      return
+    }
+    val radars = mutableListOf<RadarPoint>()
+    for (i in 0 until value.size()) {
+      val map = value.getMap(i)
+      if (map != null) {
+        val latitude = map.getDouble("latitude")
+        val longitude = map.getDouble("longitude")
+        val id = map.getString("id") ?: "radar-$i"
+        val speedLimit =
+                if (map.hasKey("speedLimit") && !map.isNull("speedLimit")) {
+                  map.getInt("speedLimit").toDouble()
+                } else null
+        radars.add(RadarPoint(id, latitude, longitude, speedLimit))
+      }
+    }
+    view?.setRadars(radars)
+  }
+
+  @ReactProp(name = "nearbyRadarIds")
+  fun setNearbyRadarIds(view: MapboxNavigationView?, value: ReadableArray?) {
+    if (value == null) {
+      view?.setNearbyRadarIds(emptySet())
+      return
+    }
+    val ids = mutableSetOf<String>()
+    for (i in 0 until value.size()) {
+      val id = value.getString(i)
+      if (id != null) {
+        ids.add(id)
+      }
+    }
+    view?.setNearbyRadarIds(ids)
+  }
+
   companion object {
     const val NAME = "MapboxNavigationView"
   }
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/RadarPoint.kt b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/RadarPoint.kt
new file mode 100644
index 0000000..b4659f2
--- /dev/null
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/RadarPoint.kt
@@ -0,0 +1,8 @@
+package com.mapboxnavigation
+
+data class RadarPoint(
+        val id: String,
+        val latitude: Double,
+        val longitude: Double,
+        val speedLimit: Double? = null
+)
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/drawable/trip_progress_background.xml b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/drawable/trip_progress_background.xml
new file mode 100644
index 0000000..2d2aadf
--- /dev/null
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/drawable/trip_progress_background.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="rectangle">
+    
+    <!-- Fundo preto semi-transparente -->
+    <solid android:color="#E6000000" />
+    
+    <!-- Borda amarela de 2dp -->
+    <stroke
+        android:width="2dp"
+        android:color="#FFEB3B" />
+    
+    <!-- Bordas arredondadas -->
+    <corners android:radius="16dp" />
+    
+</shape>
+
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/navigation_view.xml b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/navigation_view.xml
index c00affd..f9e0bf7 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/navigation_view.xml
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/navigation_view.xml
@@ -13,31 +13,53 @@
     app:layout_constraintStart_toStartOf="parent"
     app:layout_constraintTop_toTopOf="parent" />
 
+  <!-- Compass ser√° habilitado programaticamente no Kotlin -->
+
+  <!-- Container principal com fundo semi-transparente preto e borda amarela -->
   <androidx.cardview.widget.CardView
     android:id="@+id/tripProgressCard"
     android:layout_width="0dp"
     android:layout_height="wrap_content"
     android:visibility="invisible"
+    app:cardBackgroundColor="#00000000"
+    app:cardCornerRadius="16dp"
     app:cardElevation="8dp"
     app:cardUseCompatPadding="false"
     app:layout_constraintBottom_toBottomOf="parent"
     app:layout_constraintEnd_toEndOf="parent"
-    app:layout_constraintStart_toStartOf="parent">
+    app:layout_constraintStart_toStartOf="parent"
+    android:layout_marginStart="16dp"
+    android:layout_marginEnd="16dp"
+    android:layout_marginBottom="16dp">
+
+    <!-- LinearLayout interno com fundo personalizado -->
+    <LinearLayout
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:background="@drawable/trip_progress_background"
+      android:orientation="horizontal"
+      android:padding="16dp"
+      android:gravity="center_vertical"
+      android:minHeight="72dp">
 
     <com.mapbox.navigation.ui.components.tripprogress.view.MapboxTripProgressView
       android:id="@+id/tripProgressView"
-      android:layout_width="match_parent"
-      android:layout_margin="8dp"
-      android:layout_height="wrap_content" />
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:layout_weight="1"
+        android:background="@android:color/transparent" />
 
     <ImageView
       android:id="@+id/stop"
-      android:layout_width="41dp"
-      android:layout_height="41dp"
-      android:layout_gravity="end|center_vertical"
-      android:layout_marginEnd="12dp"
-      app:srcCompat="@android:drawable/ic_delete"
-      android:contentDescription="@string/delete_icon"/>
+        android:layout_width="48dp"
+        android:layout_height="48dp"
+        android:layout_marginStart="12dp"
+        android:background="?attr/selectableItemBackgroundBorderless"
+        android:padding="8dp"
+        android:tint="#FFEB3B"
+        android:contentDescription="@string/delete_icon"
+        app:srcCompat="@android:drawable/ic_delete" />
+    </LinearLayout>
   </androidx.cardview.widget.CardView>
 
   <com.mapbox.navigation.ui.components.maneuver.view.MapboxManeuverView
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/values/styles.xml b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/values/styles.xml
index 4c3d3c3..cbb9be9 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/values/styles.xml
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/values/styles.xml
@@ -12,4 +12,35 @@
         <item name="android:textColor">#FFFFFF</item>
         <item name="android:textSize">21sp</item>
     </style>
+    
+    <!-- Tema personalizado para Trip Progress com cores preto/amarelo -->
+    <style name="TripProgressTheme" parent="Theme.AppCompat">
+        <!-- Cores principais -->
+        <item name="colorPrimary">#FFEB3B</item>
+        <item name="colorPrimaryDark">#000000</item>
+        <item name="colorAccent">#FFEB3B</item>
+        
+        <!-- Cores de texto -->
+        <item name="android:textColorPrimary">#FFEB3B</item>
+        <item name="android:textColorSecondary">#FFEB3B</item>
+        <item name="android:textColor">#FFEB3B</item>
+        
+        <!-- Fundo transparente -->
+        <item name="android:windowBackground">@android:color/transparent</item>
+        <item name="android:colorBackground">@android:color/transparent</item>
+    </style>
+    
+    <!-- Estilo para texto do trip progress -->
+    <style name="TripProgressTextAppearance" parent="TextAppearance.AppCompat">
+        <item name="android:textColor">#FFEB3B</item>
+        <item name="android:textSize">24sp</item>
+        <item name="android:textStyle">bold</item>
+    </style>
+    
+    <!-- Estilo para subtexto do trip progress -->
+    <style name="TripProgressSubtextAppearance" parent="TextAppearance.AppCompat">
+        <item name="android:textColor">#FFEB3B</item>
+        <item name="android:textSize">16sp</item>
+        <item name="android:textStyle">normal</item>
+    </style>
 </resources>
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/src/MapboxNavigation.tsx b/node_modules/@pawan-pk/react-native-mapbox-navigation/src/MapboxNavigation.tsx
index e3d3f19..5436421 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/src/MapboxNavigation.tsx
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/src/MapboxNavigation.tsx
@@ -106,6 +106,7 @@ class MapboxNavigation extends React.Component<
       onRouteProgressChange,
       onCancelNavigation,
       onError,
+      radars,
       ...rest
     } = this.props;
 
@@ -117,6 +118,12 @@ class MapboxNavigation extends React.Component<
           startOrigin={[startOrigin.longitude, startOrigin.latitude]}
           destinationTitle={destination.title}
           destination={[destination.longitude, destination.latitude]}
+          radars={radars?.map((r) => ({
+            id: r.id,
+            latitude: r.latitude,
+            longitude: r.longitude,
+            speedLimit: r.speedLimit,
+          }))}
           onLocationChange={(event) => onLocationChange?.(event.nativeEvent)}
           onRouteProgressChange={(event) =>
             onRouteProgressChange?.(event.nativeEvent)
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/src/MapboxNavigationViewNativeComponent.ts b/node_modules/@pawan-pk/react-native-mapbox-navigation/src/MapboxNavigationViewNativeComponent.ts
index 14196df..50f245e 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/src/MapboxNavigationViewNativeComponent.ts
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/src/MapboxNavigationViewNativeComponent.ts
@@ -23,6 +23,12 @@ interface NativeProps extends ViewProps {
   shouldSimulateRoute?: boolean;
   showsEndOfRouteFeedback?: boolean;
   hideStatusView?: boolean;
+  radars?: {
+    id: string;
+    latitude: Double;
+    longitude: Double;
+    speedLimit?: Double;
+  }[];
 }
 
 export default codegenNativeComponent<NativeProps>(
