diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/.classpath b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/.classpath
new file mode 100644
index 0000000..bbe97e5
--- /dev/null
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/.classpath
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-17/"/>
+	<classpathentry kind="con" path="org.eclipse.buildship.core.gradleclasspathcontainer"/>
+	<classpathentry kind="output" path="bin/default"/>
+</classpath>
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/.project b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/.project
new file mode 100644
index 0000000..83f1d08
--- /dev/null
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/.project
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>pawan-pk_react-native-mapbox-navigation</name>
+	<comment>Project pawan-pk_react-native-mapbox-navigation created by Buildship.</comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.buildship.core.gradleprojectbuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.buildship.core.gradleprojectnature</nature>
+	</natures>
+	<filteredResources>
+		<filter>
+			<id>1768515740480</id>
+			<name></name>
+			<type>30</type>
+			<matcher>
+				<id>org.eclipse.core.resources.regexFilterMatcher</id>
+				<arguments>node_modules|\.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
+</projectDescription>
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/.settings/org.eclipse.buildship.core.prefs b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/.settings/org.eclipse.buildship.core.prefs
new file mode 100644
index 0000000..68c9fab
--- /dev/null
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/.settings/org.eclipse.buildship.core.prefs
@@ -0,0 +1,2 @@
+connection.project.dir=../../../../android
+eclipse.preferences.version=1
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/build.gradle b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/build.gradle
index 7d28df3..f6c5272 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/build.gradle
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/build.gradle
@@ -119,8 +119,9 @@ dependencies {
   implementation "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
 
   // mapbox dependencies
-  implementation "com.mapbox.navigationcore:navigation:3.0.2"
-  implementation "com.mapbox.navigationcore:ui-components:3.0.2"
+  // Mapbox Navigation SDK v3.18.0
+  implementation "com.mapbox.navigationcore:navigation:3.18.0"
+  implementation "com.mapbox.navigationcore:ui-components:3.18.0"
 
   implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
   implementation 'androidx.cardview:cardview:1.0.0'
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationView.kt b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationView.kt
index 41a3ba0..2848ab4 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationView.kt
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationView.kt
@@ -3,25 +3,39 @@ package com.mapboxnavigation
 import android.annotation.SuppressLint
 import android.content.res.Configuration
 import android.content.res.Resources
+import android.graphics.BitmapFactory
 import android.util.Log
+import android.view.Choreographer
+import android.view.Gravity
 import android.view.LayoutInflater
 import android.view.View
 import android.widget.FrameLayout
 import com.facebook.react.bridge.Arguments
 import com.facebook.react.uimanager.ThemedReactContext
 import com.facebook.react.uimanager.events.RCTEventEmitter
+import com.google.gson.JsonObject
 import com.mapbox.api.directions.v5.DirectionsCriteria
-import com.mapbox.api.directions.v5.models.DirectionsWaypoint
 import com.mapbox.api.directions.v5.models.RouteOptions
 import com.mapbox.bindgen.Expected
 import com.mapbox.common.location.Location
+import com.mapbox.geojson.Feature
+import com.mapbox.geojson.FeatureCollection
+import com.mapbox.geojson.LineString
 import com.mapbox.geojson.Point
 import com.mapbox.maps.CameraOptions
 import com.mapbox.maps.EdgeInsets
 import com.mapbox.maps.ImageHolder
+import com.mapbox.maps.LayerPosition
+import com.mapbox.maps.RenderedQueryGeometry
+import com.mapbox.maps.RenderedQueryOptions
+import com.mapbox.maps.ScreenCoordinate
 import com.mapbox.maps.plugin.LocationPuck2D
 import com.mapbox.maps.plugin.animation.camera
+import com.mapbox.maps.plugin.compass.compass
+import com.mapbox.maps.plugin.gestures.addOnMapClickListener
+import com.mapbox.maps.plugin.animation.MapAnimationOptions
 import com.mapbox.maps.plugin.locationcomponent.location
+import com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI
 import com.mapbox.navigation.base.TimeFormat
 import com.mapbox.navigation.base.extensions.applyDefaultNavigationOptions
 import com.mapbox.navigation.base.extensions.applyLanguageAndVoiceUnitOptions
@@ -50,24 +64,24 @@ import com.mapbox.navigation.tripdata.progress.model.EstimatedTimeToArrivalForma
 import com.mapbox.navigation.tripdata.progress.model.PercentDistanceTraveledFormatter
 import com.mapbox.navigation.tripdata.progress.model.TimeRemainingFormatter
 import com.mapbox.navigation.tripdata.progress.model.TripProgressUpdateFormatter
+import com.mapbox.navigation.tripdata.speedlimit.api.MapboxSpeedInfoApi
 import com.mapbox.navigation.ui.base.util.MapboxNavigationConsumer
 import com.mapbox.navigation.ui.components.maneuver.model.ManeuverPrimaryOptions
 import com.mapbox.navigation.ui.components.maneuver.model.ManeuverSecondaryOptions
 import com.mapbox.navigation.ui.components.maneuver.model.ManeuverSubOptions
 import com.mapbox.navigation.ui.components.maneuver.model.ManeuverViewOptions
 import com.mapbox.navigation.ui.components.maneuver.view.MapboxManeuverView
-import com.mapbox.navigation.ui.components.tripprogress.view.MapboxTripProgressView
 import com.mapbox.navigation.ui.maps.NavigationStyles
 import com.mapbox.navigation.ui.maps.camera.NavigationCamera
 import com.mapbox.navigation.ui.maps.camera.data.MapboxNavigationViewportDataSource
 import com.mapbox.navigation.ui.maps.camera.lifecycle.NavigationBasicGesturesHandler
 import com.mapbox.navigation.ui.maps.camera.state.NavigationCameraState
-import com.mapbox.navigation.ui.maps.camera.transition.NavigationCameraTransitionOptions
 import com.mapbox.navigation.ui.maps.location.NavigationLocationProvider
 import com.mapbox.navigation.ui.maps.route.RouteLayerConstants.TOP_LEVEL_ROUTE_LINE_LAYER_ID
 import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowApi
 import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowView
 import com.mapbox.navigation.ui.maps.route.arrow.model.RouteArrowOptions
+import com.mapbox.navigation.ui.maps.route.callout.api.DefaultRouteCalloutAdapter
 import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineApi
 import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineView
 import com.mapbox.navigation.ui.maps.route.line.model.MapboxRouteLineApiOptions
@@ -80,41 +94,58 @@ import com.mapbox.navigation.voice.model.SpeechError
 import com.mapbox.navigation.voice.model.SpeechValue
 import com.mapbox.navigation.voice.model.SpeechVolume
 import com.mapboxnavigation.databinding.NavigationViewBinding
+import java.text.Normalizer
+import java.text.SimpleDateFormat
+import java.util.Calendar
 import java.util.Locale
 
+/** Ponto de radar para exibi√ß√£o no mapa (id, coordenadas, limite de velocidade, tipo). */
+data class RadarPoint(
+        val id: String,
+        val latitude: Double,
+        val longitude: Double,
+        val speedLimit: Double? = null,
+        val type: String? = null // Tipo do radar: "semaforico", "fixo", "m√≥vel", etc.
+)
+
 @SuppressLint("ViewConstructor")
-class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout(context.baseContext) {
+@OptIn(ExperimentalPreviewMapboxNavigationAPI::class)
+class MapboxNavigationView(private val context: ThemedReactContext) :
+        FrameLayout(context.baseContext) {
   private companion object {
     private const val BUTTON_ANIMATION_DURATION = 1500L
   }
 
   private var origin: Point? = null
   private var destination: Point? = null
-  private var destinationTitle: String = "Destination"
+  private var destinationTitle: String = "Destino"
   private var waypoints: List<Point> = listOf()
   private var waypointLegs: List<WaypointLegs> = listOf()
-  private var distanceUnit: String = DirectionsCriteria.IMPERIAL
-  private var locale = Locale.getDefault()
+  private var distanceUnit: String = DirectionsCriteria.METRIC
+  private var locale = Locale("pt", "BR")
 
-  /**
-   * Bindings to the example layout.
-   */
-  private var binding: NavigationViewBinding = NavigationViewBinding.inflate(LayoutInflater.from(context), this, true)
+  /** Quando definido, instru√ß√µes de voz s√£o enviadas ao JS (onVoiceInstructionText) para usar react-native-tts com a voz do usu√°rio. */
+  private var ttsVoiceId: String? = null
+  /** Uma vez true, todas as instru√ß√µes de rota v√£o para o JS (voz do app); evita Mapbox sobrescrever ap√≥s in√≠cio da navega√ß√£o. */
+  private var useAppVoicePreferred: Boolean = false
+
+  /** Bindings to the example layout. */
+  private var binding: NavigationViewBinding =
+          NavigationViewBinding.inflate(LayoutInflater.from(context), this, true)
 
   /**
-   * Produces the camera frames based on the location and routing data for the [navigationCamera] to execute.
+   * Produces the camera frames based on the location and routing data for the [navigationCamera] to
+   * execute.
    */
   private var viewportDataSource = MapboxNavigationViewportDataSource(binding.mapView.mapboxMap)
 
   /**
    * Used to execute camera transitions based on the data generated by the [viewportDataSource].
-   * This includes transitions from route overview to route following and continuously updating the camera as the location changes.
+   * This includes transitions from route overview to route following and continuously updating the
+   * camera as the location changes.
    */
-  private var navigationCamera = NavigationCamera(
-    binding.mapView.mapboxMap,
-    binding.mapView.camera,
-    viewportDataSource
-  )
+  private var navigationCamera =
+          NavigationCamera(binding.mapView.mapboxMap, binding.mapView.camera, viewportDataSource)
 
   /**
    * Mapbox Navigation entry point. There should only be one instance of this object for the app.
@@ -123,43 +154,74 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
   private var mapboxNavigation: MapboxNavigation? = null
 
   /*
-   * Below are generated camera padding values to ensure that the route fits well on screen while
-   * other elements are overlaid on top of the map (including instruction view, buttons, etc.)
+   * Padding da c√¢mera: estilo Waze ‚Äî modal fixo embaixo, posi√ß√£o do usu√°rio jogada para cima.
+   * Bottom = altura do modal (trip progress + speed + margens); top/laterais m√≠nimos.
+   * Assim a c√¢mera mant√©m o usu√°rio na √°rea vis√≠vel acima do modal, sem sobreposi√ß√£o.
    */
   private val pixelDensity = Resources.getSystem().displayMetrics.density
+  // Overview: rota inteira na tela; bottom um pouco maior para o modal
   private val overviewPadding: EdgeInsets by lazy {
-    EdgeInsets(
-      140.0 * pixelDensity,
-      40.0 * pixelDensity,
-      120.0 * pixelDensity,
-      40.0 * pixelDensity
-    )
+    EdgeInsets(60.0 * pixelDensity, 40.0 * pixelDensity, 200.0 * pixelDensity, 40.0 * pixelDensity)
   }
   private val landscapeOverviewPadding: EdgeInsets by lazy {
-    EdgeInsets(
-      30.0 * pixelDensity,
-      380.0 * pixelDensity,
-      110.0 * pixelDensity,
-      20.0 * pixelDensity
-    )
+    EdgeInsets(30.0 * pixelDensity, 380.0 * pixelDensity, 120.0 * pixelDensity, 20.0 * pixelDensity)
   }
+  // Following: usu√°rio na √°rea acima do modal (~220dp para acomodar o floating card + margens)
   private val followingPadding: EdgeInsets by lazy {
-    EdgeInsets(
-      180.0 * pixelDensity,
-      40.0 * pixelDensity,
-      150.0 * pixelDensity,
-      40.0 * pixelDensity
-    )
+    EdgeInsets(70.0 * pixelDensity, 44.0 * pixelDensity, 220.0 * pixelDensity, 44.0 * pixelDensity)
   }
   private val landscapeFollowingPadding: EdgeInsets by lazy {
-    EdgeInsets(
-      30.0 * pixelDensity,
-      380.0 * pixelDensity,
-      110.0 * pixelDensity,
-      40.0 * pixelDensity
-    )
+    EdgeInsets(40.0 * pixelDensity, 400.0 * pixelDensity, 140.0 * pixelDensity, 40.0 * pixelDensity)
   }
 
+  // Properties for radar functionality
+  private var baseRadars: List<RadarPoint> = listOf()
+  private var overlayRadars: List<RadarPoint> = listOf()
+  /** URL do GeoJSON (ex: https://api/radars/geojson) ‚Äî nativo carrega direto, sem bridge */
+  private var radarsGeoJsonUrl: String? = null
+  private var radars: List<RadarPoint> = listOf()
+  private var filteredRadars: List<RadarPoint> = listOf() // Radares filtrados pr√≥ximos √† rota
+  private var nearbyRadarIds: Set<String> = setOf()
+  private val loadedIconNames = mutableSetOf<String>()
+  private var additionalBottomPadding: Double = 0.0
+  private var lastAppliedAdditionalPadding: Double = 0.0
+  private var isDestroyed: Boolean = false
+  @Volatile private var isUpdatingRadars: Boolean = false // Flag for threading safety
+  private var hasPendingUpdate: Boolean = false // If an update was requested during processing
+  private var isStyleLoading: Boolean = false
+  private val throttleHandler = android.os.Handler(android.os.Looper.getMainLooper())
+  private var throttledUpdateRunnable: Runnable? = null
+  private var imageMissingListenerRegistered: Boolean = false
+  private var alternativeRoutes: List<NavigationRoute> = listOf()
+  private var currentRouteIndex: Int = 0
+  private var currentRoute: NavigationRoute? = null // Rota atual para filtrar radares
+  private var navigationInitialized: Boolean = false
+  private var isCameraInIdleMode: Boolean = false
+  private var lastAutoRecenterTime: Long = 0
+  private var isManualOverview: Boolean = false
+  private var initialFocusHandled: Boolean = false
+
+  // Pulse animation for radar highlight
+  private val pulseHandler = android.os.Handler(android.os.Looper.getMainLooper())
+  private var pulseAnimationRunnable: Runnable? = null
+  private var pulseAnimationValue = 0f // 0.0 to 1.0
+  private var lastRadarsSignature: String = ""
+  private var lastNearbyRadarIdsHash: Int = 0
+  private var lastAppliedRadarsGeoJsonHash: Int = 0
+  private var lastStyleUpdateTimeMs: Long = 0
+  private val STYLE_UPDATE_MIN_INTERVAL_MS = 1200L
+
+  // Auto-recenter timer logic
+  private val autoRecenterHandler = android.os.Handler(android.os.Looper.getMainLooper())
+  private var autoRecenterRunnable: Runnable? = null
+  private val AUTO_RECENTER_DELAY = 10000L // 10 segundos
+
+  // Throttle eventos enviados ao JS para evitar travamento (bridge n√£o aguenta dezenas por segundo)
+  private var lastOnLocationChangeEmitTimeMs: Long = 0
+  private val LOCATION_CHANGE_EMIT_INTERVAL_MS = 500L
+  private var lastOnRouteProgressEmitTimeMs: Long = 0
+  private val ROUTE_PROGRESS_EMIT_INTERVAL_MS = 1000L
+
   /**
    * Generates updates for the [MapboxManeuverView] to display the upcoming maneuver instructions
    * and remaining distance to the maneuver point.
@@ -167,12 +229,26 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
   private lateinit var maneuverApi: MapboxManeuverApi
 
   /**
-   * Generates updates for the [MapboxTripProgressView] that include remaining time and distance to the destination.
+   * Generates updates for the [MapboxTripProgressView] that include remaining time and distance to
+   * the destination.
+   */
+  private var tripProgressApi: MapboxTripProgressApi? = null
+
+  /**
+   * Speed Limit API: formata dados de limite de velocidade para o MapboxSpeedInfoView. Ver:
+   * https://docs.mapbox.com/android/navigation/guides/ui-components/speed-limit/
    */
-  private lateinit var tripProgressApi: MapboxTripProgressApi
+  private val speedInfoApi: MapboxSpeedInfoApi by lazy { MapboxSpeedInfoApi() }
+
+  /** Op√ß√µes de formata√ß√£o de dist√¢ncia (usadas tamb√©m pelo Speed Limit API). */
+  private var distanceFormatterOptions: DistanceFormatterOptions? = null
+
+  /** Volume da voz (0f a 1f). Respeitado quando n√£o est√° mute. */
+  private var voiceVolume: Float = 1f
 
   /**
-   * Stores and updates the state of whether the voice instructions should be played as they come or muted.
+   * Stores and updates the state of whether the voice instructions should be played as they come or
+   * muted.
    */
   private var isVoiceInstructionsMuted = false
     set(value) {
@@ -182,139 +258,158 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
         voiceInstructionsPlayer?.volume(SpeechVolume(0f))
       } else {
         binding.soundButton.unmuteAndExtend(BUTTON_ANIMATION_DURATION)
-        voiceInstructionsPlayer?.volume(SpeechVolume(1f))
+        voiceInstructionsPlayer?.volume(SpeechVolume(voiceVolume))
       }
     }
 
   /**
-   * Extracts message that should be communicated to the driver about the upcoming maneuver.
-   * When possible, downloads a synthesized audio file that can be played back to the driver.
+   * Extracts message that should be communicated to the driver about the upcoming maneuver. When
+   * possible, downloads a synthesized audio file that can be played back to the driver.
    */
-  private lateinit var speechApi: MapboxSpeechApi
+  private var speechApi: MapboxSpeechApi? = null
 
   /**
-   * Plays the synthesized audio files with upcoming maneuver instructions
-   * or uses an on-device Text-To-Speech engine to communicate the message to the driver.
-   * NOTE: do not use lazy initialization for this class since it takes some time to initialize
-   * the system services required for on-device speech synthesis. With lazy initialization
-   * there is a high risk that said services will not be available when the first instruction
-   * has to be played. [MapboxVoiceInstructionsPlayer] should be instantiated in
-   * `Activity#onCreate`.
+   * Plays the synthesized audio files with upcoming maneuver instructions or uses an on-device
+   * Text-To-Speech engine to communicate the message to the driver. NOTE: do not use lazy
+   * initialization for this class since it takes some time to initialize the system services
+   * required for on-device speech synthesis. With lazy initialization there is a high risk that
+   * said services will not be available when the first instruction has to be played.
+   * [MapboxVoiceInstructionsPlayer] should be instantiated in `Activity#onCreate`.
    */
   private var voiceInstructionsPlayer: MapboxVoiceInstructionsPlayer? = null
 
-  /**
-   * Observes when a new voice instruction should be played.
-   */
+  /** Observes when a new voice instruction should be played. */
   private val voiceInstructionsObserver = VoiceInstructionsObserver { voiceInstructions ->
-    speechApi.generate(voiceInstructions, speechCallback)
+    speechApi?.generate(voiceInstructions, speechCallback)
   }
 
   /**
-   * Based on whether the synthesized audio file is available, the callback plays the file
-   * or uses the fall back which is played back using the on-device Text-To-Speech engine.
+   * Based on whether the synthesized audio file is available, the callback plays the file or uses
+   * the fall back which is played back using the on-device Text-To-Speech engine.
    */
   private val speechCallback =
-    MapboxNavigationConsumer<Expected<SpeechError, SpeechValue>> { expected ->
-      expected.fold(
-        { error ->
-          // play the instruction via fallback text-to-speech engine
-          voiceInstructionsPlayer?.play(
-            error.fallback,
-            voiceInstructionsPlayerCallback
-          )
-        },
-        { value ->
-          // play the sound file from the external generator
-          voiceInstructionsPlayer?.play(
-            value.announcement,
-            voiceInstructionsPlayerCallback
-          )
-        }
-      )
-    }
+          MapboxNavigationConsumer<Expected<SpeechError, SpeechValue>> { expected ->
+            val useAppVoice = useAppVoicePreferred || !ttsVoiceId.isNullOrBlank()
+            if (useAppVoice) {
+              val text: String? = expected.fold(
+                      { error ->
+                        val f = error.fallback
+                        (f.announcement.takeIf { !it.isNullOrBlank() } ?: f.ssmlAnnouncement) ?: ""
+                      },
+                      { value ->
+                        val a = value.announcement
+                        (a.announcement.takeIf { !it.isNullOrBlank() } ?: a.ssmlAnnouncement) ?: ""
+                      }
+              )
+              if (text != null && text.isNotBlank()) {
+                val ev = com.facebook.react.bridge.Arguments.createMap()
+                ev.putString("text", text)
+                safeEmitEvent("onVoiceInstructionText", ev)
+              }
+              expected.fold(
+                      { _ -> Unit },
+                      { value -> Unit.also { speechApi?.clean(value.announcement) } }
+              )
+            } else {
+              expected.fold(
+                      { error ->
+                        voiceInstructionsPlayer?.play(error.fallback, voiceInstructionsPlayerCallback)
+                        Unit
+                      },
+                      { value ->
+                        voiceInstructionsPlayer?.play(
+                                value.announcement,
+                                voiceInstructionsPlayerCallback
+                        )
+                        Unit
+                      }
+              )
+            }
+          }
 
   /**
-   * When a synthesized audio file was downloaded, this callback cleans up the disk after it was played.
+   * When a synthesized audio file was downloaded, this callback cleans up the disk after it was
+   * played.
    */
   private val voiceInstructionsPlayerCallback =
-    MapboxNavigationConsumer<SpeechAnnouncement> { value ->
-      // remove already consumed file to free-up space
-      speechApi.clean(value)
-    }
+          MapboxNavigationConsumer<SpeechAnnouncement> { value ->
+            // remove already consumed file to free-up space
+            speechApi?.clean(value)
+          }
 
   /**
-   * [NavigationLocationProvider] is a utility class that helps to provide location updates generated by the Navigation SDK
-   * to the Maps SDK in order to update the user location indicator on the map.
+   * [NavigationLocationProvider] is a utility class that helps to provide location updates
+   * generated by the Navigation SDK to the Maps SDK in order to update the user location indicator
+   * on the map.
    */
   private val navigationLocationProvider = NavigationLocationProvider()
 
+  // Observers
+  private val offRouteObserver =
+          com.mapbox.navigation.core.trip.session.OffRouteObserver { offRoute ->
+            if (offRoute) {
+              Log.d("MapboxNavigationView", "üöó Usu√°rio saiu da rota")
+              val event = Arguments.createMap()
+              event.putBoolean("offRoute", true)
+              safeEmitEvent("onOffRoute", event)
+            }
+          }
+
   /**
-   * RouteLine: Additional route line options are available through the
-   * [MapboxRouteLineViewOptions] and [MapboxRouteLineApiOptions].
-   * Notice here the [MapboxRouteLineViewOptions.routeLineBelowLayerId] option. The map is made up of layers. In this
-   * case the route line will be placed below the "road-label" layer which is a good default
+   * RouteLine: Additional route line options are available through the [MapboxRouteLineViewOptions]
+   * and [MapboxRouteLineApiOptions]. Notice here the
+   * [MapboxRouteLineViewOptions.routeLineBelowLayerId] option. The map is made up of layers. In
+   * this case the route line will be placed below the "road-label" layer which is a good default
    * for the most common Mapbox navigation related maps. You should consider if this should be
    * changed for your use case especially if you are using a custom map style.
    */
   private val routeLineViewOptions: MapboxRouteLineViewOptions by lazy {
     MapboxRouteLineViewOptions.Builder(context)
-      /**
-       * Route line related colors can be customized via the [RouteLineColorResources]. If using the
-       * default colors the [RouteLineColorResources] does not need to be set as seen here, the
-       * defaults will be used internally by the builder.
-       */
-      .routeLineColorResources(RouteLineColorResources.Builder().build())
-      .routeLineBelowLayerId("road-label-navigation")
-      .build()
+            /**
+             * Route line related colors can be customized via the [RouteLineColorResources]. If
+             * using the default colors the [RouteLineColorResources] does not need to be set as
+             * seen here, the defaults will be used internally by the builder.
+             */
+            .routeLineColorResources(RouteLineColorResources.Builder().build())
+            .routeLineBelowLayerId("road-label-navigation")
+            .build()
   }
 
   private val routeLineApiOptions: MapboxRouteLineApiOptions by lazy {
-    MapboxRouteLineApiOptions.Builder()
-      .build()
+    MapboxRouteLineApiOptions.Builder().isRouteCalloutsEnabled(true).build()
   }
 
   /**
-   * RouteLine: This class is responsible for rendering route line related mutations generated
-   * by the [routeLineApi]
+   * RouteLine: This class is responsible for rendering route line related mutations generated by
+   * the [routeLineApi]
    */
-  private val routeLineView by lazy {
-    MapboxRouteLineView(routeLineViewOptions)
-  }
-
+  private val routeLineView by lazy { MapboxRouteLineView(routeLineViewOptions) }
 
   /**
    * RouteLine: This class is responsible for generating route line related data which must be
    * rendered by the [routeLineView] in order to visualize the route line on the map.
    */
-  private val routeLineApi: MapboxRouteLineApi by lazy {
-    MapboxRouteLineApi(routeLineApiOptions)
-  }
+  private val routeLineApi: MapboxRouteLineApi by lazy { MapboxRouteLineApi(routeLineApiOptions) }
 
   /**
-   * RouteArrow: This class is responsible for generating data related to maneuver arrows. The
-   * data generated must be rendered by the [routeArrowView] in order to apply mutations to
-   * the map.
+   * RouteArrow: This class is responsible for generating data related to maneuver arrows. The data
+   * generated must be rendered by the [routeArrowView] in order to apply mutations to the map.
    */
-  private val routeArrowApi: MapboxRouteArrowApi by lazy {
-    MapboxRouteArrowApi()
-  }
+  private val routeArrowApi: MapboxRouteArrowApi by lazy { MapboxRouteArrowApi() }
 
   /**
-   * RouteArrow: Customization of the maneuver arrow(s) can be done using the
-   * [RouteArrowOptions]. Here the above layer ID is used to determine where in the map layer
-   * stack the arrows appear. Above the layer of the route traffic line is being used here. Your
-   * use case may necessitate adjusting this to a different layer position.
+   * RouteArrow: Customization of the maneuver arrow(s) can be done using the [RouteArrowOptions].
+   * Here the above layer ID is used to determine where in the map layer stack the arrows appear.
+   * Above the layer of the route traffic line is being used here. Your use case may necessitate
+   * adjusting this to a different layer position.
    */
   private val routeArrowOptions by lazy {
-    RouteArrowOptions.Builder(context)
-      .withAboveLayerId(TOP_LEVEL_ROUTE_LINE_LAYER_ID)
-      .build()
+    RouteArrowOptions.Builder(context).withAboveLayerId(TOP_LEVEL_ROUTE_LINE_LAYER_ID).build()
   }
 
   /**
-   * RouteArrow: This class is responsible for rendering the arrow related mutations generated
-   * by the [routeArrowApi]
+   * RouteArrow: This class is responsible for rendering the arrow related mutations generated by
+   * the [routeArrowApi]
    */
   private val routeArrowView: MapboxRouteArrowView by lazy {
     MapboxRouteArrowView(routeArrowOptions)
@@ -323,54 +418,133 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
   /**
    * Gets notified with location updates.
    *
-   * Exposes raw updates coming directly from the location services
-   * and the updates enhanced by the Navigation SDK (cleaned up and matched to the road).
+   * Exposes raw updates coming directly from the location services and the updates enhanced by the
+   * Navigation SDK (cleaned up and matched to the road).
    */
-  private val locationObserver = object : LocationObserver {
-    var firstLocationUpdateReceived = false
-
-    override fun onNewRawLocation(rawLocation: Location) {
-      // not handled
+  private val locationObserver =
+          object : LocationObserver {
+            var firstLocationUpdateReceived = false
+
+            override fun onNewRawLocation(rawLocation: Location) {
+              // not handled
+            }
+
+            override fun onNewLocationMatcherResult(locationMatcherResult: LocationMatcherResult) {
+              val enhancedLocation = locationMatcherResult.enhancedLocation
+              // update location puck's position on the map
+              navigationLocationProvider.changePosition(
+                      location = enhancedLocation,
+                      keyPoints = locationMatcherResult.keyPoints,
+              )
+
+              // update camera position to account for new location
+              viewportDataSource.onLocationChanged(enhancedLocation)
+              viewportDataSource.evaluate()
+
+              // if this is the first location update the activity has received,
+              // it's best to immediately move the camera to the current user location
+              if (!firstLocationUpdateReceived) {
+                firstLocationUpdateReceived = true
+                Log.d("MapboxNavigationView", "üìç Primeiro sinal: Iniciando em vis√£o geral")
+                navigationCamera.requestNavigationCameraToOverview()
+
+                // OTIMIZA√á√ÉO: Foco autom√°tico inicial ap√≥s 4 segundos (tempo para ver a rota)
+                postDelayed(
+                        {
+                          if (navigationInitialized &&
+                                          !isDestroyed &&
+                                          !isManualOverview &&
+                                          !initialFocusHandled
+                          ) {
+                            Log.d(
+                                    "MapboxNavigationView",
+                                    "üïí Foco autom√°tico inicial (delay p√≥s-sinal)"
+                            )
+                            navigationCamera.requestNavigationCameraToFollowing()
+                            initialFocusHandled = true
+                          }
+                        },
+                        4000
+                )
+              }
+
+              // Throttle: enviar onLocationChange ao JS no m√°x. a cada 500ms (evita travamento da
+              // bridge)
+              val nowMs = System.currentTimeMillis()
+              if (nowMs - lastOnLocationChangeEmitTimeMs >= LOCATION_CHANGE_EMIT_INTERVAL_MS) {
+                lastOnLocationChangeEmitTimeMs = nowMs
+                val event = Arguments.createMap()
+                event.putDouble("longitude", enhancedLocation.longitude)
+                event.putDouble("latitude", enhancedLocation.latitude)
+                event.putDouble("heading", enhancedLocation.bearing ?: 0.0)
+                event.putDouble("accuracy", enhancedLocation.horizontalAccuracy ?: 0.0)
+                safeEmitEvent("onLocationChange", event)
+              }
+
+              // OTIMIZA√á√ÉO: Recentrar autom√°tico se o usu√°rio se mover e a c√¢mera estiver parada
+              // (IDLE)
+              val speed = enhancedLocation.speed // em m/s
+              if (isCameraInIdleMode && !isManualOverview && speed != null && speed > (5.0 / 3.6)
+              ) { // > 5km/h
+                val now = System.currentTimeMillis()
+                if (now - lastAutoRecenterTime > 5000) { // Throttle de 5s
+                  Log.d(
+                          "MapboxNavigationView",
+                          "üöó Movimento detectado ($speed m/s), recentrando c√¢mera automaticamente"
+                  )
+                  navigationCamera.requestNavigationCameraToFollowing()
+                  lastAutoRecenterTime = now
+                }
+              }
+
+              // Speed: sempre vis√≠vel ‚Äî limite da via (SpeedInfoView) ou velocidade atual
+              // (TextView)
+              val opts = distanceFormatterOptions
+              if (opts != null) {
+                try {
+                  val value =
+                          speedInfoApi.updatePostedAndCurrentSpeed(
+                                  locationMatcherResult,
+                                  opts,
+                          )
+                  value?.let {
+                    binding.speedLimitView.render(it)
+                    binding.speedLimitView.visibility = View.VISIBLE
+                  }
+                } catch (e: Exception) {
+                  Log.w("MapboxNavigationView", "Speed update: ${e.message}")
+                }
+              }
+            }
+          }
+
+  /** Gets notified with progress along the currently active route. */
+  private val routeProgressObserver = RouteProgressObserver { routeProgress ->
+    // Atualizar rota atual se necess√°rio (pode mudar durante navega√ß√£o)
+    val currentNavRoute = routeProgress.navigationRoute
+    if (currentNavRoute != currentRoute) {
+      currentRoute = currentNavRoute
+      // N√ÉO filtrar radares - mostrar todos sempre
     }
 
-    override fun onNewLocationMatcherResult(locationMatcherResult: LocationMatcherResult) {
-      val enhancedLocation = locationMatcherResult.enhancedLocation
-      // update location puck's position on the map
-      navigationLocationProvider.changePosition(
-        location = enhancedLocation,
-        keyPoints = locationMatcherResult.keyPoints,
-      )
-
-      // update camera position to account for new location
-      viewportDataSource.onLocationChanged(enhancedLocation)
-      viewportDataSource.evaluate()
-
-      // if this is the first location update the activity has received,
-      // it's best to immediately move the camera to the current user location
-      if (!firstLocationUpdateReceived) {
-        firstLocationUpdateReceived = true
-        navigationCamera.requestNavigationCameraToOverview(
-          stateTransitionOptions = NavigationCameraTransitionOptions.Builder()
-            .maxDuration(0) // instant transition
-            .build()
-        )
+    // update the current road name display
+    try {
+      val leg = routeProgress.currentLegProgress
+      val step = leg?.currentStepProgress?.step
+      val streetName = step?.name()
+
+      binding.roadNameText?.let { view ->
+        if (!streetName.isNullOrEmpty()) {
+          view.text = streetName
+          view.visibility = View.VISIBLE
+        } else {
+          view.visibility = View.GONE
+        }
       }
-
-      val event = Arguments.createMap()
-      event.putDouble("longitude", enhancedLocation.longitude)
-      event.putDouble("latitude", enhancedLocation.latitude)
-      event.putDouble("heading", enhancedLocation.bearing ?: 0.0)
-      event.putDouble("accuracy", enhancedLocation.horizontalAccuracy ?: 0.0)
-      context
-        .getJSModule(RCTEventEmitter::class.java)
-        .receiveEvent(id, "onLocationChange", event)
+    } catch (e: Exception) {
+      Log.w("MapboxNavigationView", "Erro ao atualizar nome da rua: ${e.message}")
     }
-  }
 
-  /**
-   * Gets notified with progress along the currently active route.
-   */
-  private val routeProgressObserver = RouteProgressObserver { routeProgress ->
     // update the camera position to account for the progressed fragment of the route
     if (routeProgress.fractionTraveled.toDouble() != 0.0) {
       viewportDataSource.onRouteProgressChanged(routeProgress)
@@ -378,57 +552,112 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
     viewportDataSource.evaluate()
 
     // draw the upcoming maneuver arrow on the map
-    val style = binding.mapView.mapboxMap.style
-    if (style != null) {
-      val maneuverArrowResult = routeArrowApi.addUpcomingManeuverArrow(routeProgress)
-      routeArrowView.renderManeuverUpdate(style, maneuverArrowResult)
+    try {
+      val style = binding.mapView.mapboxMap.style
+      if (style != null) {
+        val maneuverArrowResult = routeArrowApi.addUpcomingManeuverArrow(routeProgress)
+        routeArrowView.renderManeuverUpdate(style, maneuverArrowResult)
+      }
+    } catch (e: Exception) {
+      Log.w("MapboxNavigationView", "Erro ao renderizar seta de manobra: ${e.message}")
     }
 
     // update top banner with maneuver instructions
-    val maneuvers = maneuverApi.getManeuvers(routeProgress)
-    maneuvers.fold(
-      { error ->
-        Log.w("Maneuvers error:", error.throwable)
-      },
-      {
-        val maneuverViewOptions = ManeuverViewOptions.Builder()
-          .primaryManeuverOptions(
-            ManeuverPrimaryOptions.Builder()
-              .textAppearance(R.style.PrimaryManeuverTextAppearance)
-              .build()
-          )
-          .secondaryManeuverOptions(
-            ManeuverSecondaryOptions.Builder()
-              .textAppearance(R.style.ManeuverTextAppearance)
-              .build()
-          )
-          .subManeuverOptions(
-            ManeuverSubOptions.Builder()
-              .textAppearance(R.style.ManeuverTextAppearance)
-              .build()
-          )
-          .stepDistanceTextAppearance(R.style.StepDistanceRemainingAppearance)
-          .build()
-
-        binding.maneuverView.visibility = View.VISIBLE
-        binding.maneuverView.updateManeuverViewOptions(maneuverViewOptions)
-        binding.maneuverView.renderManeuvers(maneuvers)
+    try {
+      if (::maneuverApi.isInitialized && binding.maneuverView != null) {
+        val maneuvers = maneuverApi.getManeuvers(routeProgress)
+        maneuvers.fold(
+                { error -> Log.w("Maneuvers error:", error.throwable) },
+                {
+                  val maneuverViewOptions =
+                          ManeuverViewOptions.Builder()
+                                  .primaryManeuverOptions(
+                                          ManeuverPrimaryOptions.Builder()
+                                                  .textAppearance(
+                                                          R.style.PrimaryManeuverTextAppearance
+                                                  )
+                                                  .build()
+                                  )
+                                  .secondaryManeuverOptions(
+                                          ManeuverSecondaryOptions.Builder()
+                                                  .textAppearance(R.style.ManeuverTextAppearance)
+                                                  .build()
+                                  )
+                                  .subManeuverOptions(
+                                          ManeuverSubOptions.Builder()
+                                                  .textAppearance(R.style.ManeuverTextAppearance)
+                                                  .build()
+                                  )
+                                  .stepDistanceTextAppearance(
+                                          R.style.StepDistanceRemainingAppearance
+                                  )
+                                  .build()
+
+                  // Mostrar instru√ß√£o de manobra (layout tem maneuverView)
+                  binding.maneuverView.updateManeuverViewOptions(maneuverViewOptions)
+                  binding.maneuverView.renderManeuvers(maneuvers)
+                  Unit
+                }
+        )
       }
-    )
+    } catch (e: Exception) {
+      Log.w("MapboxNavigationView", "Erro ao atualizar maneuver: ${e.message}")
+    }
 
-    // update bottom trip progress summary
-    binding.tripProgressView.render(
-      tripProgressApi.getTripProgress(routeProgress)
-    )
+    // update trip progress: duas linhas (tempo em destaque + dist√¢ncia ‚Äî ETA), estilo primeira
+    // imagem
+    updateTripProgressUi(routeProgress)
 
-    val event = Arguments.createMap()
-    event.putDouble("distanceTraveled", routeProgress.distanceTraveled.toDouble())
-    event.putDouble("durationRemaining", routeProgress.durationRemaining)
-    event.putDouble("fractionTraveled", routeProgress.fractionTraveled.toDouble())
-    event.putDouble("distanceRemaining", routeProgress.distanceRemaining.toDouble())
-    context
-      .getJSModule(RCTEventEmitter::class.java)
-      .receiveEvent(id, "onRouteProgressChange", event)
+    // Throttle: enviar onRouteProgressChange ao JS no m√°x. a cada 1s (evita travamento da bridge)
+    val nowMs = System.currentTimeMillis()
+    if (nowMs - lastOnRouteProgressEmitTimeMs >= ROUTE_PROGRESS_EMIT_INTERVAL_MS) {
+      lastOnRouteProgressEmitTimeMs = nowMs
+      val event = Arguments.createMap()
+      event.putDouble("distanceTraveled", routeProgress.distanceTraveled.toDouble())
+      event.putDouble("durationRemaining", routeProgress.durationRemaining)
+      event.putDouble("fractionTraveled", routeProgress.fractionTraveled.toDouble())
+      event.putDouble("distanceRemaining", routeProgress.distanceRemaining.toDouble())
+      safeEmitEvent("onRouteProgressChange", event)
+    }
+  }
+
+  /** Atualiza a barra de trip progress manualmente usando TextViews personalizados */
+  private fun updateTripProgressUi(routeProgress: RouteProgress) {
+    try {
+      val distanceRemaining = routeProgress.distanceRemaining
+      val durationRemaining = routeProgress.durationRemaining
+
+      // 1. Duranc√£o (Tempo restante)
+      val minutes = (durationRemaining / 60).toInt()
+      val durationText =
+              when {
+                minutes < 1 -> "Pr√≥ximo"
+                minutes < 60 -> "$minutes min"
+                else -> {
+                  val hours = minutes / 60
+                  val remainingMinutes = minutes % 60
+                  "${hours}h ${remainingMinutes}m"
+                }
+              }
+      binding.timeRemainingText.text = durationText
+
+      // 2. Dist√¢ncia restante
+      val distanceText =
+              if (distanceRemaining < 1000) {
+                "${distanceRemaining.toInt()} m"
+              } else {
+                String.format("%.1f km", distanceRemaining / 1000.0)
+              }
+      binding.distanceRemainingText.text = distanceText
+
+      // 3. ETA (Hora de chegada)
+      val calendar = Calendar.getInstance()
+      calendar.add(Calendar.SECOND, durationRemaining.toInt())
+      val sdf = SimpleDateFormat("HH:mm", Locale.getDefault())
+      binding.etaText.text = sdf.format(calendar.time)
+    } catch (e: Exception) {
+      Log.w("MapboxNavigationView", "updateTripProgressUi error: ${e.message}")
+    }
   }
 
   /**
@@ -436,39 +665,82 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
    *
    * A change can mean:
    * - routes get changed with [MapboxNavigation.setNavigationRoutes]
-   * - routes annotations get refreshed (for example, congestion annotation that indicate the live traffic along the route)
+   * - routes annotations get refreshed (for example, congestion annotation that indicate the live
+   * traffic along the route)
    * - driver got off route and a reroute was executed
    */
   private val routesObserver = RoutesObserver { routeUpdateResult ->
-    if (routeUpdateResult.navigationRoutes.isNotEmpty()) {
-      // generate route geometries asynchronously and render them
-      routeLineApi.setNavigationRoutes(
-        routeUpdateResult.navigationRoutes
-      ) { value ->
-        binding.mapView.mapboxMap.style?.apply {
-          routeLineView.renderRouteDrawData(this, value)
+    try {
+      if (!isValidForOperations()) return@RoutesObserver
+
+      if (routeUpdateResult.navigationRoutes.isNotEmpty()) {
+        // Armazenar rota atual para refer√™ncia
+        currentRoute = routeUpdateResult.navigationRoutes.first()
+
+        // N√ÉO filtrar radares - mostrar todos sempre
+
+        // generate route geometries with SDK default callouts (duration/ETA per route)
+        val style = binding.mapView.mapboxMap.style
+        if (style != null) {
+          val alternativesMetadata =
+                  mapboxNavigation?.getAlternativeMetadataFor(routeUpdateResult.navigationRoutes)
+          routeLineApi.setNavigationRoutes(
+                  routeUpdateResult.navigationRoutes,
+                  alternativesMetadata ?: emptyList()
+          ) { value ->
+            if (binding.mapView != null) {
+              routeLineView.renderRouteDrawData(style, value)
+            }
+          }
         }
-      }
 
-      // update the camera position to account for the new route
-      viewportDataSource.onRouteChanged(routeUpdateResult.navigationRoutes.first())
-      viewportDataSource.evaluate()
-    } else {
-      // remove the route line and route arrow from the map
-      val style = binding.mapView.mapboxMap.style
-      if (style != null) {
-        routeLineApi.clearRouteLine { value ->
-          routeLineView.renderClearRouteLineValue(
-            style,
-            value
-          )
+        // update the camera position to account for the new route
+        viewportDataSource.onRouteChanged(routeUpdateResult.navigationRoutes.first())
+        viewportDataSource.evaluate()
+
+        // Emit onRouteChanged event with updated geometry
+        val activeRoute = routeUpdateResult.navigationRoutes.first()
+        val geometry = activeRoute.directionsRoute.geometry()
+        if (geometry != null) {
+          val event = Arguments.createMap()
+          try {
+            // Convert Polyline to GeoJSON LineString (Precision 6 is standard for Mapbox
+            // Directions)
+            val lineString = LineString.fromPolyline(geometry, 6)
+            event.putString("geometry", lineString.toJson())
+          } catch (e: Exception) {
+            // Fallback if conversion fails (e.g. already GeoJSON)
+            event.putString("geometry", geometry)
+          }
+          safeEmitEvent("onRouteChanged", event)
+        }
+      } else {
+        // Limpar rota atual e mostrar todos os radares
+        currentRoute = null
+        filteredRadars = radars
+        updateRadarsOnMap()
+
+        // remove the route line and route arrow from the map
+        try {
+          val style = binding.mapView.mapboxMap.style
+          if (style != null) {
+            routeLineApi.clearRouteLine { value ->
+              if (binding.mapView != null) {
+                routeLineView.renderClearRouteLineValue(style, value)
+              }
+            }
+            routeArrowView.render(style, routeArrowApi.clearArrows())
+          }
+        } catch (e: Exception) {
+          Log.w("MapboxNavigationView", "Erro ao limpar rota: ${e.message}")
         }
-        routeArrowView.render(style, routeArrowApi.clearArrows())
-      }
 
-      // remove the route reference from camera position evaluations
-      viewportDataSource.clearRouteData()
-      viewportDataSource.evaluate()
+        // remove the route reference from camera position evaluations
+        viewportDataSource.clearRouteData()
+        viewportDataSource.evaluate()
+      }
+    } catch (e: Exception) {
+      Log.w("MapboxNavigationView", "Erro no routesObserver: ${e.message}")
     }
   }
 
@@ -477,156 +749,316 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
   }
 
   private fun onCreate() {
-    // initialize Mapbox Navigation
-    mapboxNavigation = if (MapboxNavigationProvider.isCreated()) {
-      MapboxNavigationProvider.retrieve()
-    } else {
-      MapboxNavigationProvider.create(
-        NavigationOptions.Builder(context)
-          .build()
-      )
+    // initialize Mapbox Navigation v3.18.0 (token lido de res/values ou MapboxOptions)
+    if (!MapboxNavigationProvider.isCreated()) {
+      val navigationOptions = NavigationOptions.Builder(context).build()
+      MapboxNavigationProvider.create(navigationOptions)
     }
+    mapboxNavigation = MapboxNavigationProvider.retrieve()
   }
 
   @SuppressLint("MissingPermission")
   private fun initNavigation() {
     if (origin == null || destination == null) {
-      sendErrorToReact("origin and destination are required")
       return
     }
+    if (navigationInitialized) {
+      return
+    }
+    try {
+      navigationInitialized = true
+      Log.d("MapboxNavigationView", "Iniciando navega√ß√£o: origin=$origin, destination=$destination")
 
-    // Recenter Camera
-    val initialCameraOptions = CameraOptions.Builder()
-      .zoom(14.0)
-      .center(origin)
-      .build()
-    binding.mapView.mapboxMap.setCamera(initialCameraOptions)
+      // Recenter Camera
+      val initialCameraOptions = CameraOptions.Builder().zoom(14.0).center(origin).build()
+      binding.mapView.mapboxMap.setCamera(initialCameraOptions)
 
-    // Start Navigation
-    startNavigation()
+      // Start Navigation
+      startNavigation()
 
-    // set the animations lifecycle listener to ensure the NavigationCamera stops
-    // automatically following the user location when the map is interacted with
-    binding.mapView.camera.addCameraAnimationsLifecycleListener(
-      NavigationBasicGesturesHandler(navigationCamera)
-    )
-    navigationCamera.registerNavigationCameraStateChangeObserver { navigationCameraState ->
-      // shows/hide the recenter button depending on the camera state
-      when (navigationCameraState) {
-        NavigationCameraState.TRANSITION_TO_FOLLOWING,
-        NavigationCameraState.FOLLOWING -> binding.recenter.visibility = View.INVISIBLE
+      // set the animations lifecycle listener to ensure the NavigationCamera stops
+      // automatically following the user location when the map is interacted with
+      binding.mapView.camera.addCameraAnimationsLifecycleListener(
+              NavigationBasicGesturesHandler(navigationCamera)
+      )
+      navigationCamera.registerNavigationCameraStateChangeObserver { navigationCameraState ->
+        // shows/hide the recenter button depending on the camera state
+        when (navigationCameraState) {
+          NavigationCameraState.TRANSITION_TO_FOLLOWING, NavigationCameraState.FOLLOWING -> {
+            binding.recenter.visibility = View.INVISIBLE
+            isCameraInIdleMode = false
+            isManualOverview = false // Reset ao voltar a seguir
+            stopAutoRecenterTimer()
+          }
+          NavigationCameraState.TRANSITION_TO_OVERVIEW,
+          NavigationCameraState.OVERVIEW,
+          NavigationCameraState.IDLE -> {
+            binding.recenter.visibility = View.VISIBLE
+            isCameraInIdleMode = true
+            startAutoRecenterTimer()
+          }
+        }
+      }
 
-        NavigationCameraState.TRANSITION_TO_OVERVIEW,
-        NavigationCameraState.OVERVIEW,
-        NavigationCameraState.IDLE -> binding.recenter.visibility = View.VISIBLE
+      // Remover delay antigo aqui (movido para o locationObserver)
+      // set the padding values depending on screen orientation and visible view layout
+      if (this.resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {
+        viewportDataSource.overviewPadding = landscapeOverviewPadding
+      } else {
+        viewportDataSource.overviewPadding = overviewPadding
+      }
+      if (this.resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {
+        viewportDataSource.followingPadding = landscapeFollowingPadding
+      } else {
+        viewportDataSource.followingPadding = followingPadding
       }
-    }
-    // set the padding values depending on screen orientation and visible view layout
-    if (this.resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {
-      viewportDataSource.overviewPadding = landscapeOverviewPadding
-    } else {
-      viewportDataSource.overviewPadding = overviewPadding
-    }
-    if (this.resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {
-      viewportDataSource.followingPadding = landscapeFollowingPadding
-    } else {
-      viewportDataSource.followingPadding = followingPadding
-    }
 
-    // make sure to use the same DistanceFormatterOptions across different features
-    val unitType = if (distanceUnit == "imperial") UnitType.IMPERIAL else UnitType.METRIC
-    val distanceFormatterOptions = DistanceFormatterOptions.Builder(context)
-      .unitType(unitType)
-      .build()
+      // make sure to use the same DistanceFormatterOptions across different features (incl. Speed
+      // Limit API)
+      val unitType = if (distanceUnit == "imperial") UnitType.IMPERIAL else UnitType.METRIC
+      val options = DistanceFormatterOptions.Builder(context).unitType(unitType).build()
+      distanceFormatterOptions = options
+
+      // initialize maneuver api that feeds the data to the top banner maneuver view
+      maneuverApi = MapboxManeuverApi(MapboxDistanceFormatter(options))
+
+      // initialize bottom progress view
+      tripProgressApi =
+              MapboxTripProgressApi(
+                      TripProgressUpdateFormatter.Builder(context)
+                              .distanceRemainingFormatter(DistanceRemainingFormatter(options))
+                              .timeRemainingFormatter(TimeRemainingFormatter(context))
+                              .percentRouteTraveledFormatter(PercentDistanceTraveledFormatter())
+                              .estimatedTimeToArrivalFormatter(
+                                      EstimatedTimeToArrivalFormatter(
+                                              context,
+                                              TimeFormat.NONE_SPECIFIED
+                                      )
+                              )
+                              .build()
+              )
+
+      // initialize voice instructions api and the voice instruction player (pt-BR)
+      val voiceLanguage = locale.toLanguageTag()
+      speechApi = MapboxSpeechApi(context, voiceLanguage)
+      try {
+        voiceInstructionsPlayer = MapboxVoiceInstructionsPlayer(context, voiceLanguage)
+      } catch (e: Exception) {
+        Log.w("MapboxNavigationView", "Voice instructions n√£o dispon√≠veis: ${e.message}")
+        voiceInstructionsPlayer = null
+      }
 
-    // initialize maneuver api that feeds the data to the top banner maneuver view
-    maneuverApi = MapboxManeuverApi(
-      MapboxDistanceFormatter(distanceFormatterOptions)
-    )
+      // load map style
+      binding.mapView.mapboxMap.loadStyle(NavigationStyles.NAVIGATION_DAY_STYLE) { style ->
+        // Ensure that the route line related layers are present before the route arrow
+        routeLineView.initializeLayers(style)
+        // Callouts padr√£o do SDK: bolha com dura√ß√£o/ETA na rota
+        try {
+          routeLineView.setCalloutAdapter(
+                  binding.mapView.viewAnnotationManager,
+                  DefaultRouteCalloutAdapter(context)
+          )
+        } catch (e: Exception) {
+          Log.w("MapboxNavigationView", "Erro ao configurar callouts: ${e.message}")
+        }
 
-    // initialize bottom progress view
-    tripProgressApi = MapboxTripProgressApi(
-      TripProgressUpdateFormatter.Builder(context)
-        .distanceRemainingFormatter(
-          DistanceRemainingFormatter(distanceFormatterOptions)
-        )
-        .timeRemainingFormatter(
-          TimeRemainingFormatter(context)
-        )
-        .percentRouteTraveledFormatter(
-          PercentDistanceTraveledFormatter()
-        )
-        .estimatedTimeToArrivalFormatter(
-          EstimatedTimeToArrivalFormatter(context, TimeFormat.NONE_SPECIFIED)
-        )
-        .build()
-    )
-    // initialize voice instructions api and the voice instruction player
-    speechApi = MapboxSpeechApi(
-      context,
-      locale.language
-    )
-    voiceInstructionsPlayer = MapboxVoiceInstructionsPlayer(
-      context,
-      locale.language
-    )
+        // Carregar imagens de radar (sem fallback din√¢mico de image-missing)
+        try {
+          loadRadarImages(style)
+          // Atualizar radares: bridge (radars) OU URL (radarsGeoJsonUrl)
+          val urlForRadars = radarsGeoJsonUrl
+          if (radars.isNotEmpty() || (urlForRadars != null && urlForRadars.isNotBlank())) {
+            updateRadarsOnMap()
+          }
+        } catch (e: Exception) {
+          Log.e("MapboxNavigationView", "Erro ao inicializar radares no estilo", e)
+        }
+        // Compass: posi√ß√£o abaixo dos controles (recenter/overview/sound), canto inferior direito
+        try {
+          val density = pixelDensity.toFloat()
+          binding.mapView.compass.updateSettings {
+            position = Gravity.BOTTOM or Gravity.START
+            marginRight = 16f * density
+            marginBottom = 380f * density
+            marginTop = 4f * density
+            marginLeft = 4f * density
+          }
+        } catch (e: Exception) {
+          Log.d("MapboxNavigationView", "Compass position: ${e.message}")
+        }
 
-    // load map style
-    binding.mapView.mapboxMap.loadStyle(NavigationStyles.NAVIGATION_DAY_STYLE) {
-      // Ensure that the route line related layers are present before the route arrow
-      routeLineView.initializeLayers(it)
-    }
+        // Registrar listener de click no mapa (radar tap + rota alternativa)
+        binding.mapView.mapboxMap.addOnMapClickListener { point ->
+          try {
+            val mapboxMap = binding.mapView.mapboxMap
+            val pixel = mapboxMap.pixelForCoordinate(point)
+
+            // 1. Verificar se clicou em um radar (radars-layer-symbol ou cluster)
+            mapboxMap.queryRenderedFeatures(
+                    RenderedQueryGeometry(ScreenCoordinate(pixel.x, pixel.y)),
+                    RenderedQueryOptions(
+                            listOf("radars-layer-symbol", "radars-cluster-layer"),
+                            null
+                    )
+            ) { radarExpected ->
+              if (radarExpected.isValue) {
+                val radarFeatures = radarExpected.value
+                if (radarFeatures != null && radarFeatures.isNotEmpty()) {
+                  val qf = radarFeatures[0].queriedFeature
+                  val geoFeature = qf.feature
+                  val geom = geoFeature?.geometry()
+                  if (geom is com.mapbox.geojson.Point) {
+                    val lat = geom.latitude()
+                    val lng = geom.longitude()
+                    val props = geoFeature.properties()
+                    val pointCountEl = props?.get("point_count")
+                    val pointCount = (pointCountEl as? com.google.gson.JsonPrimitive)?.asLong
+                    if (pointCount != null && pointCount > 0L) {
+                      // Cluster: n√£o mover c√¢mera; usu√°rio pode abrir o cluster sem perder foco na localiza√ß√£o
+                    } else {
+                      // Radar individual: n√£o mover c√¢mera; s√≥ emitir evento (recenter ao fechar modal)
+                      val radarId = (props?.get("id") as? com.google.gson.JsonPrimitive)?.asString
+                      if (radarId != null && radarId.isNotBlank()) {
+                        val event = com.facebook.react.bridge.Arguments.createMap()
+                        event.putString("id", radarId)
+                        event.putDouble("latitude", lat)
+                        event.putDouble("longitude", lng)
+                        (props?.get("speedLimit") as? com.google.gson.JsonPrimitive)?.asDouble?.let { event.putDouble("speedLimit", it) }
+                        val typeStr = (props?.get("type") as? com.google.gson.JsonPrimitive)?.asString
+                                ?: (props?.get("radarType") as? com.google.gson.JsonPrimitive)?.asString
+                        if (typeStr != null) event.putString("type", typeStr)
+                        safeEmitEvent("onRadarTap", event)
+                      }
+                    }
+                  }
+                }
+              }
+            }
+
+            // 2. Consultar features na camada de rota (alternativas)
+            mapboxMap.queryRenderedFeatures(
+                    RenderedQueryGeometry(ScreenCoordinate(pixel.x, pixel.y)),
+                    RenderedQueryOptions(
+                            listOf(
+                                    "mapbox-navigation-route-line",
+                                    "mapbox-navigation-route-line-casing"
+                            ),
+                            null
+                    )
+            ) { expected ->
+              if (expected.isValue) {
+                val features = expected.value
+                if (features != null && features.isNotEmpty()) {
+                  val routes = mapboxNavigation?.getNavigationRoutes()
+                  if (routes != null && routes.size > 1) {
+                    // Melhor: Pegar a rota de √≠ndice 1 (primeira alternativa) e definir como
+                    // prim√°ria.
+                    val newRoutes = routes.toMutableList()
+                    val alternative = newRoutes.removeAt(1)
+                    newRoutes.add(0, alternative)
+
+                    mapboxNavigation?.setNavigationRoutes(newRoutes)
+                    Log.i("MapboxNavigationView", "Rota alternativa selecionada via click!")
+
+                    // Emitir evento para React Native
+                    val event = Arguments.createMap()
+                    event.putBoolean("alternativeSelected", true)
+
+                    safeEmitEvent("onRouteAlternativeSelected", event)
+                  }
+                }
+              }
+            }
+            // Retornar false para permitir que o mapa processe outros clicks se necess√°rio
+            return@addOnMapClickListener false
+          } catch (e: Exception) {
+            Log.w("MapboxNavigationView", "Erro no click do mapa: ${e.message}")
+          }
+          false
+        }
+      }
 
-    // initialize view interactions
-    binding.stop.setOnClickListener {
-      val event = Arguments.createMap()
-      event.putString("message", "Navigation Cancel")
-      context
-        .getJSModule(RCTEventEmitter::class.java)
-        .receiveEvent(id, "onCancelNavigation", event)
-    }
+      // initialize view interactions
+      binding.stop.setOnClickListener {
+        // Enviar pedido de cancelamento para o React Native tratar com modal personalizado
+        val event = Arguments.createMap()
+        event.putString("message", "Request Cancel")
+        safeEmitEvent("onCancelNavigation", event)
+      }
 
-    binding.recenter.setOnClickListener {
-      navigationCamera.requestNavigationCameraToFollowing()
-      binding.routeOverview.showTextAndExtend(BUTTON_ANIMATION_DURATION)
-    }
-    binding.routeOverview.setOnClickListener {
-      navigationCamera.requestNavigationCameraToOverview()
-      binding.recenter.showTextAndExtend(BUTTON_ANIMATION_DURATION)
-    }
-    binding.soundButton.setOnClickListener {
-      // mute/unmute voice instructions
-      isVoiceInstructionsMuted = !isVoiceInstructionsMuted
-    }
+      binding.recenter.setOnClickListener {
+        isManualOverview = false
+        initialFocusHandled = true
+        navigationCamera.requestNavigationCameraToFollowing()
+        binding.routeOverview.showTextAndExtend(BUTTON_ANIMATION_DURATION)
+      }
+      binding.routeOverview.setOnClickListener {
+        isManualOverview = true
+        navigationCamera.requestNavigationCameraToOverview()
+        binding.recenter.showTextAndExtend(BUTTON_ANIMATION_DURATION)
+      }
+      binding.soundButton.setOnClickListener {
+        // mute/unmute voice instructions
+        isVoiceInstructionsMuted = !isVoiceInstructionsMuted
+        // Sincronizar com React (soundEnabled = !muted)
+        try {
+          val ev = Arguments.createMap()
+          ev.putBoolean("muted", isVoiceInstructionsMuted)
+          ev.putBoolean("soundEnabled", !isVoiceInstructionsMuted)
+          safeEmitEvent("onMuteChange", ev)
+        } catch (e: Exception) {
+          Log.w("MapboxNavigationView", "Erro ao emitir onMuteChange: ${e.message}")
+        }
+      }
 
-    // Check initial muted or not
-    if (this.isVoiceInstructionsMuted) {
-      binding.soundButton.mute()
-      voiceInstructionsPlayer?.volume(SpeechVolume(0f))
-    } else {
-      binding.soundButton.unmute()
-      voiceInstructionsPlayer?.volume(SpeechVolume(1f))
+      // Check initial muted or not (respeita prefer√™ncias do app)
+      if (this.isVoiceInstructionsMuted) {
+        binding.soundButton.mute()
+        voiceInstructionsPlayer?.volume(SpeechVolume(0f))
+      } else {
+        binding.soundButton.unmute()
+        voiceInstructionsPlayer?.volume(SpeechVolume(voiceVolume))
+      }
+    } catch (e: Exception) {
+      navigationInitialized = false
+      Log.e("MapboxNavigationView", "Erro ao inicializar navega√ß√£o", e)
+      sendErrorToReact("Erro ao iniciar navega√ß√£o: ${e.message}")
     }
   }
 
   private fun onDestroy() {
-    maneuverApi.cancel()
-    routeLineApi.cancel()
-    routeLineView.cancel()
-    speechApi.cancel()
-    voiceInstructionsPlayer?.shutdown()
-    mapboxNavigation?.stopTripSession()
+    navigationInitialized = false
+    isDestroyed = true
+    cleanup()
+    try {
+      maneuverApi?.cancel()
+      routeLineApi.cancel()
+      routeLineView.cancel()
+      speechApi?.cancel()
+      voiceInstructionsPlayer?.shutdown()
+      mapboxNavigation?.stopTripSession()
+    } catch (e: Exception) {
+      Log.w("MapboxNavigationView", "onDestroy: ${e.message}")
+    }
   }
 
   private fun startNavigation() {
     // initialize location puck
     binding.mapView.location.apply {
       setLocationProvider(navigationLocationProvider)
-      this.locationPuck = LocationPuck2D(
-        bearingImage = ImageHolder.Companion.from(
-          com.mapbox.navigation.ui.maps.R.drawable.mapbox_navigation_puck_icon
-        )
-      )
+      this.locationPuck =
+              LocationPuck2D(
+                      bearingImage =
+                              ImageHolder.Companion.from(
+                                      com.mapbox
+                                              .navigation
+                                              .ui
+                                              .maps
+                                              .R
+                                              .drawable
+                                              .mapbox_navigation_puck_icon
+                              )
+              )
       puckBearingEnabled = true
       enabled = true
     }
@@ -634,31 +1066,34 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
     startRoute()
   }
 
-  private val arrivalObserver = object : ArrivalObserver {
+  private val arrivalObserver =
+          object : ArrivalObserver {
 
-    override fun onWaypointArrival(routeProgress: RouteProgress) {
-      onArrival(routeProgress)
-    }
+            override fun onWaypointArrival(routeProgress: RouteProgress) {
+              onArrival(routeProgress)
+            }
 
-    override fun onNextRouteLegStart(routeLegProgress: RouteLegProgress) {
-      // do something when the user starts a new leg
-    }
+            override fun onNextRouteLegStart(routeLegProgress: RouteLegProgress) {
+              // do something when the user starts a new leg
+            }
 
-    override fun onFinalDestinationArrival(routeProgress: RouteProgress) {
-      onArrival(routeProgress)
-    }
-  }
+            override fun onFinalDestinationArrival(routeProgress: RouteProgress) {
+              onArrival(routeProgress)
+            }
+          }
 
   private fun onArrival(routeProgress: RouteProgress) {
-    val leg = routeProgress.currentLegProgress
-    if (leg != null) {
-      val event = Arguments.createMap()
-      event.putInt("index", leg.legIndex)
-      event.putDouble("latitude", leg.legDestination?.location?.latitude() ?: 0.0)
-      event.putDouble("longitude", leg.legDestination?.location?.longitude() ?: 0.0)
-      context
-        .getJSModule(RCTEventEmitter::class.java)
-        .receiveEvent(id, "onArrive", event)
+    try {
+      val leg = routeProgress.currentLegProgress
+      if (leg != null) {
+        val event = Arguments.createMap()
+        event.putInt("index", leg.legIndex)
+        event.putDouble("latitude", leg.legDestination?.location?.latitude() ?: 0.0)
+        event.putDouble("longitude", leg.legDestination?.location?.longitude() ?: 0.0)
+        safeEmitEvent("onArrive", event)
+      }
+    } catch (e: Exception) {
+      Log.w("MapboxNavigationView", "onArrival error: ${e.message}")
     }
   }
 
@@ -669,8 +1104,8 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
 
   private val measureAndLayout = Runnable {
     measure(
-      MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY),
-      MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY)
+            MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY),
+            MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY)
     )
     layout(left, top, right, bottom)
   }
@@ -687,53 +1122,94 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
     names.add(destinationTitle)
 
     mapboxNavigation?.requestRoutes(
-      RouteOptions.builder()
-        .applyDefaultNavigationOptions()
-        .applyLanguageAndVoiceUnitOptions(context)
-        .coordinatesList(coordinates)
-        .waypointIndicesList(indices)
-        .waypointNamesList(names)
-        .language(locale.language)
-        .steps(true)
-        .voiceInstructions(true)
-        .voiceUnits(distanceUnit)
-        .build(),
-      object : NavigationRouterCallback {
-        override fun onCanceled(routeOptions: RouteOptions, @RouterOrigin routerOrigin: String) {
-          // no implementation
-        }
-
-        override fun onFailure(reasons: List<RouterFailure>, routeOptions: RouteOptions) {
-          sendErrorToReact("Error finding route $reasons")
-        }
-
-        override fun onRoutesReady(
-          routes: List<NavigationRoute>,
-          @RouterOrigin routerOrigin: String
-        ) {
-          setRouteAndStartNavigation(routes)
-        }
-      }
+            RouteOptions.builder()
+                    .applyDefaultNavigationOptions()
+                    .applyLanguageAndVoiceUnitOptions(context)
+                    .coordinatesList(coordinates)
+                    .waypointIndicesList(indices)
+                    .waypointNamesList(names)
+                    .language(locale.language)
+                    .steps(true)
+                    .voiceInstructions(true)
+                    .voiceUnits(distanceUnit)
+                    .alternatives(true) // Solicitar rotas alternativas
+                    .annotationsList(
+                            listOf(DirectionsCriteria.ANNOTATION_MAXSPEED)
+                    ) // Necess√°rio para speedLimitInfo
+                    .build(),
+            object : NavigationRouterCallback {
+              override fun onCanceled(
+                      routeOptions: RouteOptions,
+                      @RouterOrigin routerOrigin: String
+              ) {
+                // no implementation
+              }
+
+              override fun onFailure(reasons: List<RouterFailure>, routeOptions: RouteOptions) {
+                sendErrorToReact("Error finding route $reasons")
+              }
+
+              override fun onRoutesReady(
+                      routes: List<NavigationRoute>,
+                      @RouterOrigin routerOrigin: String
+              ) {
+                if (isDestroyed) return
+                // Armazenar rotas alternativas (at√© 3 melhores)
+                alternativeRoutes = routes.take(3)
+                currentRouteIndex = 0
+
+                // Mostrar rotas alternativas no mapa antes de iniciar navega√ß√£o
+                if (alternativeRoutes.size > 1) {
+                  showAlternativeRoutes(alternativeRoutes)
+                }
+
+                setRouteAndStartNavigation(routes)
+              }
+            }
     )
   }
 
   @SuppressLint("MissingPermission")
   private fun setRouteAndStartNavigation(routes: List<NavigationRoute>) {
-    // set routes, where the first route in the list is the primary route that
-    // will be used for active guidance
-    mapboxNavigation?.setNavigationRoutes(routes)
-
-    // show UI elements
-    binding.soundButton.visibility = View.VISIBLE
-    binding.routeOverview.visibility = View.VISIBLE
-    binding.tripProgressCard.visibility = View.VISIBLE
-
-    // move the camera to overview when new route is available
-//    navigationCamera.requestNavigationCameraToOverview()
-    mapboxNavigation?.startTripSession(withForegroundService = true)
+    if (routes.isEmpty()) {
+      Log.w("MapboxNavigationView", "setRouteAndStartNavigation: lista de rotas vazia")
+      return
+    }
+    try {
+      // set routes, where the first route in the list is the primary route that
+      // will be used for active guidance
+      mapboxNavigation?.setNavigationRoutes(routes)
+
+      // show UI elements
+      binding.maneuverView.visibility = View.VISIBLE
+      binding.soundButton.visibility = View.VISIBLE
+      binding.routeOverview.visibility = View.VISIBLE
+      binding.tripProgressCard.visibility = View.VISIBLE
+      // binding.speedLimitView.visibility = View.VISIBLE
+
+      mapboxNavigation?.startTripSession(withForegroundService = true)
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao iniciar sess√£o de navega√ß√£o", e)
+      sendErrorToReact("Erro ao iniciar navega√ß√£o: ${e.message}")
+    }
   }
 
   private fun startRoute() {
+    // Create a list of coordinates that includes origin, destination
+    val coordinatesList = mutableListOf<Point>()
+    this.origin?.let { coordinatesList.add(it) }
+    this.waypoints.let { coordinatesList.addAll(waypoints) }
+    this.destination?.let { coordinatesList.add(it) }
+
+    if (coordinatesList.size < 2) {
+      Log.e(
+              "MapboxNavigationView",
+              "startRoute: origem e destino s√£o obrigat√≥rios (pontos=${coordinatesList.size})"
+      )
+      sendErrorToReact("Origem e destino s√£o obrigat√≥rios")
+      return
+    }
+
     // register event listeners
     mapboxNavigation?.registerRoutesObserver(routesObserver)
     mapboxNavigation?.registerArrivalObserver(arrivalObserver)
@@ -741,39 +1217,48 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
     mapboxNavigation?.registerLocationObserver(locationObserver)
     mapboxNavigation?.registerVoiceInstructionsObserver(voiceInstructionsObserver)
 
-    // Create a list of coordinates that includes origin, destination
-    val coordinatesList = mutableListOf<Point>()
-    this.origin?.let { coordinatesList.add(it) }
-    this.waypoints.let { coordinatesList.addAll(waypoints) }
-    this.destination?.let { coordinatesList.add(it) }
-
     findRoute(coordinatesList)
   }
 
   override fun onDetachedFromWindow() {
     super.onDetachedFromWindow()
+    stopAutoRecenterTimer()
     mapboxNavigation?.unregisterRoutesObserver(routesObserver)
     mapboxNavigation?.unregisterArrivalObserver(arrivalObserver)
     mapboxNavigation?.unregisterLocationObserver(locationObserver)
     mapboxNavigation?.unregisterRouteProgressObserver(routeProgressObserver)
     mapboxNavigation?.unregisterVoiceInstructionsObserver(voiceInstructionsObserver)
+    onDestroy()
+  }
 
-    // Clear routs and end
-    mapboxNavigation?.setNavigationRoutes(listOf())
+  private fun startAutoRecenterTimer() {
+    stopAutoRecenterTimer()
+    autoRecenterRunnable = Runnable {
+      if (navigationInitialized && isCameraInIdleMode && !isManualOverview && !isDestroyed) {
+        Log.d("MapboxNavigationView", "üïí Auto-recenter: Tempo de inatividade atingido (10s)")
+        navigationCamera.requestNavigationCameraToFollowing()
+      }
+    }
+    autoRecenterRunnable?.let { autoRecenterHandler.postDelayed(it, AUTO_RECENTER_DELAY) }
+  }
 
-    // hide UI elements
-    binding.soundButton.visibility = View.INVISIBLE
-    binding.maneuverView.visibility = View.INVISIBLE
-    binding.routeOverview.visibility = View.INVISIBLE
-    binding.tripProgressCard.visibility = View.INVISIBLE
+  private fun stopAutoRecenterTimer() {
+    autoRecenterRunnable?.let { autoRecenterHandler.removeCallbacks(it) }
+    autoRecenterRunnable = null
+  }
+
+  private fun cleanup() {
+    try {
+      pulseHandler.removeCallbacksAndMessages(null)
+    } catch (e: Exception) {
+      Log.w("MapboxNavigationView", "Cleanup error: ${e.message}")
+    }
   }
 
   private fun sendErrorToReact(error: String?) {
     val event = Arguments.createMap()
     event.putString("error", error)
-    context
-      .getJSModule(RCTEventEmitter::class.java)
-      .receiveEvent(id, "onError", event)
+    safeEmitEvent("onError", event)
   }
 
   fun onDropViewInstance() {
@@ -782,10 +1267,12 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
 
   fun setStartOrigin(origin: Point?) {
     this.origin = origin
+    if (destination != null) initNavigation()
   }
 
   fun setDestination(destination: Point?) {
     this.destination = destination
+    if (origin != null) initNavigation()
   }
 
   fun setDestinationTitle(title: String) {
@@ -802,7 +1289,7 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
 
   fun setDirectionUnit(unit: String) {
     this.distanceUnit = unit
-    initNavigation()
+    if (origin != null && destination != null) initNavigation()
   }
 
   fun setLocal(language: String) {
@@ -817,7 +1304,1779 @@ class MapboxNavigationView(private val context: ThemedReactContext): FrameLayout
     this.isVoiceInstructionsMuted = mute
   }
 
+  fun setVolume(volume: Float) {
+    voiceVolume = volume.coerceIn(0f, 1f)
+    if (!isVoiceInstructionsMuted) {
+      voiceInstructionsPlayer?.volume(SpeechVolume(voiceVolume))
+    }
+  }
+
   fun setShowCancelButton(show: Boolean) {
     binding.stop.visibility = if (show) View.VISIBLE else View.INVISIBLE
   }
+
+  // Setter methods for radar functionality
+  fun setBottomPadding(padding: Double) {
+    try {
+      additionalBottomPadding = padding
+      updateCameraPadding()
+      Log.d("MapboxNavigationView", "‚¨áÔ∏è Bottom padding atualizado para: $padding")
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao definir bottom padding", e)
+    }
+  }
+
+  /** Quando este valor muda (ex.: JS incrementa ao fechar modal do radar), volta c√¢mera a seguir o usu√°rio */
+  fun setRecenterTrigger(value: Int) {
+    post {
+      try {
+        navigationCamera.requestNavigationCameraToFollowing()
+      } catch (e: Exception) {
+        Log.e("MapboxNavigationView", "Erro ao recentrar c√¢mera", e)
+      }
+    }
+  }
+
+  fun setTtsVoiceId(voiceId: String?) {
+    val id = voiceId?.takeIf { it.isNotBlank() }
+    ttsVoiceId = id
+    useAppVoicePreferred = !id.isNullOrBlank()
+  }
+
+  /** Base: CSV ao longo da rota ‚Äî enviada UMA vez, nunca muda ao reportar */
+  fun setBaseRadars(list: List<RadarPoint>) {
+    try {
+      val sig = list.joinToString("|") { "${it.id}:${it.latitude}:${it.longitude}" }
+      if (sig == lastBaseRadarsSignature) return
+      lastBaseRadarsSignature = sig
+      baseRadars = list
+      mergeRadarsAndUpdate()
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao definir base radares", e)
+    }
+  }
+
+  fun setRadarsGeoJsonUrl(url: String?) {
+    val u = url?.trim()?.takeIf { it.isNotEmpty() }
+    if (u == radarsGeoJsonUrl) return
+    radarsGeoJsonUrl = u
+    if (u == null) lastRadarsGeoJsonUrlUsed = null
+    Log.d("MapboxNavigationView", "üåê radarsGeoJsonUrl=${if (u != null) "set(${u.take(50)}...)" else "null"}")
+    updateRadarsOnMap()
+  }
+
+  /** Overlay: SOMENTE radares reportados ‚Äî enviada ao reportar (lista pequena) */
+  fun setOverlayRadars(list: List<RadarPoint>) {
+    try {
+      val sig = list.joinToString("|") { "${it.id}:${it.latitude}:${it.longitude}" }
+      if (sig == lastOverlayRadarsSignature) return
+      lastOverlayRadarsSignature = sig
+      overlayRadars = list
+      mergeRadarsAndUpdate()
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao definir overlay radares", e)
+    }
+  }
+
+  private var lastBaseRadarsSignature: String = ""
+  private var lastOverlayRadarsSignature: String = ""
+
+  private fun mergeRadarsAndUpdate() {
+    if (radarsGeoJsonUrl != null) {
+      radars = overlayRadars
+      lastRadarsSignature = "url:${radarsGeoJsonUrl}|overlay:${overlayRadars.size}"
+      Log.d("MapboxNavigationView", "üìç base=URL, overlay=${overlayRadars.size}")
+    } else {
+      val overlayIds = overlayRadars.map { it.id }.toSet()
+      radars = baseRadars.filter { it.id !in overlayIds } + overlayRadars
+      lastRadarsSignature =
+          radars.joinToString("|") { "${it.id}:${it.latitude}:${it.longitude}:${it.speedLimit ?: 0.0}:${it.type ?: ""}" }
+      Log.d("MapboxNavigationView", "üìç ${radars.size} radares (base=${baseRadars.size}, overlay=${overlayRadars.size})")
+    }
+    updateRadarsOnMap()
+  }
+
+  fun setNearbyRadarIds(radarIds: Set<String>) {
+    try {
+      val newHash = radarIds.toList().sorted().joinToString("|").hashCode()
+      if (newHash == lastNearbyRadarIdsHash) return
+      lastNearbyRadarIdsHash = newHash
+      this.nearbyRadarIds = radarIds
+      Log.d("MapboxNavigationView", "üì° ${radarIds.size} radares pr√≥ximos definidos")
+      updateHighlightFilterAndPulse()
+      if (radarIds.isNotEmpty()) {
+        // Retries: estilo pode n√£o estar pronto ou GeoJSON ainda carregando
+        listOf(100L, 300L, 600L, 1000L, 1500L, 2500L).forEach { delayMs ->
+          throttleHandler.postDelayed({ updateHighlightFilterAndPulse() }, delayMs)
+        }
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao definir radares pr√≥ximos", e)
+    }
+  }
+
+  private fun isValidForOperations(): Boolean {
+    return try {
+      !isDestroyed && binding.mapView != null
+    } catch (e: Exception) {
+      false
+    }
+  }
+
+  // Utility functions
+  private fun getCurrentStyle(): com.mapbox.maps.Style? {
+    return try {
+      binding.mapView.mapboxMap.style
+    } catch (e: Exception) {
+      null
+    }
+  }
+
+  private fun safeEmitEvent(eventName: String, event: com.facebook.react.bridge.WritableMap) {
+    if (isDestroyed || id == View.NO_ID) return
+
+    try {
+      val reactContext = context as? ThemedReactContext ?: return
+      if (!reactContext.hasActiveCatalystInstance()) return
+
+      val emitter =
+              reactContext.getJSModule(
+                      com.facebook.react.uimanager.events.RCTEventEmitter::class.java
+              )
+      if (emitter != null) {
+        emitter.receiveEvent(id, eventName, event)
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao emitir evento $eventName", e)
+    }
+  }
+
+  private fun updateCameraPadding() {
+    try {
+      val style = getCurrentStyle() ?: return
+
+      // Atualizar padding da c√¢mera baseado no additionalBottomPadding
+      // Usar l√≥gica diferencial para evitar ac√∫mulo infinito de padding
+      val currentPadding = viewportDataSource.followingPadding
+
+      // Aplicar densidade se necess√°rio (assumindo que entrada √© DP)
+      // Mas para manter compatibilidade com comportamento atual (que usu√°rio disse "sobe um
+      // pouco"),
+      // vamos manter a unidade crua por enquanto ou aplicar density se parecer muito pequeno.
+      // O codigo anterior somava direto e funcionava "um pouco". Vamos manter a escala.
+      // Se adicionalBottomPadding for DP, deveria ser * pixelDensity.
+      // Vamos assumir que o valor passado j√° est√° ok ou ajustar depois se precisar.
+
+      val paddingToAdd =
+              additionalBottomPadding *
+                      pixelDensity // Convertendo para pixels para garantir efeito correto
+
+      // Recuperar base subtraindo o √∫ltimo aplicado
+      val baseBottom = currentPadding.bottom - lastAppliedAdditionalPadding
+
+      val newBottomPadding = baseBottom + paddingToAdd
+
+      val newPadding =
+              EdgeInsets(
+                      currentPadding.top,
+                      currentPadding.left,
+                      newBottomPadding.coerceAtLeast(0.0), // Evitar valores negativos
+                      currentPadding.right
+              )
+
+      viewportDataSource.followingPadding = newPadding
+      viewportDataSource.evaluate()
+
+      // Atualizar √∫ltimo valor aplicado
+      lastAppliedAdditionalPadding = paddingToAdd
+
+      Log.d(
+              "MapboxNavigationView",
+              "‚úÖ Camera padding atualizado: bottom=$newBottomPadding (added: $paddingToAdd)"
+      )
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao atualizar camera padding", e)
+    }
+  }
+
+  private fun updateRadarAnnotations() {
+    updateRadarsOnMap()
+  }
+
+  private fun updateRadarAnimations() {
+    // Evita refresh completo do source em mudan√ßas de nearby ids.
+  }
+
+  private fun loadRadarImagesWithRetry(style: com.mapbox.maps.Style) {
+    loadRadarImages(style)
+  }
+
+  private fun loadRadarImages(style: com.mapbox.maps.Style) {
+    try {
+      // Usar applicationContext para garantir recursos do app (n√£o da lib)
+      val appCtx = context.applicationContext ?: context
+      val res = appCtx.resources
+      val pkg = appCtx.packageName.ifEmpty { "com.radarbot" }
+      val imageNames =
+              listOf(
+                      "placa0",
+                      "placa10",
+                      "placa20",
+                      "placa30",
+                      "placa40",
+                      "placa50",
+                      "placa60",
+                      "placa70",
+                      "placa80",
+                      "placa90",
+                      "placa100",
+                      "placa110",
+                      "placa120",
+                      "placa130",
+                      "placa140",
+                      "placa150",
+                      "placa160",
+                      "radarFixo",
+                      "radarSemaforico",
+                      "radarMovel",
+                      "radar_fixo",
+                      "radar_semaforico",
+                      "radar_movel",
+              )
+
+      imageNames.forEach { imageName ->
+        try {
+          // Se j√° carregou, n√£o precisa tentar de novo (otimiza√ß√£o)
+          if (loadedIconNames.contains(imageName) && style.getStyleImage(imageName) != null) {
+            return@forEach
+          }
+
+          // Android drawable: apenas a-z, 0-9, underscore. camelCase -> snake_case.
+          val snakeCase = imageName.replace(Regex("[A-Z]")) { "_${it.value.lowercase()}" }
+          val possibleResourceNames =
+                  listOf(
+                                  "assets_images_$imageName",
+                                  "assets_images_${imageName.lowercase()}",
+                                  "assets_images_$snakeCase", // radarMovel -> radar_movel
+                                  imageName,
+                                  imageName.lowercase(),
+                                  snakeCase,
+                                  snakeCase.lowercase()
+                          )
+                          .distinct()
+
+          var resourceId = 0
+          var finalResourceName = ""
+
+          for (resName in possibleResourceNames) {
+            val id = res.getIdentifier(resName, "drawable", pkg)
+            if (id != 0) {
+              resourceId = id
+              finalResourceName = resName
+              break
+            }
+          }
+
+          if (resourceId == 0) {
+            // Log apenas para nomes principais importantes se n√£o encontrar nenhum
+            if (imageName == "radarSemaforico" || imageName == "radarMovel") {
+              Log.w(
+                      "MapboxNavigationView",
+                      "‚ö†Ô∏è Imagem faltando no mapa: $imageName (tentados: $possibleResourceNames)"
+              )
+            }
+            return@forEach
+          }
+
+          val bitmap = BitmapFactory.decodeResource(res, resourceId)
+          if (bitmap == null) {
+            Log.w("MapboxNavigationView", "‚ö†Ô∏è Bitmap null para $finalResourceName")
+            return@forEach
+          }
+
+          // Mapbox API: addImage(id, bitmap, sdf). sdf=false para PNGs normais.
+          style.addImage(imageName, bitmap, false)
+          loadedIconNames.add(imageName)
+          // Log.d("MapboxNavigationView", "‚úÖ Imagem $imageName carregada ($finalResourceName)")
+
+        } catch (e: Exception) {
+          Log.e("MapboxNavigationView", "‚ùå Erro ao carregar imagem $imageName", e)
+        }
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "‚ùå Erro geral ao carregar imagens", e)
+    }
+  }
+
+  private fun registerImageMissingListener(style: com.mapbox.maps.Style) {
+    if (imageMissingListenerRegistered) {
+      return
+    }
+
+    try {
+      binding.mapView.mapboxMap.subscribeStyleImageMissing { eventData ->
+        val missingId = eventData.imageId
+        val currentStyle = binding.mapView.mapboxMap.style ?: return@subscribeStyleImageMissing
+
+        try {
+          val appCtx = context.applicationContext ?: context
+          val res = appCtx.resources
+          val pkg = appCtx.packageName
+          val snakeCase = missingId.replace(Regex("[A-Z]")) { "_${it.value.lowercase()}" }
+          val namesToTry = listOf("assets_images_$missingId", "assets_images_$snakeCase", missingId, snakeCase).distinct()
+          var resourceId = 0
+          for (resourceName in namesToTry) {
+            resourceId = res.getIdentifier(resourceName, "drawable", pkg)
+            if (resourceId != 0) break
+          }
+          if (resourceId != 0) {
+            val bitmap = BitmapFactory.decodeResource(res, resourceId)
+            if (bitmap != null) {
+              val imageExists =
+                      try {
+                        currentStyle.getStyleImage(missingId) != null
+                      } catch (e: Exception) {
+                        false
+                      }
+
+              if (!imageExists) {
+                currentStyle.addImage(missingId, bitmap, false)
+                Log.d("MapboxNavigationView", "‚úÖ Imagem faltante $missingId carregada via listener")
+              }
+            }
+          }
+        } catch (e: Exception) {
+          Log.e("MapboxNavigationView", "Erro ao processar imagem faltante $missingId", e)
+        }
+      }
+
+      imageMissingListenerRegistered = true
+      Log.d("MapboxNavigationView", "‚úÖ Listener de imagens faltantes registrado")
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao registrar listener de imagens faltantes", e)
+    }
+  }
+
+  // Fun√ß√£o removida - n√£o filtramos mais radares, mostramos todos durante navega√ß√£o
+  // private fun filterRadarsNearRoute() { ... }
+
+  /** Calcula a dist√¢ncia m√≠nima perpendicular de um ponto at√© a rota Retorna dist√¢ncia em metros */
+  private fun calculateMinDistanceToRoute(point: Point, routePoints: List<Point>): Double {
+    if (routePoints.size < 2) {
+      return Double.MAX_VALUE
+    }
+
+    var minDistance = Double.MAX_VALUE
+
+    // Verificar dist√¢ncia perpendicular para cada segmento da rota
+    for (i in 0 until routePoints.size - 1) {
+      val segmentStart = routePoints[i]
+      val segmentEnd = routePoints[i + 1]
+
+      val distance = calculatePerpendicularDistance(point, segmentStart, segmentEnd)
+      if (distance < minDistance) {
+        minDistance = distance
+      }
+    }
+
+    return minDistance
+  }
+
+  /**
+   * Calcula dist√¢ncia perpendicular de um ponto at√© um segmento de linha Usa f√≥rmula de dist√¢ncia
+   * ponto-linha Retorna dist√¢ncia em metros usando f√≥rmula de Haversine
+   */
+  private fun calculatePerpendicularDistance(
+          point: Point,
+          lineStart: Point,
+          lineEnd: Point
+  ): Double {
+    // Calcular dist√¢ncia usando f√≥rmula de Haversine
+    val R = 6371000.0 // Raio da Terra em metros
+
+    // Converter para radianos
+    val lat1 = Math.toRadians(point.latitude())
+    val lon1 = Math.toRadians(point.longitude())
+    val lat2 = Math.toRadians(lineStart.latitude())
+    val lon2 = Math.toRadians(lineStart.longitude())
+    val lat3 = Math.toRadians(lineEnd.latitude())
+    val lon3 = Math.toRadians(lineEnd.longitude())
+
+    // Calcular vetor do segmento
+    val dLat = lat3 - lat2
+    val dLon = lon3 - lon2
+
+    // Calcular produto escalar para encontrar ponto mais pr√≥ximo no segmento
+    val t =
+            if (dLat * dLat + dLon * dLon > 0) {
+              val dot = (lat1 - lat2) * dLat + (lon1 - lon2) * dLon
+              val lenSq = dLat * dLat + dLon * dLon
+              (dot / lenSq).coerceIn(0.0, 1.0)
+            } else {
+              0.0
+            }
+
+    // Ponto mais pr√≥ximo no segmento
+    val closestLat = lat2 + t * dLat
+    val closestLon = lon2 + t * dLon
+
+    // Calcular dist√¢ncia Haversine entre ponto e ponto mais pr√≥ximo
+    val dLat2 = lat1 - closestLat
+    val dLon2 = lon1 - closestLon
+
+    val a =
+            Math.sin(dLat2 / 2) * Math.sin(dLat2 / 2) +
+                    Math.cos(lat1) *
+                            Math.cos(closestLat) *
+                            Math.sin(dLon2 / 2) *
+                            Math.sin(dLon2 / 2)
+    val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
+
+    return R * c
+  }
+
+  private fun updateRadarsOnMap_OLD() {
+    val style = getCurrentStyle() ?: return
+
+    // Mostrar todos os radares, limitando apenas por performance (1000 radares max)
+    // ESTABILIDADE: Ordenar por ID para evitar "pisca-pisca" quando a lista muda de ordem
+    val radarsToDisplay = radars.sortedBy { it.id }.take(1000)
+
+    if (radarsToDisplay.isEmpty()) {
+      return
+    }
+
+    try {
+      val features =
+              radarsToDisplay.mapNotNull { radar: RadarPoint ->
+                val speedLimit = radar.speedLimit ?: 0.0
+
+                // Determinar imagem baseado no tipo do radar usando normaliza√ß√£o robusta
+                val rawType = radar.type ?: ""
+                val typeStr =
+                        Normalizer.normalize(rawType, Normalizer.Form.NFD)
+                                .replace(Regex("\\p{InCombiningDiacriticalMarks}+"), "")
+                                .lowercase()
+
+                val (preferredIcon, iconSize) =
+                        when {
+                          // Prioridade 1: Semaf√≥rico / C√¢mera
+                          typeStr.contains("semaforo") ||
+                                  typeStr.contains("camera") ||
+                                  typeStr.contains("fotografica") ->
+                                  Pair("radar_semaforico", 0.05) // Pequeno
+
+                          // Prioridade 2: M√≥vel / Mobile
+                          typeStr.contains("movel") || typeStr.contains("mobile") ->
+                                  Pair("radar_movel", 0.05) // Pequeno
+
+                          // Prioridade 3: Placas (Fixo ou Placa)
+                          typeStr.contains("fixo") || typeStr.contains("placa") -> {
+                            val speeds =
+                                    listOf(
+                                            20,
+                                            30,
+                                            40,
+                                            50,
+                                            60,
+                                            70,
+                                            80,
+                                            90,
+                                            100,
+                                            110,
+                                            120,
+                                            130,
+                                            140,
+                                            150,
+                                            160
+                                    )
+                            val closestSpeed =
+                                    if (speedLimit > 0) {
+                                      speeds.minByOrNull { kotlin.math.abs(it - speedLimit) } ?: 0
+                                    } else {
+                                      0
+                                    }
+                            // Placas j√° est√£o em formato compativel (placa80, etc) ou podem ser
+                            // placa_80 se renomearmos.
+                            // Mantendo placaXX pois n√£o conflitam tanto, mas se quisermos padrao:
+                            val icon = if (closestSpeed > 0) "placa$closestSpeed" else "radar_fixo"
+                            Pair(icon, 0.18)
+                          }
+
+                          // Default
+                          else -> Pair("radar_movel", 0.05) // Changed from "radar" to "radar_movel"
+                        }
+
+                // Fallback se a imagem preferida n√£o estiver carregada
+                val iconImage =
+                        if (loadedIconNames.contains(preferredIcon)) {
+                          preferredIcon
+                        } else if (loadedIconNames.contains(preferredIcon.lowercase())) {
+                          preferredIcon.lowercase()
+                        } else if (loadedIconNames.contains("radar_movel")) {
+                          "radar_movel"
+                        } else {
+                          return@mapNotNull null
+                        }
+
+                // Match Map.tsx: No rotation logic
+                val iconRotate = 0.0
+
+                // Log de debug
+                if (radarsToDisplay.indexOf(radar) < 5) {
+                  Log.d(
+                          "MapboxNavigationView",
+                          "üì° Radar ID: ${radar.id} | Tipo: '$typeStr' | √çcone: '$iconImage'"
+                  )
+                }
+
+                val isNearby = nearbyRadarIds.contains(radar.id)
+
+                if (radar.latitude.isNaN() ||
+                                radar.longitude.isNaN() ||
+                                radar.latitude.isInfinite() ||
+                                radar.longitude.isInfinite()
+                ) {
+                  return@mapNotNull null
+                }
+
+                Feature.fromGeometry(
+                        Point.fromLngLat(radar.longitude, radar.latitude),
+                        JsonObject().apply {
+                          addProperty("id", radar.id)
+                          addProperty("speedLimit", radar.speedLimit?.toString() ?: "")
+                          addProperty("iconImage", iconImage)
+                          addProperty("iconSize", iconSize)
+                          addProperty("isNearby", java.lang.Boolean.valueOf(isNearby))
+                          addProperty("radarType", radar.type ?: "")
+                        }
+                )
+              }
+
+      val featureCollection = FeatureCollection.fromFeatures(features.toList())
+      val geoJsonString = featureCollection.toJson()
+
+      loadRadarImages(style)
+
+      if (style.styleSourceExists("radars-source")) {
+        val dataValue = com.mapbox.bindgen.Value.fromJson(geoJsonString)
+        dataValue.value?.let { value ->
+          style.setStyleSourceProperty("radars-source", "data", value)
+        }
+      } else {
+        // Criar fonte pela primeira vez
+        val sourceJson =
+                """
+            {
+              "type": "geojson",
+              "data": $geoJsonString
+            }
+          """.trimIndent()
+
+        val sourceValueResult = com.mapbox.bindgen.Value.fromJson(sourceJson)
+        sourceValueResult.value?.let { value -> style.addStyleSource("radars-source", value) }
+      }
+
+      // 1. Create/Update Highlight Layer (Circle background for pulsing effect)
+      if (style.styleLayerExists("radars-highlight-layer")) {
+        style.removeStyleLayer("radars-highlight-layer")
+      }
+
+      val highlightLayerJson =
+              """
+        {
+          "id": "radars-highlight-layer",
+          "type": "circle",
+          "source": "radars-source",
+          "paint": {
+            "circle-radius": 25,
+            "circle-color": "#ef4444",
+            "circle-opacity": ["case", ["==", ["get", "isNearby"], true], 0.6, 0.0],
+            "circle-stroke-width": 2,
+            "circle-stroke-color": "#ffffff",
+            "circle-stroke-opacity": ["case", ["==", ["get", "isNearby"], true], 0.8, 0.0]
+          }
+        }
+      """.trimIndent()
+
+      val highlightLayerValue = com.mapbox.bindgen.Value.fromJson(highlightLayerJson)
+      highlightLayerValue.value?.let { value ->
+        // Put highlight BELOW the symbol layer (or at route level)
+        val layerPosition =
+                if (style.styleLayerExists(TOP_LEVEL_ROUTE_LINE_LAYER_ID)) {
+                  LayerPosition(TOP_LEVEL_ROUTE_LINE_LAYER_ID, null, null)
+                } else {
+                  null
+                }
+        style.addStyleLayer(value, layerPosition)
+
+        // Start pulsing animation
+        startRadarPulseAnimation(style)
+      }
+
+      // 2. Create/Update Symbol Layer (Icons)
+      if (style.styleLayerExists("radars-layer-symbol")) {
+        style.removeStyleLayer("radars-layer-symbol")
+      }
+
+      val layerJson =
+              """
+        {
+          "id": "radars-layer-symbol",
+          "type": "symbol",
+          "source": "radars-source",
+          "layout": {
+            "icon-image": ["get", "iconImage"],
+            "icon-size": ["get", "iconSize"],
+            "icon-allow-overlap": true,
+            "icon-ignore-placement": true,
+            "icon-anchor": "center",
+            "icon-pitch-alignment": "viewport",
+            "icon-rotation-alignment": "viewport"
+          },
+          "paint": {}
+        }
+      """.trimIndent()
+
+      val layerValueResult = com.mapbox.bindgen.Value.fromJson(layerJson)
+      layerValueResult.value?.let { value ->
+        // Put symobl layer ABOVE highlight layer if possible, or just add it (default is top)
+        // To ensure it's above highlight, we can put it ABOVE highlight layer
+        val layerPosition =
+                if (style.styleLayerExists("radars-highlight-layer")) {
+                  LayerPosition("radars-highlight-layer", null, null) // Place ABOVE highlight
+                } else {
+                  null
+                }
+        style.addStyleLayer(value, layerPosition)
+        Log.d("MapboxNavigationView", "‚úÖ Layer 'radars-layer-symbol' recriado com Highlight")
+      }
+              ?: Log.w("MapboxNavigationView", "‚ö†Ô∏è layerValueResult.value √© null, layer n√£o criado")
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao atualizar radares no mapa", e)
+    }
+  }
+
+  private fun startRadarPulseAnimation_OLD(style: com.mapbox.maps.Style) {
+    // Stop any existing animation
+    pulseAnimationRunnable?.let { pulseHandler.removeCallbacks(it) }
+
+    pulseAnimationRunnable =
+            object : Runnable {
+              override fun run() {
+                try {
+                  if (!style.styleLayerExists("radars-highlight-layer")) {
+                    return
+                  }
+
+                  // Increment animation value (0 to 1 and loop)
+                  pulseAnimationValue += 0.015f // Slower increment for smoother animation
+                  if (pulseAnimationValue > 1f) {
+                    pulseAnimationValue = 0f
+                  }
+
+                  // Use sine wave for smooth, natural pulsing (0 to 1 to 0)
+                  val sineWave = Math.sin(pulseAnimationValue * Math.PI).toFloat()
+
+                  // Calculate pulsing radius (25 to 45 pixels)
+                  val minRadius = 25.0
+                  val maxRadius = 45.0
+                  val currentRadius = minRadius + (maxRadius - minRadius) * sineWave
+
+                  // Calculate pulsing opacity (0.6 to 0.2 and back, synchronized with radius)
+                  val minOpacity = 0.2
+                  val maxOpacity = 0.6
+                  val currentOpacity = minOpacity + (maxOpacity - minOpacity) * sineWave
+
+                  // Update layer paint properties
+                  val radiusValue = com.mapbox.bindgen.Value(currentRadius)
+                  val opacityValue = com.mapbox.bindgen.Value(currentOpacity)
+
+                  style.setStyleLayerProperty(
+                          "radars-highlight-layer",
+                          "circle-radius",
+                          radiusValue
+                  )
+                  style.setStyleLayerProperty(
+                          "radars-highlight-layer",
+                          "circle-opacity",
+                          com.mapbox.bindgen.Value.fromJson(
+                                          """["case", ["==", ["get", "isNearby"], true], $currentOpacity, 0.0]"""
+                                  )
+                                  .value
+                                  ?: opacityValue
+                  )
+
+                  // Schedule next frame (60ms for smoother animation, ~16fps)
+                  pulseHandler.postDelayed(this, 60)
+                } catch (e: Exception) {
+                  Log.e("MapboxNavigationView", "Erro na anima√ß√£o de pulse", e)
+                }
+              }
+            }
+
+    // Start animation
+    pulseHandler.post(pulseAnimationRunnable!!)
+  }
+
+  // ==============================================================================================
+  // OPTIMIZED NATIVE RENDERING IMPLEMENTATION (Persistent Layers + 18k item support)
+  // ==============================================================================================
+
+  private fun updateRadarsOnMap_NO_CLUSTER() {
+    try {
+      val style = getCurrentStyle() ?: return
+
+      // TODOS os radares agora s√£o processados (filtro removido por pedido do usu√°rio)
+      val radarsToDisplay = radars
+
+      val features =
+              radarsToDisplay.mapNotNull { radar ->
+                val typeStr = (radar.type ?: "unknown").trim().lowercase()
+
+                val (preferredIcon, iconSize) =
+                        when {
+                          typeStr.contains("semaforo") ||
+                                  typeStr.contains("camera") ||
+                                  typeStr.contains("fotografica") -> Pair("radar_semaforico", 0.05)
+                          typeStr.contains("movel") || typeStr.contains("mobile") ->
+                                  Pair("radar_movel", 0.05)
+                          typeStr.contains("fixo") || typeStr.contains("placa") -> {
+                            val speeds =
+                                    listOf(
+                                            20,
+                                            30,
+                                            40,
+                                            50,
+                                            60,
+                                            70,
+                                            80,
+                                            90,
+                                            100,
+                                            110,
+                                            120,
+                                            130,
+                                            140,
+                                            150,
+                                            160
+                                    )
+                            val speed = radar.speedLimit ?: 0.0
+                            val closestSpeed =
+                                    if (speed > 0)
+                                            speeds.minByOrNull { kotlin.math.abs(it - speed) } ?: 0
+                                    else 0
+                            val icon = if (closestSpeed > 0) "placa$closestSpeed" else "radar_fixo"
+                            Pair(icon, 0.18)
+                          }
+                          else -> Pair("radar_movel", 0.05) // Changed from "radar" to "radar_movel"
+                        }
+
+                // Normaliza√ß√£o de nomes de √≠cones
+                val iconImage =
+                        if (loadedIconNames.contains(preferredIcon)) preferredIcon
+                        else if (loadedIconNames.contains(preferredIcon.lowercase()))
+                                preferredIcon.lowercase()
+                        else "radar_movel"
+
+                val isNearby = nearbyRadarIds.contains(radar.id)
+
+                if (radar.latitude.isNaN() ||
+                                radar.longitude.isNaN() ||
+                                radar.latitude.isInfinite() ||
+                                radar.longitude.isInfinite()
+                ) {
+                  null
+                } else {
+                  Feature.fromGeometry(
+                          Point.fromLngLat(radar.longitude, radar.latitude),
+                          JsonObject().apply {
+                            addProperty("id", radar.id)
+                            addProperty("speedLimit", radar.speedLimit?.toString() ?: "")
+                            addProperty("iconImage", iconImage)
+                            addProperty("iconSize", iconSize)
+                            addProperty("isNearby", isNearby)
+                            addProperty("radarType", radar.type ?: "")
+                          }
+                  )
+                }
+              }
+
+      val featureCollection = FeatureCollection.fromFeatures(features)
+      val geoJsonString = featureCollection.toJson()
+
+      // KEY FIX: Only update DATA if source exists. Do NOT destroy layers.
+      if (style.styleSourceExists("radars-source")) {
+        val dataValue = com.mapbox.bindgen.Value.fromJson(geoJsonString)
+        dataValue.value?.let { value ->
+          style.setStyleSourceProperty("radars-source", "data", value)
+        }
+      } else {
+        // Initialize source and layers ONCE
+        loadRadarImages(style)
+
+        val sourceJson =
+                """
+            { "type": "geojson", "data": $geoJsonString }
+          """.trimIndent()
+
+        val sourceValueResult = com.mapbox.bindgen.Value.fromJson(sourceJson)
+        sourceValueResult.value?.let { value -> style.addStyleSource("radars-source", value) }
+
+        // Highlight Layer
+        val highlightLayerJson =
+                """
+            {
+              "id": "radars-highlight-layer", "type": "circle", "source": "radars-source",
+              "paint": {
+                "circle-radius": 25, "circle-color": "#ef4444",
+                "circle-opacity": ["case", ["==", ["get", "isNearby"], true], 0.6, 0.0],
+                "circle-stroke-width": 2, "circle-stroke-color": "#ffffff",
+                "circle-stroke-opacity": ["case", ["==", ["get", "isNearby"], true], 0.8, 0.0]
+              }
+            }
+          """.trimIndent()
+
+        val highlightLayerValue = com.mapbox.bindgen.Value.fromJson(highlightLayerJson)
+        highlightLayerValue.value?.let { value ->
+          val position =
+                  if (style.styleLayerExists(TOP_LEVEL_ROUTE_LINE_LAYER_ID))
+                          LayerPosition(TOP_LEVEL_ROUTE_LINE_LAYER_ID, null, null)
+                  else null
+          style.addStyleLayer(value, position)
+        }
+
+        // Symbol Layer
+        val layerJson =
+                """
+            {
+              "id": "radars-layer-symbol", "type": "symbol", "source": "radars-source",
+              "layout": {
+                "icon-image": ["get", "iconImage"], "icon-size": ["get", "iconSize"],
+                "icon-allow-overlap": true, "icon-ignore-placement": true,
+                "icon-anchor": "center", "icon-pitch-alignment": "viewport", "icon-rotation-alignment": "viewport"
+              }
+            }
+          """.trimIndent()
+
+        val layerValue = com.mapbox.bindgen.Value.fromJson(layerJson)
+        layerValue.value?.let { value -> style.addStyleLayer(value, null) }
+
+        startRadarPulseAnimation(style)
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao atualizar radares no mapa", e)
+    }
+  }
+
+  // ==============================================================================================
+  // CLUSTERED NATIVE RENDERING IMPLEMENTATION (Matches Map.tsx)
+  // ==============================================================================================
+
+  // ==============================================================================================
+  // CLUSTERED NATIVE RENDERING IMPLEMENTATION (Matches Map.tsx) - OPTIMIZED THREADING
+  // ==============================================================================================
+
+  private fun updateRadarsOnMap() {
+    throttledUpdateRunnable?.let { throttleHandler.removeCallbacks(it) }
+    throttledUpdateRunnable = Runnable { performUpdateRadarsOnMap() }
+    // 200ms quando URL (sem processamento pesado); 400ms quando bridge
+    val delayMs = if (radarsGeoJsonUrl != null) 200L else 400L
+    throttleHandler.postDelayed(throttledUpdateRunnable!!, delayMs)
+  }
+
+  private var lastRadarsGeoJsonUrlUsed: String? = null
+
+  /** Base via URL (todos os radares) + overlay via props. Zero bridge para base. */
+  private fun performUpdateRadarsFromUrl(style: com.mapbox.maps.Style, url: String) {
+    try {
+      loadRadarImages(style)
+      val urlChanged = url != lastRadarsGeoJsonUrlUsed
+      if (!style.styleSourceExists("radars-source")) {
+        val escapedUrl = url.replace("\\", "\\\\").replace("\"", "\\\"")
+        // Otimizado: clustering reativado para reduzir draw calls em alta densidade
+        val sourceJson =
+            """
+            {
+              "type": "geojson",
+              "data": "$escapedUrl",
+              "cluster": true,
+              "clusterRadius": 50,
+              "clusterMaxZoom": 12
+            }
+          """.trimIndent()
+        val sourceVal = com.mapbox.bindgen.Value.fromJson(sourceJson)
+        sourceVal.value?.let { v ->
+          style.addStyleSource("radars-source", v)
+          lastRadarsGeoJsonUrlUsed = url
+          Log.d("MapboxNavigationView", "üåê radars-source carregando de URL (todos os radares)")
+        }
+        addBaseRadarLayersIfNeeded(style)
+      } else if (urlChanged) {
+        val urlValue = com.mapbox.bindgen.Value(url)
+        style.setStyleSourceProperty("radars-source", "data", urlValue)
+        lastRadarsGeoJsonUrlUsed = url
+        Log.d("MapboxNavigationView", "üåê radars-source refetch (URL alterada)")
+        addBaseRadarLayersIfNeeded(style)
+      }
+      updateOverlaySourceFromProps(style)
+      updateBaseSymbolFilterExcludingOverlay(style)
+      ensureHighlightLayerExists(style)
+      ensureOverlayHighlightLayerExists(style)
+      throttleHandler.post { updateHighlightFilterAndPulse() }
+      if (nearbyRadarIds.isNotEmpty()) {
+        throttleHandler.postDelayed({ updateHighlightFilterAndPulse() }, 1200)
+        throttleHandler.postDelayed({ updateHighlightFilterAndPulse() }, 2500)
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro em performUpdateRadarsFromUrl", e)
+    }
+  }
+
+  private fun addBaseRadarLayersIfNeeded(style: com.mapbox.maps.Style) {
+    if (style.styleLayerExists("radars-cluster-layer")) return
+    val aboveRoute =
+        if (style.styleLayerExists(TOP_LEVEL_ROUTE_LINE_LAYER_ID))
+          LayerPosition(TOP_LEVEL_ROUTE_LINE_LAYER_ID, null, null)
+        else null
+    // Ordem conforme docs Mapbox: unclustered PRIMEIRO, depois clusters
+    val baseSymbolFilter = buildBaseSymbolFilterJson()
+    val symbolJson =
+        """
+        {
+          "id": "radars-layer-symbol", "type": "symbol", "source": "radars-source",
+          "filter": $baseSymbolFilter,
+          "layout": {
+            "icon-image": ["get", "iconImage"],
+            "icon-size": ["get", "iconSize"],
+            "icon-allow-overlap": true,
+            "icon-ignore-placement": true,
+            "icon-anchor": "center",
+            "icon-pitch-alignment": "viewport",
+            "icon-rotation-alignment": "viewport"
+          }
+        }
+      """.trimIndent()
+    com.mapbox.bindgen.Value.fromJson(symbolJson).value?.let { style.addStyleLayer(it, aboveRoute) }
+    val clusterJson =
+        """
+        {
+          "id": "radars-cluster-layer", "type": "circle", "source": "radars-source",
+          "filter": ["has", "point_count"],
+          "paint": {
+            "circle-color": ["step", ["get", "point_count"], "#fbbf24", 10, "#8b5800", 50, "#000000"],
+            "circle-radius": ["step", ["get", "point_count"], 20, 10, 30, 50, 40],
+            "circle-stroke-width": 2, "circle-stroke-color": "#fbbf24"
+          }
+        }
+      """.trimIndent()
+    com.mapbox.bindgen.Value.fromJson(clusterJson).value?.let { style.addStyleLayer(it, aboveRoute) }
+    val countJson =
+        """
+        {
+          "id": "radars-cluster-count-layer", "type": "symbol", "source": "radars-source",
+          "filter": ["has", "point_count"],
+          "layout": {
+            "text-field": ["to-string", ["get", "point_count"]],
+            "text-font": ["Open Sans Regular", "Arial Unicode MS Regular"],
+            "text-size": 12
+          },
+          "paint": { "text-color": "#ffffff" }
+        }
+      """.trimIndent()
+    com.mapbox.bindgen.Value.fromJson(countJson).value?.let { style.addStyleLayer(it, aboveRoute) }
+    val highlightFilter = buildHighlightFilterForBaseJson()
+    val highlightJson =
+        """
+        {
+          "id": "radars-highlight-layer", "type": "circle", "source": "radars-source",
+          "filter": $highlightFilter,
+          "paint": {
+            "circle-radius": $PULSE_MIN_RADIUS,
+            "circle-color": "#ef4444",
+            "circle-opacity": $PULSE_MIN_OPACITY,
+            "circle-stroke-width": 2,
+            "circle-stroke-color": "#ffffff",
+            "circle-stroke-opacity": 0.8
+          }
+        }
+      """.trimIndent()
+    com.mapbox.bindgen.Value.fromJson(highlightJson).value?.let { style.addStyleLayer(it, aboveRoute) }
+    if (nearbyRadarIds.isNotEmpty()) startRadarPulseAnimation(style)
+  }
+
+  private fun updateOverlaySourceFromProps(style: com.mapbox.maps.Style) {
+    val overlay = overlayRadars
+    val features =
+        overlay.mapNotNull { r ->
+          if (r.latitude.isNaN() || r.longitude.isNaN()) return@mapNotNull null
+          val typeStr = (r.type ?: "unknown").trim().lowercase()
+          val (icon, size) =
+              when {
+                typeStr.contains("semaforo") || typeStr.contains("camera") -> Pair("radar_semaforico", 0.05)
+                typeStr.contains("movel") || typeStr.contains("mobile") -> Pair("radar_movel", 0.05)
+                typeStr.contains("fixo") || typeStr.contains("placa") -> {
+                  val speeds = listOf(20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160)
+                  val closest = (r.speedLimit ?: 0.0).let { s -> speeds.minByOrNull { kotlin.math.abs(it - s) } ?: 0 }
+                  Pair(if (closest > 0) "placa$closest" else "radar_fixo", 0.18)
+                }
+                else -> Pair("radar_movel", 0.05)
+              }
+          Feature.fromGeometry(
+              Point.fromLngLat(r.longitude, r.latitude),
+              JsonObject().apply {
+                addProperty("id", r.id)
+                addProperty("iconImage", icon)
+                addProperty("iconSize", size)
+              }
+          )
+        }
+    val fc = FeatureCollection.fromFeatures(features)
+    val dataVal = com.mapbox.bindgen.Value.fromJson(fc.toJson()).value ?: return
+    if (style.styleSourceExists("radars-overlay-source")) {
+      style.setStyleSourceProperty("radars-overlay-source", "data", dataVal)
+    } else {
+      val sourceJson = """{ "type": "geojson", "data": ${fc.toJson()} }""".trimIndent()
+      com.mapbox.bindgen.Value.fromJson(sourceJson).value?.let {
+        style.addStyleSource("radars-overlay-source", it)
+      }
+      if (!style.styleLayerExists("radars-overlay-symbol")) {
+        val layerJson =
+            """
+            {
+              "id": "radars-overlay-symbol", "type": "symbol", "source": "radars-overlay-source",
+              "layout": {
+                "icon-image": ["get", "iconImage"],
+                "icon-size": ["get", "iconSize"],
+                "icon-allow-overlap": true,
+                "icon-ignore-placement": true,
+                "icon-anchor": "center"
+              }
+            }
+          """.trimIndent()
+        com.mapbox.bindgen.Value.fromJson(layerJson).value?.let { style.addStyleLayer(it, null) }
+      }
+    }
+  }
+
+  private fun ensureOverlayHighlightLayerExists(style: com.mapbox.maps.Style) {
+    if (!style.styleSourceExists("radars-overlay-source")) return
+    if (style.styleLayerExists("radars-overlay-highlight-layer")) return
+    try {
+      val filter = buildHighlightFilterJson()
+      val json =
+          """
+          {
+            "id": "radars-overlay-highlight-layer", "type": "circle", "source": "radars-overlay-source",
+            "filter": $filter,
+            "paint": {
+              "circle-radius": $PULSE_MIN_RADIUS,
+              "circle-color": "#ef4444",
+              "circle-opacity": $PULSE_MIN_OPACITY,
+              "circle-stroke-width": 2,
+              "circle-stroke-color": "#ffffff",
+              "circle-stroke-opacity": 0.8
+            }
+          }
+        """.trimIndent()
+      com.mapbox.bindgen.Value.fromJson(json).value?.let {
+        style.addStyleLayer(it, LayerPosition("radars-overlay-symbol", null, null))
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao criar overlay highlight", e)
+    }
+  }
+
+  private var radarsUpdateRetryCount = 0
+  private val RADARS_UPDATE_MAX_RETRIES = 12
+
+  private fun performUpdateRadarsOnMap() {
+    if (isUpdatingRadars) {
+      hasPendingUpdate = true
+      return
+    }
+    hasPendingUpdate = false
+
+    val style = getCurrentStyle()
+    if (style == null) {
+      val urlOrNull = radarsGeoJsonUrl
+      val hasData = (urlOrNull != null && urlOrNull.isNotBlank()) ||
+          radars.isNotEmpty() || overlayRadars.isNotEmpty()
+      if (hasData && radarsUpdateRetryCount < RADARS_UPDATE_MAX_RETRIES) {
+        radarsUpdateRetryCount++
+        throttleHandler.postDelayed({ performUpdateRadarsOnMap() }, 400)
+        Log.d("MapboxNavigationView", "‚è≥ Style ainda n√£o carregada, retry $radarsUpdateRetryCount/$RADARS_UPDATE_MAX_RETRIES")
+      } else if (radarsUpdateRetryCount >= RADARS_UPDATE_MAX_RETRIES) {
+        radarsUpdateRetryCount = 0
+      }
+      return
+    }
+    radarsUpdateRetryCount = 0
+
+    val url = radarsGeoJsonUrl
+
+    // CAMINHO URL: base vem do servidor (sem bridge). Waze/RadarBot fazem assim.
+    if (url != null && url.isNotBlank()) {
+      performUpdateRadarsFromUrl(style, url)
+      return
+    }
+
+    // Copy data for thread safety
+    val radarsToDisplay = ArrayList(radars)
+    val loadedIcons = HashSet(loadedIconNames) // Copy set
+
+    isUpdatingRadars = true
+
+    Thread {
+              try {
+                // HEAVY PROCESSING OFF MAIN THREAD
+                val features =
+                        radarsToDisplay.mapNotNull { radar ->
+                          val typeStr = (radar.type ?: "unknown").trim().lowercase()
+                          val (preferredIcon, iconSize) =
+                                  when {
+                                    typeStr.contains("semaforo") ||
+                                            typeStr.contains("camera") ||
+                                            typeStr.contains("fotografica") ->
+                                            Pair("radar_semaforico", 0.05)
+                                    typeStr.contains("movel") || typeStr.contains("mobile") ->
+                                            Pair("radar_movel", 0.05)
+                                    typeStr.contains("fixo") || typeStr.contains("placa") -> {
+                                      val speeds =
+                                              listOf(
+                                                      20,
+                                                      30,
+                                                      40,
+                                                      50,
+                                                      60,
+                                                      70,
+                                                      80,
+                                                      90,
+                                                      100,
+                                                      110,
+                                                      120,
+                                                      130,
+                                                      140,
+                                                      150,
+                                                      160
+                                              )
+                                      val speed = radar.speedLimit ?: 0.0
+                                      val closestSpeed =
+                                              if (speed > 0)
+                                                      speeds.minByOrNull {
+                                                        kotlin.math.abs(it - speed)
+                                                      }
+                                                              ?: 0
+                                              else 0
+                                      val icon =
+                                              if (closestSpeed > 0) "placa$closestSpeed"
+                                              else "radar_fixo"
+                                      Pair(icon, 0.18)
+                                    }
+                                    else -> Pair("radar_movel", 0.05)
+                                  }
+
+                          val iconImage =
+                                  if (loadedIcons.contains(preferredIcon)) preferredIcon
+                                  else if (loadedIcons.contains(preferredIcon.lowercase()))
+                                          preferredIcon.lowercase()
+                                  else "radar_movel"
+
+                          if (radar.latitude.isNaN() ||
+                                          radar.longitude.isNaN() ||
+                                          radar.latitude.isInfinite() ||
+                                          radar.longitude.isInfinite()
+                          ) {
+                            null
+                          } else {
+                            Feature.fromGeometry(
+                                    Point.fromLngLat(radar.longitude, radar.latitude),
+                                    JsonObject().apply {
+                                      addProperty("id", radar.id)
+                                      addProperty("speedLimit", radar.speedLimit?.toString() ?: "")
+                                      addProperty("iconImage", iconImage)
+                                      addProperty("iconSize", iconSize)
+                                      addProperty("radarType", radar.type ?: "")
+                                    }
+                            )
+                          }
+                        }
+
+                val featureCollection = FeatureCollection.fromFeatures(features)
+                val geoJsonString = featureCollection.toJson()
+                val geoJsonHash = geoJsonString.hashCode()
+                if (geoJsonHash == lastAppliedRadarsGeoJsonHash) {
+                  isUpdatingRadars = false
+                  return@Thread
+                }
+
+                // CRITICAL PERFORMANCE: Parse JSON on background thread
+                val dataValueResult = com.mapbox.bindgen.Value.fromJson(geoJsonString)
+                val finalDataValue = dataValueResult.value
+
+                // POST BACK TO MAIN THREAD - defer to next frame to avoid blocking current render
+                val handler = android.os.Handler(android.os.Looper.getMainLooper())
+                val applyUpdate: Runnable = object : Runnable {
+                  override fun run() {
+                    Choreographer.getInstance().postFrameCallback {
+                      try {
+                        if (isDestroyed) {
+                          isUpdatingRadars = false
+                          return@postFrameCallback
+                        }
+                        val currentStyle = getCurrentStyle()
+                        if (currentStyle == null || finalDataValue == null) {
+                          isUpdatingRadars = false
+                          return@postFrameCallback
+                        }
+                        val now = System.currentTimeMillis()
+                        if (now - lastStyleUpdateTimeMs < STYLE_UPDATE_MIN_INTERVAL_MS) {
+                          throttleHandler.postDelayed(
+                            this,
+                            STYLE_UPDATE_MIN_INTERVAL_MS - (now - lastStyleUpdateTimeMs)
+                          )
+                          return@postFrameCallback
+                        }
+                        lastStyleUpdateTimeMs = now
+
+                        if (currentStyle.styleSourceExists("radars-source")) {
+                          currentStyle.setStyleSourceProperty("radars-source", "data", finalDataValue)
+                          lastAppliedRadarsGeoJsonHash = geoJsonHash
+                          ensureHighlightLayerExists(currentStyle)
+                          throttleHandler.post { updateHighlightFilterAndPulse() }
+                        } else {
+                      loadRadarImages(currentStyle)
+
+                      // CONFIGURA√á√ÉO DO CLUSTER NA FONTE
+                      val sourceJson =
+                              """
+                          { 
+                            "type": "geojson", 
+                            "data": $geoJsonString,
+                            "cluster": true,
+                            "clusterRadius": 50,
+                            "clusterMaxZoom": 14
+                          }
+                        """.trimIndent()
+
+                      val sourceValueResult = com.mapbox.bindgen.Value.fromJson(sourceJson)
+                      sourceValueResult.value?.let { value ->
+                        currentStyle.addStyleSource("radars-source", value)
+                        lastAppliedRadarsGeoJsonHash = geoJsonHash
+                      }
+
+                      // 1. Layer de Clusters
+                      val clusterLayerJson =
+                              """
+                          {
+                            "id": "radars-cluster-layer", "type": "circle", "source": "radars-source",
+                            "filter": ["has", "point_count"],
+                            "paint": {
+                              "circle-color": [
+                                "step", ["get", "point_count"],
+                                "#fbbf24", 10, "#8b5800", 50, "#000000"
+                              ],
+                              "circle-radius": [
+                                "step", ["get", "point_count"],
+                                20, 10, 30, 50, 40
+                              ],
+                              "circle-stroke-width": 2, "circle-stroke-color": "#fbbf24"
+                            }
+                          }
+                        """.trimIndent()
+                      val clusterVal = com.mapbox.bindgen.Value.fromJson(clusterLayerJson)
+                      clusterVal.value?.let { value -> currentStyle.addStyleLayer(value, null) }
+
+                      // 2. Layer de Contagem
+                      val countLayerJson =
+                              """
+                          {
+                            "id": "radars-cluster-count-layer", "type": "symbol", "source": "radars-source",
+                            "filter": ["has", "point_count"],
+                            "layout": {
+                              "text-field": ["to-string", ["get", "point_count"]],
+                              "text-font": ["Open Sans Regular", "Arial Unicode MS Regular"],
+                              "text-size": 12 
+                            },
+                            "paint": { "text-color": "#ffffff" }
+                          }
+                        """.trimIndent()
+                      val countVal = com.mapbox.bindgen.Value.fromJson(countLayerJson)
+                      countVal.value?.let { value -> currentStyle.addStyleLayer(value, null) }
+
+                      // 2.5 Highlight layer (pulse para radares pr√≥ximos) ‚Äî filter por nearbyRadarIds
+                      val highlightFilter = buildHighlightFilterJson()
+                      val highlightLayerJson =
+                              """
+                          {
+                            "id": "radars-highlight-layer", "type": "circle", "source": "radars-source",
+                            "filter": $highlightFilter,
+                            "paint": {
+                              "circle-radius": $PULSE_MIN_RADIUS,
+                              "circle-color": "#ef4444",
+                              "circle-opacity": $PULSE_MIN_OPACITY,
+                              "circle-stroke-width": 2,
+                              "circle-stroke-color": "#ffffff",
+                              "circle-stroke-opacity": 0.8
+                            }
+                          }
+                        """.trimIndent()
+                      val highlightVal = com.mapbox.bindgen.Value.fromJson(highlightLayerJson)
+                      highlightVal.value?.let { value -> currentStyle.addStyleLayer(value, null) }
+                      if (nearbyRadarIds.isNotEmpty()) startRadarPulseAnimation(currentStyle)
+
+                      // 3. Symbol Layer
+                      val layerJson =
+                              """
+                          {
+                            "id": "radars-layer-symbol", "type": "symbol", "source": "radars-source",
+                            "filter": ["!", ["has", "point_count"]],
+                            "layout": {
+                              "icon-image": ["get", "iconImage"], "icon-size": ["get", "iconSize"],
+                              "icon-allow-overlap": true, "icon-ignore-placement": true,
+                              "icon-anchor": "center", "icon-pitch-alignment": "viewport", "icon-rotation-alignment": "viewport"
+                            }
+                          }
+                        """.trimIndent()
+
+                      val layerValue = com.mapbox.bindgen.Value.fromJson(layerJson)
+                      layerValue.value?.let { value -> currentStyle.addStyleLayer(value, null) }
+                        }
+                      } catch (e: Exception) {
+                        Log.e("MapboxNavigationView", "Erro ao atualizar UI de radares", e)
+                      } finally {
+                        isUpdatingRadars = false
+                        if (hasPendingUpdate) {
+                          handler.post { updateRadarsOnMap() }
+                        }
+                      }
+                    }
+                  }
+                }
+                handler.post(applyUpdate)
+              } catch (e: Exception) {
+                Log.e("MapboxNavigationView", "Erro ao processar radares em background", e)
+                isUpdatingRadars = false
+                // Check if another update was requested while we were processing
+                if (hasPendingUpdate) {
+                  handler.post { updateRadarsOnMap() }
+                }
+              }
+            }
+            .start()
+  }
+
+  private val PULSE_INTERVAL_MS = 120L
+  private val PULSE_MIN_RADIUS = 26.0
+  private val PULSE_MAX_RADIUS = 44.0
+  private val PULSE_MIN_OPACITY = 0.45
+  private val PULSE_MAX_OPACITY = 0.75
+
+  private fun buildHighlightFilterJson(): String {
+    val ids = nearbyRadarIds.toList()
+    if (ids.isEmpty()) return """["==", true, false]"""
+    val escaped = ids.joinToString(",") { "\"${it.replace("\\", "\\\\").replace("\"", "\\\"")}\"" }
+    // to-string garante match mesmo se GeoJSON properties.id vier como n√∫mero
+    return """["all", ["!", ["has", "point_count"]], ["in", ["to-string", ["get", "id"]], ["literal", [$escaped]]]]"""
+  }
+
+  private fun buildHighlightFilterForBaseJson(): String {
+    val highlight = buildHighlightFilterJson()
+    val excludeOverlay = buildExcludeOverlayFilterJson()
+    return """["all", $highlight, $excludeOverlay]"""
+  }
+
+  private fun buildExcludeOverlayFilterJson(): String {
+    val ids = overlayRadars.map { it.id }
+    if (ids.isEmpty()) return """["==", true, true]"""
+    val escaped = ids.joinToString(",") { "\"${it.replace("\\", "\\\\").replace("\"", "\\\"")}\"" }
+    return """["!", ["in", ["get", "id"], ["literal", [$escaped]]]]"""
+  }
+
+  private fun buildBaseSymbolFilterJson(): String {
+    // N√£o excluir por overlay na base URL:
+    // em alguns cen√°rios o filtro por id estava ocultando todos os pontos unclustered.
+    return """["!", ["has", "point_count"]]"""
+  }
+
+  private fun updateBaseSymbolFilterExcludingOverlay(style: com.mapbox.maps.Style) {
+    try {
+      val filterJson = buildBaseSymbolFilterJson()
+      val filterValue = com.mapbox.bindgen.Value.fromJson(filterJson).value ?: return
+      if (style.styleLayerExists("radars-layer-symbol"))
+        style.setStyleLayerProperty("radars-layer-symbol", "filter", filterValue)
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao atualizar filter base symbol", e)
+    }
+  }
+
+  /** Garante que a layer de highlight existe (ex.: ap√≥s atualizar s√≥ o source). */
+  private fun ensureHighlightLayerExists(style: com.mapbox.maps.Style) {
+    if (style.styleLayerExists("radars-highlight-layer")) return
+    if (!style.styleSourceExists("radars-source")) return
+    try {
+      val highlightFilter = buildHighlightFilterForBaseJson()
+      val highlightLayerJson =
+          """
+          {
+            "id": "radars-highlight-layer", "type": "circle", "source": "radars-source",
+            "filter": $highlightFilter,
+            "paint": {
+              "circle-radius": $PULSE_MIN_RADIUS,
+              "circle-color": "#ef4444",
+              "circle-opacity": $PULSE_MIN_OPACITY,
+              "circle-stroke-width": 2,
+              "circle-stroke-color": "#ffffff",
+              "circle-stroke-opacity": 0.8
+            }
+          }
+        """.trimIndent()
+      val highlightVal = com.mapbox.bindgen.Value.fromJson(highlightLayerJson)
+      highlightVal.value?.let { value ->
+        val position =
+            if (style.styleLayerExists("radars-cluster-count-layer"))
+                LayerPosition("radars-cluster-count-layer", null, null)
+            else null
+        style.addStyleLayer(value, position)
+        Log.d("MapboxNavigationView", "‚úÖ radars-highlight-layer criada (ensure)")
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao criar highlight layer", e)
+    }
+  }
+
+  private var highlightRetryCount = 0
+
+  private fun updateHighlightFilterAndPulse() {
+    val style = getCurrentStyle()
+    if (style == null) {
+      if (nearbyRadarIds.isNotEmpty() && highlightRetryCount < 12) {
+        highlightRetryCount++
+        throttleHandler.postDelayed(
+          {
+            updateHighlightFilterAndPulse()
+          },
+          200
+        )
+      }
+      return
+    }
+    highlightRetryCount = 0
+    try {
+      ensureHighlightLayerExists(style)
+      val baseFilterJson = buildHighlightFilterForBaseJson()
+      val overlayFilterJson = buildHighlightFilterJson()
+      val baseFilterValue = com.mapbox.bindgen.Value.fromJson(baseFilterJson).value ?: return
+      val overlayFilterValue = com.mapbox.bindgen.Value.fromJson(overlayFilterJson).value ?: return
+      if (style.styleLayerExists("radars-highlight-layer")) {
+        style.setStyleLayerProperty("radars-highlight-layer", "filter", baseFilterValue)
+      }
+      if (style.styleLayerExists("radars-overlay-highlight-layer")) {
+        style.setStyleLayerProperty("radars-overlay-highlight-layer", "filter", overlayFilterValue)
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao atualizar filter do highlight", e)
+    }
+    if (nearbyRadarIds.isNotEmpty()) {
+      startRadarPulseAnimation(style)
+    } else {
+      pulseAnimationRunnable?.let { pulseHandler.removeCallbacks(it) }
+      pulseAnimationRunnable = null
+    }
+  }
+
+  private fun startRadarPulseAnimation(style: com.mapbox.maps.Style) {
+    pulseAnimationRunnable?.let { pulseHandler.removeCallbacks(it) }
+    if (nearbyRadarIds.isEmpty()) return
+    pulseAnimationRunnable =
+        object : Runnable {
+          override fun run() {
+            try {
+              if (!style.styleLayerExists("radars-highlight-layer") || nearbyRadarIds.isEmpty()) {
+                return
+              }
+              pulseAnimationValue += 0.04f
+              if (pulseAnimationValue > 1f) pulseAnimationValue = 0f
+              val sine = kotlin.math.sin(pulseAnimationValue * Math.PI).toFloat()
+              val radius = PULSE_MIN_RADIUS + (PULSE_MAX_RADIUS - PULSE_MIN_RADIUS) * sine
+              val opacity = PULSE_MIN_OPACITY + (PULSE_MAX_OPACITY - PULSE_MIN_OPACITY) * sine
+              Choreographer.getInstance().postFrameCallback {
+                try {
+                  if (isDestroyed) return@postFrameCallback
+                  val s = getCurrentStyle() ?: return@postFrameCallback
+                  val rv = com.mapbox.bindgen.Value(radius)
+                  val ov = com.mapbox.bindgen.Value(opacity)
+                  if (s.styleLayerExists("radars-highlight-layer")) {
+                    s.setStyleLayerProperty("radars-highlight-layer", "circle-radius", rv)
+                    s.setStyleLayerProperty("radars-highlight-layer", "circle-opacity", ov)
+                  }
+                  if (s.styleLayerExists("radars-overlay-highlight-layer")) {
+                    s.setStyleLayerProperty("radars-overlay-highlight-layer", "circle-radius", rv)
+                    s.setStyleLayerProperty("radars-overlay-highlight-layer", "circle-opacity", ov)
+                  }
+                } catch (_: Exception) { }
+              }
+              pulseHandler.postDelayed(this, PULSE_INTERVAL_MS)
+            } catch (e: Exception) {
+              Log.e("MapboxNavigationView", "Erro no pulse", e)
+            }
+          }
+        }
+    pulseHandler.postDelayed(pulseAnimationRunnable!!, PULSE_INTERVAL_MS)
+  }
+
+  private fun updateNearbyRadarsInSource() {
+    // Evita re-render completo em cada mudan√ßa de nearby ids.
+  }
+
+  /** Mostra rotas alternativas no mapa com callouts e informa√ß√µes */
+  private fun showAlternativeRoutes(routes: List<NavigationRoute>) {
+    val style = getCurrentStyle() ?: return
+
+    try {
+      // Criar features para cada rota alternativa com informa√ß√µes
+      val alternativeRouteFeatures = mutableListOf<Feature>()
+
+      routes.forEachIndexed { index, route ->
+        val directionsRoute = route.directionsRoute
+        val routeGeometry = directionsRoute.geometry() ?: return@forEachIndexed
+
+        // Converter geometria para LineString
+        val routeGeoJsonString = routeGeometry.toString()
+        val lineString = LineString.fromJson(routeGeoJsonString)
+        if (lineString == null) return@forEachIndexed
+
+        val routeCoordinates = lineString.coordinates()
+        if (routeCoordinates.isEmpty()) return@forEachIndexed
+
+        // Obter informa√ß√µes da rota
+        val totalDistance = directionsRoute.distance() ?: 0.0
+        val totalDuration = directionsRoute.duration() ?: 0.0
+
+        // Criar callout no ponto m√©dio da rota
+        val midPointIndex = routeCoordinates.size / 2
+        val midCoord: Point = routeCoordinates[midPointIndex]
+        val midPoint = Point.fromLngLat(midCoord.longitude(), midCoord.latitude())
+
+        // Formatar informa√ß√µes
+        val distanceKm = totalDistance / 1000.0
+        val durationMinutes = (totalDuration / 60).toInt()
+
+        val distanceText =
+                if (distanceKm < 1.0) {
+                  "${totalDistance.toInt()}m"
+                } else {
+                  String.format("%.1f", distanceKm) + "km"
+                }
+
+        val timeText =
+                when {
+                  durationMinutes < 60 -> "${durationMinutes}min"
+                  else -> "${durationMinutes / 60}h ${durationMinutes % 60}min"
+                }
+
+        val routeLabel =
+                when (index) {
+                  0 -> "Rota 1 (Recomendada)"
+                  1 -> "Rota 2"
+                  2 -> "Rota 3"
+                  else -> "Rota ${index + 1}"
+                }
+
+        val feature =
+                Feature.fromGeometry(
+                        midPoint,
+                        JsonObject().apply {
+                          addProperty("routeIndex", index.toString())
+                          addProperty("distance", distanceText)
+                          addProperty("time", timeText)
+                          addProperty("label", routeLabel)
+                          addProperty("distanceKm", java.lang.Double.valueOf(distanceKm))
+                          addProperty("durationMinutes", java.lang.Integer.valueOf(durationMinutes))
+                        }
+                )
+        alternativeRouteFeatures.add(feature)
+      }
+
+      if (alternativeRouteFeatures.isEmpty()) {
+        return
+      }
+
+      val featureCollection = FeatureCollection.fromFeatures(alternativeRouteFeatures.toList())
+      val geoJsonString = featureCollection.toJson()
+      val sourceJson =
+              """
+        {
+          "type": "geojson",
+          "data": $geoJsonString
+        }
+      """.trimIndent()
+
+      val sourceValueResult = com.mapbox.bindgen.Value.fromJson(sourceJson)
+      when (val value = sourceValueResult.value) {
+        null -> {
+          Log.e(
+                  "MapboxNavigationView",
+                  "Erro ao criar source de rotas alternativas: ${sourceValueResult.error}"
+          )
+        }
+        else -> {
+          // Remover source e layer existentes
+          if (style.styleSourceExists("alternative-routes-callouts-source")) {
+            style.removeStyleSource("alternative-routes-callouts-source")
+          }
+          if (style.styleLayerExists("alternative-routes-callouts-layer")) {
+            style.removeStyleLayer("alternative-routes-callouts-layer")
+          }
+
+          // Adicionar source
+          style.addStyleSource("alternative-routes-callouts-source", value)
+
+          // Criar SymbolLayer para callouts das rotas alternativas
+          val layerJson =
+                  """
+            {
+              "id": "alternative-routes-callouts-layer",
+              "type": "symbol",
+              "source": "alternative-routes-callouts-source",
+              "layout": {
+                "text-field": ["concat", ["get", "label"], "\n", ["get", "distance"], " ‚Ä¢ ", ["get", "time"]],
+                "text-size": 12,
+                "text-anchor": "center",
+                "text-offset": [0, 0],
+                "text-allow-overlap": true,
+                "text-ignore-placement": true
+              },
+              "paint": {
+                "text-color": "#60A5FA",
+                "text-halo-color": "#1F2937",
+                "text-halo-width": 2
+              }
+            }
+          """.trimIndent()
+
+          val layerValueResult = com.mapbox.bindgen.Value.fromJson(layerJson)
+          when (val layerValue = layerValueResult.value) {
+            null -> {
+              Log.e(
+                      "MapboxNavigationView",
+                      "Erro ao criar layer de rotas alternativas: ${layerValueResult.error}"
+              )
+            }
+            else -> {
+              style.addStyleLayer(layerValue, null)
+              Log.d(
+                      "MapboxNavigationView",
+                      "‚úÖ Rotas alternativas exibidas: ${alternativeRouteFeatures.size} rotas"
+              )
+            }
+          }
+        }
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao mostrar rotas alternativas", e)
+    }
+  }
+
+  /**
+   * Promove uma rota alternativa para ser a rota principal. A sele√ß√£o √© feita tocando no callout da
+   * rota alternativa no mapa.
+   */
+  private fun selectAlternativeRoute(selectedIndex: Int, source: String) {
+    if (selectedIndex < 0 || selectedIndex >= alternativeRoutes.size) {
+      return
+    }
+
+    // J√° √© a rota principal
+    if (selectedIndex == 0) {
+      return
+    }
+
+    try {
+      val selected = alternativeRoutes[selectedIndex]
+      val reordered = mutableListOf<NavigationRoute>()
+      reordered.add(selected)
+      alternativeRoutes.forEachIndexed { index, route ->
+        if (index != selectedIndex) {
+          reordered.add(route)
+        }
+      }
+      alternativeRoutes = reordered.take(3)
+      currentRouteIndex = 0
+
+      mapboxNavigation?.setNavigationRoutes(alternativeRoutes)
+      Log.d(
+              "MapboxNavigationView",
+              "‚úÖ Rota alternativa selecionada: index=$selectedIndex (source=$source)"
+      )
+
+      // Atualiza a interface para mostrar a rota selecionada como principal
+      updateRouteVisualizationAfterSelection(selectedIndex)
+
+      // Notificar React (se quiser mostrar UI / estado)
+      val ev = Arguments.createMap()
+      ev.putInt("routeIndex", selectedIndex)
+      ev.putString("source", source)
+      safeEmitEvent("onRouteAlternativeSelected", ev)
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao selecionar rota alternativa", e)
+    }
+  }
+
+  /** Atualiza a visualiza√ß√£o das rotas ap√≥s uma rota alternativa ser selecionada como principal */
+  private fun updateRouteVisualizationAfterSelection(selectedIndex: Int) {
+    try {
+      // Atualiza a apar√™ncia das rotas para mostrar qual √© a principal
+      Log.d(
+              "MapboxNavigationView",
+              "üîÑ Atualizando visualiza√ß√£o ap√≥s sele√ß√£o da rota: $selectedIndex"
+      )
+
+      // Aqui poder√≠amos atualizar a opacidade ou cor das rotas alternativas
+      // para destacar a rota principal
+
+      // Por exemplo, poder√≠amos alterar a espessura ou cor da rota principal
+      // em rela√ß√£o √†s demais rotas alternativas
+
+      // Atualizar tamb√©m os callouts para refletir a nova ordem
+      val style = binding.mapView.mapboxMap.style
+      if (style != null) {
+        // Atualizar os callouts das rotas alternativas
+        showAlternativeRoutes(alternativeRoutes)
+      }
+    } catch (e: Exception) {
+      Log.e("MapboxNavigationView", "Erro ao atualizar visualiza√ß√£o ap√≥s sele√ß√£o", e)
+    }
+  }
+
+  private fun setupRouteAndCalloutClickListener() {
+    // Adiciona listener de clique no mapa para permitir sele√ß√£o de rota alternativa
+    binding.mapView.getMapboxMap().addOnMapClickListener { point ->
+      try {
+        Log.d(
+                "MapboxNavigationView",
+                "üñ±Ô∏è Mapa clicado - verificando se √© clique em rota alternativa"
+        )
+
+        // A funcionalidade de sele√ß√£o de rota por clique est√° implementada
+        // Apenas alternamos entre as rotas dispon√≠veis quando o usu√°rio clica no mapa
+        if (alternativeRoutes.size > 1) {
+          // Seleciona a pr√≥xima rota na lista
+          val currentIndex = currentRouteIndex
+          val nextIndex = if (currentIndex < alternativeRoutes.size - 1) currentIndex + 1 else 0
+
+          Log.d("MapboxNavigationView", "üîÑ Alternando rota: $currentIndex -> $nextIndex")
+          selectAlternativeRoute(nextIndex, "map_click")
+        }
+
+        // Notificar que o clique foi detectado
+        val event = Arguments.createMap()
+        event.putDouble("longitude", point.longitude())
+        event.putDouble("latitude", point.latitude())
+        safeEmitEvent("onMapClick", event)
+      } catch (e: Exception) {
+        Log.e("MapboxNavigationView", "Erro ao processar clique no mapa", e)
+      }
+      false // Permitir que outros listeners processem o clique tamb√©m
+    }
+  }
 }
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationViewManager.kt b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationViewManager.kt
index 03fad26..1586bc5 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationViewManager.kt
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/java/com/mapboxnavigation/MapboxNavigationViewManager.kt
@@ -11,6 +11,10 @@ import com.mapbox.geojson.Point
 
 @ReactModule(name = MapboxNavigationViewManager.NAME)
 class MapboxNavigationViewManager(private var reactContext: ReactApplicationContext): MapboxNavigationViewManagerSpec<MapboxNavigationView>() {
+  private var lastBaseRadarsPayloadHash: Int = 0
+  private var lastOverlayRadarsPayloadHash: Int = 0
+  private var lastNearbyRadarIdsHash: Int = 0
+
   override fun getName(): String {
     return NAME
   }
@@ -25,13 +29,20 @@ class MapboxNavigationViewManager(private var reactContext: ReactApplicationCont
   }
 
   override fun getExportedCustomDirectEventTypeConstants(): MutableMap<String, Map<String, String>> {
-    return MapBuilder.of(
-      "onLocationChange", MapBuilder.of("registrationName", "onLocationChange"),
-      "onError", MapBuilder.of("registrationName", "onError"),
-      "onCancelNavigation", MapBuilder.of("registrationName", "onCancelNavigation"),
-      "onArrive", MapBuilder.of("registrationName", "onArrive"),
-      "onRouteProgressChange", MapBuilder.of("registrationName", "onRouteProgressChange"),
-    )
+    return MapBuilder.builder<String, Map<String, String>>()
+      .put("onLocationChange", MapBuilder.of("registrationName", "onLocationChange"))
+      .put("onError", MapBuilder.of("registrationName", "onError"))
+      .put("onCancelNavigation", MapBuilder.of("registrationName", "onCancelNavigation"))
+      .put("onArrive", MapBuilder.of("registrationName", "onArrive"))
+      .put("onRouteProgressChange", MapBuilder.of("registrationName", "onRouteProgressChange"))
+      .put("onOffRoute", MapBuilder.of("registrationName", "onOffRoute"))
+      .put("onRouteAlternativeSelected", MapBuilder.of("registrationName", "onRouteAlternativeSelected"))
+      .put("onMapClick", MapBuilder.of("registrationName", "onMapClick"))
+      .put("onRadarTap", MapBuilder.of("registrationName", "onRadarTap"))
+      .put("onRouteChanged", MapBuilder.of("registrationName", "onRouteChanged"))
+      .put("onMuteChange", MapBuilder.of("registrationName", "onMuteChange"))
+      .put("onVoiceInstructionText", MapBuilder.of("registrationName", "onVoiceInstructionText"))
+      .build()
   }
 
   @ReactProp(name = "startOrigin")
@@ -109,6 +120,111 @@ class MapboxNavigationViewManager(private var reactContext: ReactApplicationCont
     view?.setMute(value)
   }
 
+  @ReactProp(name = "volume")
+  fun setVolume(view: MapboxNavigationView?, value: Double) {
+    view?.setVolume(value.toFloat())
+  }
+
+  /** URL do GeoJSON (ex: https://api/radars/geojson) ‚Äî nativo carrega todos os radares sem bridge */
+  @ReactProp(name = "radarsGeoJsonUrl")
+  fun setRadarsGeoJsonUrl(view: MapboxNavigationView?, value: String?) {
+    view?.setRadarsGeoJsonUrl(value)
+  }
+
+  /** Base: radares via bridge (fallback quando radarsGeoJsonUrl n√£o est√° definido) */
+  @ReactProp(name = "radars")
+  fun setBaseRadars(view: MapboxNavigationView?, value: ReadableArray?) {
+    val v = view ?: return
+    reactContext.runOnUiQueueThread {
+      if (value == null || value.size() == 0) {
+        lastBaseRadarsPayloadHash = 0
+        v.setBaseRadars(listOf())
+        return@runOnUiQueueThread
+      }
+      val list = parseRadarsFromArray(value)
+      val h = list.joinToString("|") { "${it.id}:${it.latitude}:${it.longitude}" }.hashCode()
+      if (h == lastBaseRadarsPayloadHash) return@runOnUiQueueThread
+      lastBaseRadarsPayloadHash = h
+      v.setBaseRadars(list)
+    }
+  }
+
+  /** Overlay: SOMENTE radares reportados ‚Äî enviada ao reportar (lista pequena) */
+  @ReactProp(name = "overlayRadars")
+  fun setOverlayRadars(view: MapboxNavigationView?, value: ReadableArray?) {
+    val v = view ?: return
+    reactContext.runOnUiQueueThread {
+      if (value == null || value.size() == 0) {
+        lastOverlayRadarsPayloadHash = 0
+        v.setOverlayRadars(listOf())
+        return@runOnUiQueueThread
+      }
+      val list = parseRadarsFromArray(value)
+      val h = list.joinToString("|") { "${it.id}:${it.latitude}:${it.longitude}:${it.speedLimit ?: 0}:${it.type ?: ""}" }.hashCode()
+      if (h == lastOverlayRadarsPayloadHash) return@runOnUiQueueThread
+      lastOverlayRadarsPayloadHash = h
+      v.setOverlayRadars(list)
+    }
+  }
+
+  private fun parseRadarsFromArray(value: ReadableArray): List<RadarPoint> {
+    val list = mutableListOf<RadarPoint>()
+    for (i in 0 until value.size()) {
+      val item = value.getMap(i) ?: continue
+      val id = item.getString("id") ?: ""
+      if (!item.hasKey("latitude") || !item.hasKey("longitude")) continue
+      val lat = item.getDouble("latitude")
+      val lon = item.getDouble("longitude")
+      val speedLimit = when {
+        item.hasKey("speedLimit") -> item.getDouble("speedLimit")
+        item.hasKey("velocidadeLeve") -> item.getDouble("velocidadeLeve")
+        else -> null
+      }
+      val type = when {
+        item.hasKey("type") -> item.getString("type")
+        item.hasKey("tipoRadar") -> item.getString("tipoRadar")
+        else -> null
+      }
+      list.add(RadarPoint(id, lat, lon, speedLimit, type))
+    }
+    return list
+  }
+
+  @ReactProp(name = "nearbyRadarIds")
+  fun setNearbyRadarIds(view: MapboxNavigationView?, value: ReadableArray?) {
+    if (value == null) {
+      lastNearbyRadarIdsHash = 0
+      view?.setNearbyRadarIds(emptySet())
+      return
+    }
+    val hashBuilder = StringBuilder(value.size() * 12)
+    val set = mutableSetOf<String>()
+    for (i in 0 until value.size()) {
+      val s = value.getString(i) ?: ""
+      set.add(s)
+      hashBuilder.append(s).append('|')
+    }
+    val h = hashBuilder.toString().hashCode()
+    if (h == lastNearbyRadarIdsHash) return
+    lastNearbyRadarIdsHash = h
+    view?.setNearbyRadarIds(set)
+  }
+
+  @ReactProp(name = "bottomPadding")
+  fun setBottomPadding(view: MapboxNavigationView?, value: Double) {
+    view?.setBottomPadding(value)
+  }
+
+  @ReactProp(name = "recenterTrigger")
+  fun setRecenterTrigger(view: MapboxNavigationView?, value: Int) {
+    view?.setRecenterTrigger(value)
+  }
+
+  @ReactProp(name = "ttsVoiceId")
+  fun setTtsVoiceId(view: MapboxNavigationView?, value: String?) {
+    view?.setTtsVoiceId(value)
+  }
+
   companion object {
     const val NAME = "MapboxNavigationView"
   }
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/navigation_view.xml b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/navigation_view.xml
index c00affd..3b8ef11 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/navigation_view.xml
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/layout/navigation_view.xml
@@ -13,31 +13,100 @@
     app:layout_constraintStart_toStartOf="parent"
     app:layout_constraintTop_toTopOf="parent" />
 
+  <TextView
+    android:id="@+id/roadNameText"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:layout_marginBottom="8dp"
+    android:background="#FFFFFF"
+    android:paddingHorizontal="16dp"
+    android:paddingVertical="7dp"
+    android:textColor="#212121"
+    android:textSize="18sp"
+    android:textStyle="bold"
+    android:visibility="gone"
+    app:layout_constraintBottom_toTopOf="@id/tripProgressCard"
+    app:layout_constraintEnd_toEndOf="parent"
+    app:layout_constraintStart_toStartOf="parent" />
+
   <androidx.cardview.widget.CardView
     android:id="@+id/tripProgressCard"
     android:layout_width="0dp"
     android:layout_height="wrap_content"
     android:visibility="invisible"
-    app:cardElevation="8dp"
-    app:cardUseCompatPadding="false"
+    app:cardCornerRadius="10dp"
+    app:cardElevation="0dp"
+    app:cardBackgroundColor="#FFFFFF"
     app:layout_constraintBottom_toBottomOf="parent"
     app:layout_constraintEnd_toEndOf="parent"
     app:layout_constraintStart_toStartOf="parent">
 
-    <com.mapbox.navigation.ui.components.tripprogress.view.MapboxTripProgressView
-      android:id="@+id/tripProgressView"
+    <androidx.constraintlayout.widget.ConstraintLayout
       android:layout_width="match_parent"
-      android:layout_margin="8dp"
-      android:layout_height="wrap_content" />
-
-    <ImageView
-      android:id="@+id/stop"
-      android:layout_width="41dp"
-      android:layout_height="41dp"
-      android:layout_gravity="end|center_vertical"
-      android:layout_marginEnd="12dp"
-      app:srcCompat="@android:drawable/ic_delete"
-      android:contentDescription="@string/delete_icon"/>
+      android:layout_height="wrap_content"
+      android:padding="8dp">
+
+      <LinearLayout
+        android:id="@+id/customTripProgressContainer"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:layout_marginEnd="12dp"
+        android:orientation="horizontal"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toStartOf="@+id/stopContainer"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintTop_toTopOf="parent">
+
+        <TextView
+          android:id="@+id/timeRemainingText"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:text="-- min"
+          android:textColor="#212121"
+          android:textSize="18sp"
+          android:textStyle="bold" />
+
+        <TextView
+          android:id="@+id/distanceRemainingText"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_marginStart="12dp"
+          android:text="-- km"
+          android:textColor="#666666"
+          android:textSize="16sp" />
+
+        <TextView
+          android:id="@+id/etaText"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_marginStart="12dp"
+          android:text="--:--"
+          android:textColor="#666666"
+          android:textSize="16sp" />
+      </LinearLayout>
+
+      <androidx.cardview.widget.CardView
+        android:id="@+id/stopContainer"
+        android:layout_width="48dp"
+        android:layout_height="48dp"
+        android:layout_marginEnd="8dp"
+        app:cardBackgroundColor="#FF3B30"
+        app:cardCornerRadius="24dp"
+        app:cardElevation="0dp"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintTop_toTopOf="parent">
+
+        <ImageView
+          android:id="@+id/stop"
+          android:layout_width="24dp"
+          android:layout_height="24dp"
+          android:layout_gravity="center"
+          android:tint="#FFFFFF"
+          app:srcCompat="@android:drawable/ic_menu_close_clear_cancel"
+          android:contentDescription="@string/delete_icon"/>
+      </androidx.cardview.widget.CardView>
+    </androidx.constraintlayout.widget.ConstraintLayout>
   </androidx.cardview.widget.CardView>
 
   <com.mapbox.navigation.ui.components.maneuver.view.MapboxManeuverView
@@ -60,6 +129,16 @@
     app:layout_constraintEnd_toEndOf="parent"
     app:layout_constraintTop_toBottomOf="@id/maneuverView" />
 
+  <com.mapbox.navigation.ui.components.speedlimit.view.MapboxSpeedInfoView
+    android:id="@+id/speedLimitView"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:layout_marginTop="500dp"
+    android:layout_marginStart="8dp"
+    android:visibility="invisible"
+    app:layout_constraintStart_toStartOf="parent"
+    app:layout_constraintTop_toBottomOf="@id/maneuverView" />
+
   <com.mapbox.navigation.ui.components.maps.camera.view.MapboxRouteOverviewButton
     android:id="@+id/routeOverview"
     android:layout_width="wrap_content"
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/values/styles.xml b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/values/styles.xml
index 4c3d3c3..b0dd903 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/values/styles.xml
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/android/src/main/res/values/styles.xml
@@ -12,4 +12,16 @@
         <item name="android:textColor">#FFFFFF</item>
         <item name="android:textSize">21sp</item>
     </style>
+
+    <!-- Trip Progress (Card Inferior) - Usando parent vazio para evitar overrides de tema Dark -->
+    <style name="TripProgressPrimaryTextAppearance">
+        <item name="android:textColor">#212121</item>
+        <item name="android:textStyle">bold</item>
+        <item name="android:textSize">18sp</item>
+    </style>
+
+    <style name="TripProgressSecondaryTextAppearance">
+        <item name="android:textColor">#666666</item>
+        <item name="android:textSize">14sp</item>
+    </style>
 </resources>
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/ios/MapboxNavigationView.swift b/node_modules/@pawan-pk/react-native-mapbox-navigation/ios/MapboxNavigationView.swift
index 05c943f..7a8457d 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/ios/MapboxNavigationView.swift
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/ios/MapboxNavigationView.swift
@@ -2,6 +2,8 @@
 import MapboxCoreNavigation
 import MapboxNavigation
 import MapboxDirections
+import MapboxMaps
+import Turf
 
 extension UIView {
     var parentViewController: UIViewController? {
@@ -60,17 +62,45 @@ public class MapboxNavigationView: UIView, NavigationViewControllerDelegate {
     @objc var hideStatusView: Bool = false
     @objc var mute: Bool = false
     @objc var distanceUnit: NSString = "imperial"
-    @objc var language: NSString = "us"
-    @objc var destinationTitle: NSString = "Destination"
+    @objc var language: NSString = "pt-BR"
+    @objc var destinationTitle: NSString = "Destino"
 
     @objc var onLocationChange: RCTDirectEventBlock?
     @objc var onRouteProgressChange: RCTDirectEventBlock?
     @objc var onError: RCTDirectEventBlock?
     @objc var onCancelNavigation: RCTDirectEventBlock?
     @objc var onArrive: RCTDirectEventBlock?
+    @objc var onRadarTap: RCTDirectEventBlock?
     @objc var vehicleMaxHeight: NSNumber?
     @objc var vehicleMaxWidth: NSNumber?
 
+    // Radares (paridade com Android)
+    @objc var radarsGeoJsonUrl: NSString? {
+        didSet {
+            if let vc = navViewController, let mv = vc.navigationMapView?.mapView {
+                performUpdateRadars(mapView: mv)
+            }
+        }
+    }
+    @objc var nearbyRadarIds: NSArray? {
+        didSet {
+            guard let vc = navViewController, let mv = vc.navigationMapView?.mapView else { return }
+            let ids = (nearbyRadarIds as? [String]) ?? []
+            let hash = ids.sorted().joined(separator: "|").hashValue
+            if hash != lastNearbyIdsHash {
+                lastNearbyIdsHash = hash
+                updateHighlightFilterAndPulse(style: mv.mapboxMap.style, mapView: mv)
+            }
+        }
+    }
+    @objc var bottomPadding: NSNumber = 0
+    private var radarOverlayData: [[String: Any]] = []
+    private var radarBaseData: [[String: Any]] = []
+    private var lastRadarsUrlUsed: String?
+    private var lastNearbyIdsHash: Int = 0
+    private var pulseDisplayLink: CADisplayLink?
+    private var pulseValue: Float = 0
+
     override init(frame: CGRect) {
         self.embedded = false
         self.embedding = false
@@ -92,6 +122,8 @@ public class MapboxNavigationView: UIView, NavigationViewControllerDelegate {
     }
 
     public override func removeFromSuperview() {
+        pulseDisplayLink?.invalidate()
+        pulseDisplayLink = nil
         super.removeFromSuperview()
         // cleanup and teardown any existing resources
         self.navViewController?.removeFromParent()
@@ -149,6 +181,7 @@ public class MapboxNavigationView: UIView, NavigationViewControllerDelegate {
                 vc.view.frame = strongSelf.bounds
                 vc.didMove(toParent: parentVC)
                 strongSelf.navViewController = vc
+                strongSelf.scheduleRadarsSetup()
             }
 
             strongSelf.embedding = false
@@ -191,4 +224,387 @@ public class MapboxNavigationView: UIView, NavigationViewControllerDelegate {
         ])
         return true;
     }
+
+    // MARK: - Radares (paridade com Android)
+
+    private var radarTapGesture: UITapGestureRecognizer?
+    private weak var radarTapMapView: MapView?
+
+    private func scheduleRadarsSetup() {
+        guard let mapView = navViewController?.navigationMapView?.mapView else {
+            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in self?.scheduleRadarsSetup() }
+            return
+        }
+        if radarTapGesture == nil {
+            let tap = UITapGestureRecognizer(target: self, action: #selector(radarTapRecognized(_:)))
+            tap.cancelsTouchesInView = false
+            mapView.addGestureRecognizer(tap)
+            radarTapGesture = tap
+            radarTapMapView = mapView
+        }
+        mapView.mapboxMap.onNext(event: .styleLoaded) { [weak self] _ in
+            self?.performUpdateRadars(mapView: mapView)
+        }
+        // Fallback: tentar ap√≥s delay (estilo pode j√° estar carregado)
+        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { [weak self] in
+            guard let self = self, let mv = self.navViewController?.navigationMapView?.mapView else { return }
+            if mv.mapboxMap.style.sourceExists(withId: "radars-source") { return }
+            self.performUpdateRadars(mapView: mv)
+        }
+    }
+
+    @objc private func radarTapRecognized(_ gesture: UITapGestureRecognizer) {
+        let pt = gesture.location(in: gesture.view)
+        handleRadarTap(at: pt)
+    }
+
+    private func performUpdateRadars(mapView: MapView) {
+        let style = mapView.mapboxMap.style
+        if let urlStr = radarsGeoJsonUrl as String?, !urlStr.isEmpty, let url = URL(string: urlStr) {
+            performUpdateRadarsFromUrl(style: style, url: url, mapView: mapView)
+        } else if !radarBaseData.isEmpty || !radarOverlayData.isEmpty {
+            performUpdateRadarsFromBridge(style: style, mapView: mapView)
+        }
+    }
+
+    private func performUpdateRadarsFromUrl(style: Style, url: URL, mapView: MapView) {
+        let urlStr = url.absoluteString
+        let urlChanged = urlStr != lastRadarsUrlUsed
+        do {
+            if !style.sourceExists(withId: "radars-source") {
+                var source = GeoJSONSource()
+                source.data = .url(url)
+                source.cluster = true
+                source.clusterRadius = 50
+                source.clusterMaxZoom = 12
+                try style.addSource(source, id: "radars-source")
+                lastRadarsUrlUsed = urlStr
+                addBaseRadarLayersIfNeeded(style: style, mapView: mapView)
+            } else if urlChanged {
+                try style.updateGeoJSONSource(withId: "radars-source", geoJSON: .url(url))
+                lastRadarsUrlUsed = urlStr
+            }
+            updateOverlaySource(style: style)
+            updateHighlightFilterAndPulse(style: style, mapView: mapView)
+            if nearbyIdsSet().isEmpty == false {
+                DispatchQueue.main.asyncAfter(deadline: .now() + 1.2) { [weak self] in
+                    guard let s = self else { return }
+                    s.updateHighlightFilterAndPulse(style: mapView.mapboxMap.style, mapView: mapView)
+                }
+            }
+        } catch {
+            print("MapboxNavigationView: Erro radares URL: \(error)")
+        }
+    }
+
+    private func performUpdateRadarsFromBridge(style: Style, mapView: MapView) {
+        let all = radarBaseData + radarOverlayData
+        let features = all.compactMap { dict -> Feature? in
+            guard let id = dict["id"] as? String,
+                  let lat = (dict["latitude"] as? NSNumber)?.doubleValue ?? (dict["latitude"] as? Double),
+                  let lon = (dict["longitude"] as? NSNumber)?.doubleValue ?? (dict["longitude"] as? Double) else { return nil }
+            let typeStr = ((dict["type"] as? String) ?? "unknown").lowercased()
+            let speed = (dict["speedLimit"] as? NSNumber)?.doubleValue ?? (dict["speedLimit"] as? Double)
+            let (icon, size) = iconForRadar(type: typeStr, speedLimit: speed)
+            var feature = Feature(geometry: .point(Point(CLLocationCoordinate2D(latitude: lat, longitude: lon))))
+            feature.properties = [
+                "id": .string(id),
+                "iconImage": .string(icon),
+                "iconSize": .string(String(size))
+            ]
+            return feature
+        }
+        let fc = FeatureCollection(features: features)
+        do {
+            if !style.sourceExists(withId: "radars-source") {
+                var source = GeoJSONSource()
+                source.data = .featureCollection(fc)
+                source.cluster = true
+                source.clusterRadius = 50
+                try style.addSource(source, id: "radars-source")
+                addBaseRadarLayersIfNeeded(style: style, mapView: mapView)
+            } else {
+                try style.updateGeoJSONSource(withId: "radars-source", geoJSON: .featureCollection(fc))
+            }
+            updateHighlightFilterAndPulse(style: style, mapView: mapView)
+        } catch {
+            print("MapboxNavigationView: Erro radares bridge: \(error)")
+        }
+    }
+
+    private func ensureRadarImagesInStyle(style: Style) {
+        let placas = [0, 10] + Array(stride(from: 20, through: 160, by: 10))
+        let iconIds = ["radar_semaforico", "radar_movel", "radar_fixo"] + placas.map { "placa\($0)" }
+        for id in iconIds {
+            if style.imageExists(withId: id) { continue }
+            let camel = id.split(separator: "_").enumerated().map { $0.offset == 0 ? String($0.element) : String($0.element).capitalized }.joined()
+            let candidates = [id, camel, "radarSemaforico", "radarMovel", "radarFixo", "assets_images_\(id)"]
+            var added = false
+            for name in candidates {
+                if let img = UIImage(named: name) ?? (Bundle.main.path(forResource: name, ofType: "png").flatMap { UIImage(contentsOfFile: $0) }) {
+                    try? style.addImage(img, id: id, sdf: false, stretchX: [], stretchY: [], content: nil)
+                    added = true
+                    break
+                }
+            }
+            if !added, let fallback = makePlaceholderRadarImage() {
+                try? style.addImage(fallback, id: id, sdf: false, stretchX: [], stretchY: [], content: nil)
+            }
+        }
+    }
+
+    private func makePlaceholderRadarImage() -> UIImage? {
+        let size: CGFloat = 32
+        UIGraphicsBeginImageContextWithOptions(CGSize(width: size, height: size), false, 0)
+        defer { UIGraphicsEndImageContext() }
+        guard let ctx = UIGraphicsGetCurrentContext() else { return nil }
+        ctx.setFillColor(UIColor.systemYellow.cgColor)
+        ctx.fillEllipse(in: CGRect(x: 0, y: 0, width: size, height: size))
+        ctx.setStrokeColor(UIColor.white.cgColor)
+        ctx.setLineWidth(2)
+        ctx.strokeEllipse(in: CGRect(x: 1, y: 1, width: size - 2, height: size - 2))
+        return UIGraphicsGetImageFromCurrentImageContext()
+    }
+
+    private func iconForRadar(type: String, speedLimit: Double?) -> (String, Double) {
+        if type.contains("semaforo") || type.contains("camera") || type.contains("fotografica") {
+            return ("radar_semaforico", 0.05)
+        }
+        if type.contains("movel") || type.contains("mobile") {
+            return ("radar_movel", 0.05)
+        }
+        if type.contains("fixo") || type.contains("placa") {
+            let speeds = [20.0, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160]
+            let s = speedLimit ?? 0
+            let closest = speeds.min(by: { abs($0 - s) < abs($1 - s) }) ?? 0
+            return (closest > 0 ? "placa\(Int(closest))" : "radar_fixo", 0.18)
+        }
+        return ("radar_movel", 0.05)
+    }
+
+    private func addBaseRadarLayersIfNeeded(style: Style, mapView: MapView) {
+        if style.layerExists(withId: "radars-cluster-layer") { return }
+        ensureRadarImagesInStyle(style: style)
+        let layerPos: LayerPosition? = style.layerExists(withId: "mapbox-navigation-route-line") ? .below("mapbox-navigation-route-line") : nil
+        do {
+            var sym = SymbolLayer(id: "radars-layer-symbol")
+            sym.source = "radars-source"
+            sym.filter = Exp(.not) { Exp(.has) { "point_count" } }
+            sym.iconImage = .expression(Exp(.get) { "iconImage" })
+            sym.iconSize = .expression(Exp(.get) { "iconSize" })
+            sym.iconAllowOverlap = .constant(true)
+            sym.iconIgnorePlacement = .constant(true)
+            try style.addPersistentLayer(sym, layerPosition: layerPos)
+
+            var cluster = CircleLayer(id: "radars-cluster-layer")
+            cluster.source = "radars-source"
+            cluster.filter = Exp(.has) { "point_count" }
+            cluster.circleColor = .constant(StyleColor(.systemYellow))
+            cluster.circleRadius = .constant(20)
+            cluster.circleStrokeWidth = .constant(2)
+            cluster.circleStrokeColor = .constant(StyleColor(.systemYellow))
+            try style.addPersistentLayer(cluster, layerPosition: layerPos)
+
+            var count = SymbolLayer(id: "radars-cluster-count-layer")
+            count.source = "radars-source"
+            count.filter = Exp(.has) { "point_count" }
+            count.textField = .expression(Exp(.toString) { Exp(.get) { "point_count" } })
+            count.textSize = .constant(12)
+            count.textColor = .constant(StyleColor(.white))
+            try style.addPersistentLayer(count, layerPosition: layerPos)
+
+            let filter = buildHighlightFilter()
+            var highlight = CircleLayer(id: "radars-highlight-layer")
+            highlight.source = "radars-source"
+            highlight.filter = filter
+            highlight.circleRadius = .constant(26)
+            highlight.circleColor = .constant(StyleColor(.systemRed))
+            highlight.circleOpacity = .constant(0.45)
+            highlight.circleStrokeWidth = .constant(2)
+            highlight.circleStrokeColor = .constant(StyleColor(.white))
+            try style.addPersistentLayer(highlight, layerPosition: layerPos)
+
+            if !nearbyIdsSet().isEmpty { startPulse(mapView: mapView) }
+        } catch {
+            print("MapboxNavigationView: Erro ao adicionar layers: \(error)")
+        }
+    }
+
+    private func buildHighlightFilter() -> MapboxMaps.Expression {
+        let ids = nearbyIdsSet()
+        if ids.isEmpty {
+            let json: [Any] = ["==", true, false]
+            return (try? JSONSerialization.data(withJSONObject: json)).flatMap { try? JSONDecoder().decode(MapboxMaps.Expression.self, from: $0) } ?? Exp(.eq) { true; false }
+        }
+        let arr = ids.sorted()
+        let json: [Any] = [
+            "all",
+            ["!", ["has", "point_count"]],
+            ["in", ["to-string", ["get", "id"]], ["literal", arr]]
+        ]
+        do {
+            let data = try JSONSerialization.data(withJSONObject: json)
+            return try JSONDecoder().decode(MapboxMaps.Expression.self, from: data)
+        } catch {
+            return Exp(.eq) { true; false }
+        }
+    }
+
+    private func nearbyIdsSet() -> Set<String> {
+        guard let arr = nearbyRadarIds as? [String] else { return [] }
+        return Set(arr)
+    }
+
+    private func updateOverlaySource(style: Style) {
+        guard radarsGeoJsonUrl != nil, !radarOverlayData.isEmpty else { return }
+        let features = radarOverlayData.compactMap { dict -> Feature? in
+            guard let id = dict["id"] as? String,
+                  let lat = (dict["latitude"] as? NSNumber)?.doubleValue ?? (dict["latitude"] as? Double),
+                  let lon = (dict["longitude"] as? NSNumber)?.doubleValue ?? (dict["longitude"] as? Double) else { return nil }
+            let (icon, size) = iconForRadar(type: ((dict["type"] as? String) ?? "unknown").lowercased(), speedLimit: (dict["speedLimit"] as? NSNumber)?.doubleValue)
+            var f = Feature(geometry: .point(Point(CLLocationCoordinate2D(latitude: lat, longitude: lon))))
+            f.properties = ["id": .string(id), "iconImage": .string(icon), "iconSize": .string(String(size))]
+            return f
+        }
+        let fc = FeatureCollection(features: features)
+        if style.sourceExists(withId: "radars-overlay-source") {
+            try? style.updateGeoJSONSource(withId: "radars-overlay-source", geoJSON: .featureCollection(fc))
+        } else {
+            var src = GeoJSONSource()
+            src.data = .featureCollection(fc)
+            try? style.addSource(src, id: "radars-overlay-source")
+            let layerPos: LayerPosition? = style.layerExists(withId: "radars-layer-symbol") ? .above("radars-layer-symbol") : nil
+            var sym = SymbolLayer(id: "radars-overlay-symbol")
+            sym.source = "radars-overlay-source"
+            sym.iconImage = .expression(Exp(.get) { "iconImage" })
+            sym.iconSize = .expression(Exp(.get) { "iconSize" })
+            sym.iconAllowOverlap = .constant(true)
+            sym.iconIgnorePlacement = .constant(true)
+            try? style.addPersistentLayer(sym, layerPosition: layerPos)
+        }
+    }
+
+    private func updateHighlightFilterAndPulse(style: Style, mapView: MapView) {
+        guard style.sourceExists(withId: "radars-source") else { return }
+        do {
+            if style.layerExists(withId: "radars-highlight-layer") {
+                let filter = buildHighlightFilter()
+                try style.updateLayer(withId: "radars-highlight-layer", type: CircleLayer.self) { (layer: inout CircleLayer) in
+                    layer.filter = filter
+                }
+            } else {
+                addBaseRadarLayersIfNeeded(style: style, mapView: mapView)
+                return
+            }
+            if !nearbyIdsSet().isEmpty {
+                startPulse(mapView: mapView)
+            } else {
+                pulseDisplayLink?.invalidate()
+                pulseDisplayLink = nil
+            }
+        } catch {
+            print("MapboxNavigationView: Erro highlight: \(error)")
+        }
+    }
+
+    private func startPulse(mapView: MapView) {
+        guard pulseDisplayLink == nil else { return }
+        pulseValue = 0
+        pulseDisplayLink = CADisplayLink(target: self, selector: #selector(pulseTick))
+        pulseDisplayLink?.add(to: .main, forMode: .common)
+    }
+
+    @objc private func pulseTick() {
+        guard let mapView = navViewController?.navigationMapView?.mapView,
+              mapView.mapboxMap.style.layerExists(withId: "radars-highlight-layer"),
+              !nearbyIdsSet().isEmpty else {
+            pulseDisplayLink?.invalidate()
+            pulseDisplayLink = nil
+            return
+        }
+        pulseValue += 0.04
+        if pulseValue > 1 { pulseValue = 0 }
+        let sine = sin(Double(pulseValue) * .pi)
+        let radius = 26 + (44 - 26) * sine
+        let opacity = 0.45 + (0.75 - 0.45) * sine
+        try? mapView.mapboxMap.style.updateLayer(withId: "radars-highlight-layer", type: CircleLayer.self) { (layer: inout CircleLayer) in
+            layer.circleRadius = .constant(radius)
+            layer.circleOpacity = .constant(opacity)
+        }
+    }
+
+    func setRadarsGeoJsonUrl(_ url: String?) {
+        radarsGeoJsonUrl = url as NSString?
+        if let vc = navViewController, let mv = vc.navigationMapView?.mapView {
+            performUpdateRadars(mapView: mv)
+        }
+    }
+
+    func setBaseRadars(_ radars: [[String: Any]]) {
+        radarBaseData = radars
+        if let vc = navViewController, let mv = vc.navigationMapView?.mapView {
+            performUpdateRadars(mapView: mv)
+        }
+    }
+
+    func setOverlayRadars(_ radars: [[String: Any]]) {
+        radarOverlayData = radars
+        if let vc = navViewController, let mv = vc.navigationMapView?.mapView {
+            performUpdateRadars(mapView: mv)
+        }
+    }
+
+    @objc func setBaseRadars(_ value: NSArray?) {
+        let list: [[String: Any]] = (value as? [[String: Any]]) ?? (value?.compactMap { item -> [String: Any]? in
+            if let d = item as? [String: Any] { return d }
+            if let d = item as? NSDictionary { return d as? [String: Any] }
+            return nil
+        } ?? [])
+        setBaseRadars(list)
+    }
+
+    @objc func setOverlayRadars(_ value: NSArray?) {
+        let list: [[String: Any]] = (value as? [[String: Any]]) ?? (value?.compactMap { item -> [String: Any]? in
+            if let d = item as? [String: Any] { return d }
+            if let d = item as? NSDictionary { return d as? [String: Any] }
+            return nil
+        } ?? [])
+        setOverlayRadars(list)
+    }
+
+    func setNearbyRadarIds(_ ids: [String]) {
+        let hash = ids.sorted().joined(separator: "|").hashValue
+        if hash == lastNearbyIdsHash { return }
+        lastNearbyIdsHash = hash
+        nearbyRadarIds = ids as NSArray
+        if let vc = navViewController, let mv = vc.navigationMapView?.mapView {
+            updateHighlightFilterAndPulse(style: mv.mapboxMap.style, mapView: mv)
+        }
+    }
+
+    func handleRadarTap(at point: CGPoint) {
+        guard let mapView = navViewController?.navigationMapView?.mapView else { return }
+        let options = RenderedQueryOptions(layerIds: ["radars-layer-symbol", "radars-cluster-layer", "radars-overlay-symbol"], filter: nil)
+        mapView.mapboxMap.queryRenderedFeatures(with: point, options: options) { [weak self] result in
+            switch result {
+            case .success(let features):
+                guard !features.isEmpty else { return }
+                let qf = features[0]
+                let feature = qf.feature
+                if let ptCount = feature.properties?["point_count"], case .number(let n) = ptCount, n > 0 { return }
+                if case .point(let pt) = feature.geometry {
+                    let c = pt.coordinates
+                    var evt: [String: Any] = [
+                        "id": feature.properties?["id"]?.rawValue as? String ?? "",
+                        "latitude": c.latitude,
+                        "longitude": c.longitude
+                    ]
+                    if case .number(let s) = feature.properties?["speedLimit"] ?? .null { evt["speedLimit"] = s }
+                    if case .string(let t) = feature.properties?["type"] ?? .null { evt["type"] = t }
+                    self?.onRadarTap?(evt)
+                }
+            case .failure: break
+            }
+        }
+    }
 }
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/ios/MapboxNavigationViewManager.m b/node_modules/@pawan-pk/react-native-mapbox-navigation/ios/MapboxNavigationViewManager.m
index 4ea4beb..223d513 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/ios/MapboxNavigationViewManager.m
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/ios/MapboxNavigationViewManager.m
@@ -31,4 +31,18 @@ RCT_EXPORT_VIEW_PROPERTY(language, NSString)
 RCT_EXPORT_VIEW_PROPERTY(distanceUnit, NSString)
 RCT_EXPORT_VIEW_PROPERTY(mute, BOOL)
 
+// Radares (paridade com Android)
+RCT_EXPORT_VIEW_PROPERTY(onRadarTap, RCTDirectEventBlock)
+RCT_EXPORT_VIEW_PROPERTY(radarsGeoJsonUrl, NSString)
+RCT_EXPORT_VIEW_PROPERTY(nearbyRadarIds, NSArray)
+RCT_EXPORT_VIEW_PROPERTY(bottomPadding, NSNumber)
+RCT_CUSTOM_VIEW_PROPERTY(radars, NSArray, NSObject)
+{
+    [self performSelector:@selector(setRadars:radars:) withObject:view withObject:json];
+}
+RCT_CUSTOM_VIEW_PROPERTY(overlayRadars, NSArray, NSObject)
+{
+    [self performSelector:@selector(setOverlayRadars:overlayRadars:) withObject:view withObject:json];
+}
+
 @end
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/ios/MapboxNavigationViewManager.swift b/node_modules/@pawan-pk/react-native-mapbox-navigation/ios/MapboxNavigationViewManager.swift
index 11b240c..91b4ce2 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/ios/MapboxNavigationViewManager.swift
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/ios/MapboxNavigationViewManager.swift
@@ -22,4 +22,16 @@ class MapboxNavigationViewManager: RCTViewManager {
         }
         currentView.setWaypoints(waypoints: waypoints)
     }
+
+    @objc(setRadars:radars:)
+    public func setRadars(view: Any, radars: NSArray?) {
+        guard let currentView = view as? MapboxNavigationView else { return }
+        currentView.setBaseRadars(radars)
+    }
+
+    @objc(setOverlayRadars:overlayRadars:)
+    public func setOverlayRadars(view: Any, overlayRadars: NSArray?) {
+        guard let currentView = view as? MapboxNavigationView else { return }
+        currentView.setOverlayRadars(overlayRadars)
+    }
 }
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/src/MapboxNavigation.tsx b/node_modules/@pawan-pk/react-native-mapbox-navigation/src/MapboxNavigation.tsx
index e3d3f19..fcba4f4 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/src/MapboxNavigation.tsx
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/src/MapboxNavigation.tsx
@@ -9,8 +9,8 @@ import {
   View,
 } from 'react-native';
 
-import type { MapboxNavigationProps } from './types';
 import MapboxNavigationView from './MapboxNavigationViewNativeComponent';
+import type { MapboxNavigationProps } from './types';
 
 // import MapboxNavigationNativeComponent, {
 //   Commands,
@@ -19,9 +19,9 @@ import MapboxNavigationView from './MapboxNavigationViewNativeComponent';
 const permissions: Array<Permission> =
   Platform.OS === 'android' && Platform.Version >= 33
     ? [
-        'android.permission.ACCESS_FINE_LOCATION',
-        'android.permission.POST_NOTIFICATIONS',
-      ]
+      'android.permission.ACCESS_FINE_LOCATION',
+      'android.permission.POST_NOTIFICATIONS',
+    ]
     : ['android.permission.ACCESS_FINE_LOCATION'];
 
 type MapboxNavigationState = {
@@ -66,7 +66,7 @@ class MapboxNavigation extends React.Component<
       if (
         permissions.length > 1 &&
         result[permissions[1] as ResultKey] !==
-          PermissionsAndroid.RESULTS.GRANTED
+        PermissionsAndroid.RESULTS.GRANTED
       ) {
         const errorMessage = 'Notification permission is not granted.';
         console.warn(errorMessage);
@@ -105,6 +105,11 @@ class MapboxNavigation extends React.Component<
       onLocationChange,
       onRouteProgressChange,
       onCancelNavigation,
+      onMapClick,
+      onRadarTap,
+      onRouteAlternativeSelected,
+      onRouteChanged,
+      onMuteChange,
       onError,
       ...rest
     } = this.props;
@@ -126,6 +131,13 @@ class MapboxNavigation extends React.Component<
           onCancelNavigation={(event) =>
             onCancelNavigation?.(event.nativeEvent)
           }
+          onMapClick={(event) => onMapClick?.(event.nativeEvent)}
+          onRadarTap={(event) => onRadarTap?.(event.nativeEvent)}
+          onRouteAlternativeSelected={(event) =>
+            onRouteAlternativeSelected?.(event.nativeEvent)
+          }
+          onRouteChanged={(event) => onRouteChanged?.(event.nativeEvent)}
+          onMuteChange={(event) => onMuteChange?.(event.nativeEvent)}
           {...rest}
         />
       </View>
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/src/MapboxNavigationViewNativeComponent.ts b/node_modules/@pawan-pk/react-native-mapbox-navigation/src/MapboxNavigationViewNativeComponent.ts
index 14196df..cd27085 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/src/MapboxNavigationViewNativeComponent.ts
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/src/MapboxNavigationViewNativeComponent.ts
@@ -7,6 +7,7 @@ import codegenNativeComponent from 'react-native/Libraries/Utilities/codegenNati
 type NativeCoordinate = number[];
 interface NativeProps extends ViewProps {
   mute?: boolean;
+  volume?: number;
   separateLegs?: boolean;
   distanceUnit?: string;
   startOrigin: NativeCoordinate;
@@ -23,6 +24,8 @@ interface NativeProps extends ViewProps {
   shouldSimulateRoute?: boolean;
   showsEndOfRouteFeedback?: boolean;
   hideStatusView?: boolean;
+  recenterTrigger?: number;
+  ttsVoiceId?: string;
 }
 
 export default codegenNativeComponent<NativeProps>(
diff --git a/node_modules/@pawan-pk/react-native-mapbox-navigation/src/types.ts b/node_modules/@pawan-pk/react-native-mapbox-navigation/src/types.ts
index fb4a88f..9f8c842 100644
--- a/node_modules/@pawan-pk/react-native-mapbox-navigation/src/types.ts
+++ b/node_modules/@pawan-pk/react-native-mapbox-navigation/src/types.ts
@@ -57,6 +57,12 @@ export type NativeEventsProps = {
   onError?: (event: NativeEvent<MapboxEvent>) => void;
   onCancelNavigation?: (event: NativeEvent<MapboxEvent>) => void;
   onArrive?: (event: NativeEvent<WaypointEvent>) => void;
+  onMapClick?: (event: NativeEvent<{ latitude: number; longitude: number }>) => void;
+  onRadarTap?: (event: NativeEvent<{ id: string; latitude: number; longitude: number; speedLimit?: number; type?: string }>) => void;
+  onRouteAlternativeSelected?: (event: NativeEvent<{ routeIndex: number; source: string }>) => void;
+  onRouteChanged?: (event: NativeEvent<{ geometry: string }>) => void;
+  onMuteChange?: (event: NativeEvent<{ muted: boolean; soundEnabled: boolean }>) => void;
+  onVoiceInstructionText?: (event: NativeEvent<{ text: string }>) => void;
 };
 
 export interface MapboxNavigationProps {
@@ -94,4 +100,14 @@ export interface MapboxNavigationProps {
   onError?: (error: MapboxEvent) => void;
   onCancelNavigation?: (event: MapboxEvent) => void;
   onArrive?: (point: WaypointEvent) => void;
+  onMapClick?: (event: { latitude: number; longitude: number }) => void;
+  onRadarTap?: (event: { id: string; latitude: number; longitude: number; speedLimit?: number; type?: string }) => void;
+  onRouteAlternativeSelected?: (event: { routeIndex: number; source: string }) => void;
+  onRouteChanged?: (event: { geometry: string }) => void;
+  onMuteChange?: (event: { muted: boolean; soundEnabled: boolean }) => void;
+  /** Incrementar para for√ßar c√¢mera a voltar a seguir o usu√°rio (ex.: ao fechar modal do radar) */
+  recenterTrigger?: number;
+  /** Quando definido, instru√ß√µes de voz s√£o faladas via react-native-tts (voz do usu√°rio) em vez do TTS do Mapbox */
+  ttsVoiceId?: string | null;
+  onVoiceInstructionText?: (event: { text: string }) => void;
 }
